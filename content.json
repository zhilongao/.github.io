{"pages":[{"title":"Categories","date":"2019-08-15T09:07:03.170Z","path":"categories/index.html","text":""},{"title":"About","date":"2019-08-15T09:07:03.165Z","path":"about/index.html","text":""},{"title":"Tags","date":"2019-08-15T09:07:03.179Z","path":"tags/index.html","text":""}],"posts":[{"title":"linux系统","date":"2019-09-09T12:19:57.000Z","path":"wiki/linux-system-problem/","text":"linux三种网络模式在我们安装vmware的时候，vmware会为三种网络模式各自创建一个虚拟机网络, 其中 VMnet0(表示桥接模式) VMnet8(NAT模式) VMnet1(仅主机模式) 桥接模式 和主机一样，也会占用一个局域网中的ip。信息的发送和接受，虚拟网络适配器和主机的物理网络适配器进行交换，虚拟网络适配器可以通过主机的物理网络适配器访问外部网络。在局域网中的其它主机能够识别到发送信息的ip为该虚拟机的ip。 NAT模式 虚拟机发送数据时，NAT虚拟机网络适配器会以主机的名义将数据包裹发送出去，接收时通过特殊的标识识别。在外部网络中并不知道当前虚拟机的存在。 主机模式 仅可以和主机通信，无法访问外部网络。 ​ 一篇介绍的很形象的文章 centos7之动态ip与静态ipcentos7获取ip地址的方法主要有两种 1:动态获取 2:设置静态ip我们一般通过VMWare安装完centos7后，可以使用命令ip addr查看虚拟机的ip地址。但是刚安装完的centos7有些没有设置ip地址，我们可以通过下面两种方式来设置ip地址。1. 动态获取ip(前提是路由器已经开启了DHCP(动态主机设置协议)) a: 需要修改网卡的配置文件 /etc/sysconfig/network-scripts/ifcfg-ens33 其中ifcfg-ens33为网卡名。修改该文件的两处地方既可。 (1) bootproto=dhcp (2) onboot=yes b: 重启下网络服务 [root@mini ~]# systemctl restart network c: 通过 ip addr 命令可以看到ens33的网卡已经有相应的ip地址啦 d: 通过 ping www.baidu.com 查看网络是否通畅 在VMware里，点击'编辑'-'虚拟网络编辑器' 2. 配置静态ip地址(网络模式在nat模式下) a: 也是需要修改网卡配置文件 /etc/sysconfig/network-srcipts/ifcfg-ens33 其中ifcfg-ens33为网卡名。修改该文件的两处地方既可。 (1) bootproto=static (2) onboot=yes b: 还需要在该网卡配置文件的后面加上几行，分别是ip地址，子网掩码，网关，dns服务器 IPADDR=192.168.25.156 #静态ip NETMASK=255.255.255.0 #子网掩码 GATEWAY=192.168.1.1 #网关 DNS1=192.168.25.2 DNS2=8.8.8.8 #谷歌的dns服务器 c: 重启下网络服务 [root@mini ~]# systemctl restart network d: 通过 ip addr 命令可以看到ens33的网卡已经有新的ip地址啦 e: 通过 ping www.baidu.com 查看网络是否通畅3. 在 /etc/resolv.conf文件里面保存了dns地址，可以通过cat命令查看 在设置静态ip时,子网掩码和网关地址可以在vmware的-&gt;编辑-&gt;虚拟网络编辑器-&gt;NAT设置 中查看，如下图所示","tags":[],"categories":[{"name":"系统","slug":"系统","permalink":"https://zhilongao.github.io/categories/系统/"},{"name":"linux","slug":"系统/linux","permalink":"https://zhilongao.github.io/categories/系统/linux/"}]},{"title":"字符串","date":"2019-09-06T02:25:40.000Z","path":"wiki/string-ask/","text":"无重复字符的最长子串(leetcode第3题)// 滑动窗口解法public int lengthOfLongestSubstring(String s) &#123; int length = s.length(); int ans = 0; int left = 0; int right = 0; Set&lt;Character&gt; set = new HashSet&lt;Character&gt;(); while(left &lt; length &amp;&amp; right &lt; length) &#123; if (!set.contains(s.charAt(right))) &#123; set.add(s.charAt(right ++)); ans = Math.max(ans, right - left); &#125; else &#123; set.remove(s.charAt(left ++)); &#125; &#125; return ans;&#125; 最长回文子串(leetcode第5题)// 题目要求:给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。// 1.要判断一个字符串是否为回文字符串，可以通过下面几种方式来实现// 第一种:通过栈的后进先出原理，将字符串翻转来对比前后两个字符串是否一致public static boolean isHuiWen1(String str) &#123; Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); for (int i = 0; i &lt; str.length(); i++) &#123; stack.push(str.charAt(i)); &#125; StringBuffer buf = new StringBuffer(); while (!stack.isEmpty()) &#123; buf.append(stack.pop()); &#125; if (str.equals(buf.toString())) &#123; return true; &#125; return false;&#125;// 第二种: 取消栈的引入，直接通过逆序输出拼接字符串(减少了额外的空间Stack)public static boolean isHuiWen2(String str) &#123; StringBuffer buf = new StringBuffer(); for (int i = str.length() - 1; i &gt;= 0 ; i--) &#123; buf.append(str.charAt(i)); &#125; if (buf.toString().equals(str)) &#123; return true; &#125; return false;&#125;// 第三中: 基于回文串左右两边两个字符相等的规律，定义两个变量做对比(优势是减少了字符串str的遍历次数，时间复杂度降低)public static boolean isHuiWen3(String str) &#123; int length = str.length(); int left = 0; int right = length - 1; while (left &lt;= right) &#123; if (!(str.charAt(left) == str.charAt(right))) &#123; return false; &#125; left ++; right --; &#125; return true;&#125;// 当前这道题如何实现public String longestPalindrome(String s) &#123; // 给定一个字符串s,找到s中最长的回文子串。你可以假设s的最大长度为1000。 int len = s.length(); if (len == 0) &#123; return \"\"; &#125; int resultLen = 1; String resultStr = s.substring(0, 1); for (int i = 0; i &lt; len; i ++) &#123; // 从中间向两边查找对称的回文串 String oddStr = spread(s, len, i, i); String evenStr = spread(s, len, i, i+1); String myStr = oddStr.length() &gt;= evenStr.length() ? oddStr : evenStr; if (myStr.length() &gt; resultLen) &#123; resultStr = myStr; resultLen = resultStr.length(); &#125; &#125; return resultStr;&#125; public String spread(String s, int len, int left, int right) &#123; int l = left; int r = right; while (l &gt;= 0 &amp;&amp; r &lt; len &amp;&amp; (s.charAt(l) == s.charAt(r))) &#123; l --; r ++; &#125; return s.substring(l+1, r);&#125; 压缩字符串(leetcode第443题)// 题目要求: 给定一组字符串，使用原地算法将其压缩。// 题目解法public int compress(char[] chars) &#123; int anchor = 0; // 描点，定位可以元素 int write = 0; // 写下标，定位写的位置 for (int read = 0; read &lt; chars.length; read ++) &#123; // 若是当前元素为最后一个元素或者是后一个元素与当前元素不相等，执行写入与统计写入操作 if ((read == chars.length - 1) || (chars[read + 1] != chars[read])) &#123; // 将anchor位置处的元素写入到write位置处 chars[write ++] = chars[anchor]; // 判断该元素是否需要压缩 if (read &gt; anchor) &#123; String numStr = read - anchor + 1 + \"\"; char[] numArr = numStr.toCharArray(); for (char num : numArr) &#123; chars[write ++] = num; &#125; &#125; // 将锚点移动到下一个元素 anchor = read + 1; &#125; &#125; // 返回覆盖的个数 return write;&#125;","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"算法","slug":"java/算法","permalink":"https://zhilongao.github.io/categories/java/算法/"},{"name":"字符串","slug":"java/算法/字符串","permalink":"https://zhilongao.github.io/categories/java/算法/字符串/"}]},{"title":"array-ask","date":"2019-09-05T01:52:30.000Z","path":"wiki/array-ask/","text":"寻找递增序列// 给定一个未经过排序的数组，找到最长且连续的递增序列(在美团面试题中出现过-leetcode674题)public static int findLengthOfLCIS(int[] nums) &#123; if (nums.length == 0) &#123; return 0; &#125; int max = 0; int curr = 1; for (int i = 1; i &lt; nums.length; i ++) &#123; if (nums[i] &gt; nums[i - 1]) &#123; curr ++; &#125; else &#123; max = Math.max(max, curr); curr = 1; &#125; &#125; return Math.max(max, curr);&#125;","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"算法","slug":"java/算法","permalink":"https://zhilongao.github.io/categories/java/算法/"},{"name":"数组","slug":"java/算法/数组","permalink":"https://zhilongao.github.io/categories/java/算法/数组/"}]},{"title":"mongodb-base","date":"2019-09-03T03:45:03.000Z","path":"wiki/mongodb-base/","text":"安装步骤(centos7)1.下载安装包 wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel62-3.2.10.tgz2.解压安装包 tar -zxvf mongodb-linux-x86_64-rhel62-3.2.10.tgz 3.将解压目录移动到(/usr/local/mongodb) mv mongodb-linux-x86_64-rhel62-3.2.10 /usr/local/mongodb4.在/usr/local/mongodb目录下创建/data/db目录和/logs目录 mkdir -p /usr/local/mongodb/data/db mkdir -p /usr/local/mongodb/logs5.在/usr/local/mongodb/logs目录下创建mongodb.log文件 touch mongodb.log6.在/usr/local/mongodb/bin目录下创建mongodb的配置文件 touch mongodb.conf7.编辑mongodb.conf文件 vi mongodb.conf 编辑内容 dbpath = /usr/local/mongodb/data/db #数据文件存放目录 logpath = /usr/local/mongodb/logs/mongodb.log #日志文件存放目录 port = 27017 #端口 fork = true #以守护程序的方式启用，即在后台运行 nohttpinterface = true auth=true bind_ip=0.0.0.08.修改环境变量 vi /etc/profile 添加的内容 export MONGODB_HOME=/usr/local/mongodb export PATH=$PATH:$MONGODB_HOME/bin9.编辑完成之后重启系统配置 source /etc/profile10.在/usr/local/mongodb/bin目录下启动mongodb ./mongod -f mongodb.conf11.关闭mongodb服务 ./mongod -f ./mongodb.conf --shutdown12.开启27017端口13.使用shell登录到mongodb ./mongodb14.登录到相关数据库 use test15.创建用户 db.createUser( &#123; user: \"test\", pwd: \"test\", roles: [&#123; role: \"readWrite\", db: \"test\" &#125;] &#125; )16.修改配置，开启验证 auth=true17.重启服务 停止服务，然后启动18.登录 ./mongodb19.验证 auth('test', 'test')(返回1代表成功)20.操作 db.user.find() db.user.insert(&#123;\"name\":'jack',\"age\": 12&#125;) 基本操作-&gt;java api的crud1. 引入依赖&lt;dependency&gt; &lt;groupId&gt;org.mongodb&lt;/groupId&gt; &lt;artifactId&gt;mongo-java-driver&lt;/artifactId&gt; &lt;version&gt;3.9.1&lt;/version&gt;&lt;/dependency&gt;2.java代码// 工具类public class MongoUtil &#123; private static String baseUrl = \"192.168.25.147:27017\"; private static String userName = \"test\"; private static String passWord = \"test\"; private static final String url = \"mongodb://\"+ userName +\":\"+ passWord + \"@\"+ baseUrl + \"/\"; // 获取MongoDatabase public static MongoDatabase getConnection(String dataName) &#123; // 获取MongoClient com.mongodb.client.MongoClient mongoClient = MongoClients.create(url + dataName); // 获取MongoDatabase MongoDatabase db = mongoClient.getDatabase(dataName); return db; &#125;&#125;// 基本操作 -&gt; 获取所有public static void findAll(String databaseName, String collectionName) &#123; MongoDatabase database = MongoUtil.getConnection(databaseName); MongoCollection&lt;Document&gt; collection = database.getCollection(collectionName); FindIterable&lt;Document&gt; documents = collection.find(); print(documents);&#125;// 基本操作 -&gt; 插入public static void insert(String databaseName, String collectionName) &#123; // 获取database MongoDatabase database = MongoUtil.getConnection(databaseName); // 获取Clooection MongoCollection&lt;Document&gt; collection = database.getCollection(collectionName); // 创建Document Document document = new Document() .append(\"name\", \"mick11\") .append(\"age\", \"33\") .append(\"address\", \"长沙\") .append(\"sex\", \"男\"); // 插入document collection.insertOne(document);&#125;// 打印所有public static void print(FindIterable&lt;Document&gt; documents) &#123; for (Document document : documents) &#123; System.out.println(document.toJson()); &#125;&#125;","tags":[{"name":"mongo","slug":"mongo","permalink":"https://zhilongao.github.io/tags/mongo/"}],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"数据库","slug":"java/数据库","permalink":"https://zhilongao.github.io/categories/java/数据库/"},{"name":"mongodb","slug":"java/数据库/mongodb","permalink":"https://zhilongao.github.io/categories/java/数据库/mongodb/"}]},{"title":"实际应用","date":"2019-09-02T00:47:25.000Z","path":"wiki/redis-advance/","text":"list实现分布式队列// 需要的依赖jedis fastjson&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.4&lt;/version&gt;&lt;/dependency&gt;// 测试类/** * @Author long * @Date 2019/9/8 15:00 */public class App &#123; private static final String url = \"192.168.25.150\"; private static final int port = 6379; public static void main(String[] args) &#123; // 构建queue String queueKey = \"message_queue\"; Jedis jedis = new Jedis(url, port); // 消息转换器 MessageConvert&lt;TaskItem&gt; convert = new MessageConvert&lt;&gt;(); // 消息队列 RedisQueue queue = new RedisQueue(jedis, queueKey, convert); // 生产者 MessageProducer producer = new MessageProducer(queue); // 消费者 MessageConsumer consumer = new MessageConsumer(queue); producer.start(); consumer.start(); &#125;&#125;// 消息队列/** * @Author long * @Date 2019/9/8 14:34 * 分布式消息队列-list实现 */public class RedisQueue &#123; private Jedis jedis; private String queueKey; public RedisQueue(Jedis jedis, String queueKey, MessageConvert messageConvert) &#123; this.jedis = jedis; this.queueKey = queueKey; &#125; // 发送消息 public void push(String message) &#123; this.jedis.lpush(queueKey, message); &#125; // 消费消息-&gt;可重试 public String poll(boolean isRetry) &#123; String message = jedis.rpop(queueKey); if (message == null &amp;&amp; isRetry) &#123; try &#123; TimeUnit.MILLISECONDS.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; message = jedis.rpop(queueKey); &#125; return message; &#125;&#125;/** * @Author long * @Date 2019/9/8 15:47 * 消息生产者 */public class MessageProducer extends Thread &#123; // 队列 private RedisQueue queue; // 消息转换器 private static final MessageConvert&lt;TaskItem&gt; convert = new MessageConvert&lt;&gt;(); public MessageProducer(RedisQueue queue) &#123; this.queue = queue; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; send(\"message:\" + i); try &#123; TimeUnit.MILLISECONDS.sleep(30); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; // 创建并发送消息 private void send(String message) &#123; // 创建一条消息 TaskItem item = new TaskItem(); item.id = UUID.randomUUID().toString(); item.msg = message; // 转换为字符串发送 String sendMess = convert.messageToString(item); queue.push(sendMess); &#125;&#125;/** * @Author long * @Date 2019/9/8 15:48 * 消息消费者 */public class MessageConsumer extends Thread &#123; private RedisQueue queue; public MessageConsumer(RedisQueue queue) &#123; this.queue = queue; &#125; @Override public void run() &#123; Random random = new Random(); while (true) &#123; try &#123; TimeUnit.MILLISECONDS.sleep(random.nextInt(10)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; receive(); &#125; &#125; private void receive() &#123; Object object = queue.poll(true); if (object != null) &#123; System.out.println(object); &#125; &#125;&#125;/** * @Author long * @Date 2019/9/8 15:45 * 消息转换器 */public class MessageConvert&lt;T&gt; &#123; private Type taskType = new TypeReference&lt;T&gt;() &#123;&#125;.getType(); /** * 将给定的消息转换为string类型 * @param t * @return */ public String messageToString(T t) &#123; return JSON.toJSONString(t); &#125; /** * 将string类型的消息转换为T类型 * @param message * @return */ public T stringToObject(String message) &#123; return JSON.parseObject(message, taskType); &#125;&#125; zset实现延时队列// 测试方法private static void delayQueue() &#123; Jedis jedis = new Jedis(url, port); // 延时队列 RedisDelayingQueue queue = new RedisDelayingQueue(jedis, \"q-demo\"); DelayMessageConsumer consumer = new DelayMessageConsumer(queue); DelayMessageProducer producer = new DelayMessageProducer(queue); producer.start(); consumer.start(); try &#123; // 首先让producer线程执行完成 producer.join(); // 主线程睡眠6秒，等待consumer将消息消费完成 Thread.sleep(6000); consumer.interrupt(); consumer.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125;/** * @Author long * @Date 2019/9/7 16:56 * 延时队列-&gt; 通过zset实现 */public class RedisDelayingQueue &#123; private Jedis jedis; private String queueKey; public RedisDelayingQueue(Jedis jedis, String queueKey) &#123; this.jedis = jedis; this.queueKey = queueKey; &#125; // 执行消息的发送 public void delay(String msg, long score) &#123; jedis.zadd(queueKey, score, msg); &#125; // 执行消息的处理 public void loop(MessageHandle handle) &#123; while (!Thread.interrupted()) &#123; // fixme 此处需要优化，保证操作的原子性 // 获取一条数据(score最小的那条数据) Set values = jedis.zrangeByScore(queueKey, 0, System.currentTimeMillis(), 0, 1); // 若是队列中没有任务，线程睡眠500毫秒 if (values.isEmpty()) &#123; try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; break; &#125; continue; &#125; String value = (String) values.iterator().next(); // 从queueKey中移除该元素 if (jedis.zrem(queueKey, value) &gt; 0) &#123; // 将消息交给回调接口来处理 handle.handle(value); &#125; &#125; &#125;&#125;/** * @Author long * @Date 2019/9/8 17:13 * 延时队列-生产者线程 */public class DelayMessageProducer extends Thread &#123; RedisDelayingQueue queue; public DelayMessageProducer(RedisDelayingQueue queue) &#123; this.queue = queue; &#125; @Override public void run() &#123; Random random = new Random(); for (int i = 0; i &lt; 10 ; i++) &#123; String message = \"message:\"+ i; long score = random.nextInt(10); send(message, score); &#125; &#125; private void send(String msg, long delay) &#123; TaskItem task = new TaskItem(); task.id = UUID.randomUUID().toString(); task.msg = msg; String message = JSON.toJSONString(task); queue.delay(message, delay); &#125;&#125;/** * @Author long * @Date 2019/9/8 17:11 * 延时队列消费者线程 */public class DelayMessageConsumer extends Thread &#123; RedisDelayingQueue queue; private final static MessageHandle handle = new MessageHandle() &#123; @Override public void handle(String item) &#123; System.out.println(item); &#125; &#125;; public DelayMessageConsumer(RedisDelayingQueue queue) &#123; this.queue = queue; &#125; @Override public void run() &#123; this.queue.loop(handle); &#125;&#125;/** * @Author long * @Date 2019/9/8 17:21 * 消息处理回调接口 */public interface MessageHandle &#123; void handle(String item);&#125;","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"数据库","slug":"java/数据库","permalink":"https://zhilongao.github.io/categories/java/数据库/"},{"name":"redis","slug":"java/数据库/redis","permalink":"https://zhilongao.github.io/categories/java/数据库/redis/"}]},{"title":"单链表","date":"2019-08-31T03:56:40.000Z","path":"wiki/linked-list-ask/","text":"单链表常见操作 1.如何实现一个单链表的逆序输出-&gt;反转单链表 public static ListNode reverse(ListNode head) &#123; ListNode prev = null; ListNode next = null; while (head != null &amp;&amp; (next = head.next) != null) &#123; head.next = prev; prev = head; head = next; &#125; head.next = prev; return head;&#125;","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"算法","slug":"java/算法","permalink":"https://zhilongao.github.io/categories/java/算法/"},{"name":"链表","slug":"java/算法/链表","permalink":"https://zhilongao.github.io/categories/java/算法/链表/"}]},{"title":"排序算法","date":"2019-08-31T01:19:15.000Z","path":"wiki/arithmetic-sort/","text":"常见的排序算法 1.插入排序 // 插入排序算法// 时间复杂度：平均情况:o(n^2) 最好情况:o(n) 最坏情况:o(n^2) // 空间复杂度: o(1)// 特点: 稳定public static void insertSort(int[] array) &#123; int i,j; for (i = 1; i &lt; array.length; i ++) &#123; int temp = array[i]; for (j = i - 1; j &gt;=0 &amp;&amp; array[j] &gt; temp; j --) &#123; // 将数组中的元素后移一位 array[j + 1] = array[j]; &#125; array[j + 1] = temp; &#125;&#125; 2.选择排序 原理 // 选择排序算法// 时间复杂度: 平均情况:o(n^2) 最好情况:o(n^2) 最坏情况:o(n^2) // 空间复杂度: o(1)// 特点: 不稳定public static void selectSort(int[] array) &#123; for (int i = 0; i &lt; array.length; i ++) &#123; for (int j = i + 1; j &lt; array.length; j ++) &#123; if (array[i] &gt; array[j]) &#123; int temp = array[i]; array[i] = array[j]; array[j] = temp; &#125; &#125; &#125;&#125; 3.交换排序-&gt;冒泡排序 原理 // 冒泡排序算法// 时间复杂度: 平均情况:o(n^2) 最好情况:o(n) 最坏情况:o(n^2)// 空间复杂度: o(1)// 特点：稳定public static void bubbleSort(int[] array) &#123; for (int i = 0; i &lt; array.length; i ++) &#123; for (int j = 0; j &lt; array.length - i - 1; j ++) &#123; if (array[j] &gt; array[j + 1]) &#123; int temp = array[j]; array[j] = array[j + 1]; array[j + 1] = temp; &#125; &#125; &#125;&#125; 4.交换排序-&gt;快速排序 原理 // 快速排序算法// 时间复杂度: 平均情况:o(nlog2^n) 最好情况:o(nlog2^n) 最坏情况:o(n^2)// 空间复杂度: o(nlog2^n)// 特点：不稳定public static void fastSort(int[] array, int low, int high) &#123; if (low &gt; high) &#123; return; &#125; int i = low; int j = fast; int temp = array[low]; while (i &lt; j) &#123; // 从右向左找到第一个小于temp的元素,保存其下标 while (array[j] &gt; temp &amp;&amp; i &lt; j) &#123; j --; &#125; // 从左向右找到第一个大于temp的元素，保存其下标 while (array[i] &lt;= temp &amp;&amp; i &lt; j) &#123; i ++; &#125; // 交换这两个元素 int swap = array[i]; array[i] = array[j]; array[j] = swap; &#125; // 交换temp array[low] = array[i]; array[i] = temp; // 快排temp左半边 fastSort(array, low, j - 1); // 快排temp右半边 fastSort(array, j + 1, high);&#125; 5.归并排序 // 归并排序算法// 时间复杂度: 平均情况:o(nlog2^n) 最好情况:o(nlog2^n) 最坏情况:o(nlog2^n)// 空间复杂度：o(1)// 特点: 稳定public static void sortMerge(int[] array) &#123; sort(array, 0, array.length - 1);&#125;public static void sort(int array[], int L, int R) &#123; if (L == R) &#123; return; &#125; int mid = (R + L) / 2; // 排序左半部分 sort(array, L, mid); // 排序右半部分 sort(array, mid + 1, R); // 合并 merge(array, L, mid, R);&#125;public static void merge(int[] array, int L, int mid, int R) &#123; int[] temp = new int[R - L + 1]; int i = 0; int p1 = L; int p2 = mid + 1; // 将数组排序后放入到临时数组temp中 while (p1 &lt;= mid &amp;&amp; p2 &lt;= R) &#123; if (array[p1] &lt; array[p2]) &#123; temp[i++] = array[p1++]; &#125; else &#123; temp[i++] = array[p2++]; &#125; &#125; while(p1 &lt;= mid) &#123; temp[i++] = array[p1++]; &#125; while(p2 &lt;= R) &#123; temp[i++] = array[p2++]; &#125; // 将临时数组中的元素移动到array中 for (int k = 0; k &lt; temp.length; k ++) &#123; array[L + k] = temp[k]; &#125;&#125;","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"算法","slug":"java/算法","permalink":"https://zhilongao.github.io/categories/java/算法/"},{"name":"排序","slug":"java/算法/排序","permalink":"https://zhilongao.github.io/categories/java/算法/排序/"}]},{"title":"jvm-command","date":"2019-08-29T09:01:23.000Z","path":"wiki/jvm-command/","text":"jvm基本指令 基本指令 指令说明 iconst_1 int型常量值1进栈 bipush 将一个byte型常量值推送至栈顶 iload_1 第二个int型局部变量进栈，从0开始计数 istore_1 将栈顶int型数值存入第二个局部变量，从0开始计数","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"基础","slug":"java/基础","permalink":"https://zhilongao.github.io/categories/java/基础/"},{"name":"jvm","slug":"java/基础/jvm","permalink":"https://zhilongao.github.io/categories/java/基础/jvm/"}]},{"title":"dubbo","date":"2019-08-28T11:57:42.000Z","path":"wiki/dubbo-ask/","text":"协议","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"分布式","slug":"java/分布式","permalink":"https://zhilongao.github.io/categories/java/分布式/"}]},{"title":"博客","date":"2019-08-27T13:38:52.000Z","path":"wiki/share-articles/","text":"友情链接 任亚鹏的博客 技术大牛 小马哥 精彩社区 美团技术团队 v2ex 掘金 java技术驿站 infoq","tags":[],"categories":[]},{"title":"分库分表","date":"2019-08-27T09:08:54.000Z","path":"wiki/mysql-split/","text":"数据库优化之分库分表 针对数据库的优化有两点，第一是从整体层面优化，设计到读写分离和分库分表。第二是从sql层面优化，主要是涉及到索引相关的一些东西。 读写分离 ​ 需求: 读写分离的目的是做数据冗余备份，同时将读写分离，提升数据库的服务性能（IO性能瓶颈）。 ​ 搭建过程: 在基本操作里面-&gt;mysql配置主从同步的步骤 。 ​ 实现原理: 首先是master数据库会先将数据库的变化存储在binlog文件中。在slave数据库上，会有一个IO Thread负责将binlog文件读取到内部的relaylog文件中。同时，slave数据库上的另外一个线程SQL Thread读取relaylog，将数据写入到slave数据库里面。 ​ 细节: mysql的binlog文件存储在 /var/lib/mysql文件夹下；使用命令-&gt; mysqlbinlog –base64-output=decode-rows -v mysql-bin.000001 查看binlog的内容；binlog的格式：statement（默认，基于sql语句模式，针对数据更新的一些函数now()等，数据延迟造成的不一致），row：基于行模式，记录修改后每一条数据变化的值，mixed：混合模式，由mysql自动判断处理。 ​ 问题：同步延迟，master tps较高时出现同步延迟； 网络延迟；磁盘IO 分库分表 ​ 垂直拆分 ​ 概念:垂直拆分主要是通过业务层面，将各个业务模块所使用到的表放到各自不同的数据库里面，做到各个业务模块库相互隔离的目的。 ​ 问题:若是各个业务模块的表之间存在一些关联查询，需要将这些查询改为服务调用的方式。 针对一些全局表，可以改为服务调用的方式，对外提供服务。 ​ 水平拆分 ​ 概念:将一张大的表拆分成n多张小表。实现方式，第一种是通过一致性hash（若是新增表的话，会涉及到数据迁移的问题）。第二种是可以按照id的范围来拆分。第三种是通过日期来拆分。 ​ 问题:唯一主键问题，可以使用zk自增id 可以使用redis的自增id 可以使用代理的id Mycat 1. 从github上面clone项目 https://github.com/MyCATApache/Mycat-Server.git2. 修改项目中schema.xml配置文件中的dataHost数据库配置节点信息，修改为可用的数据库3. MycatStartup类运行main函数启动 idea启动前需要在配置参数VM options: -DMYCAT_HOME=D:\\code\\Mycat-Server\\src\\main4. 通过数据库连接工具可以连接到MyCat,数据库相关配置在server.xml配置文件里面 默认的用户名: root 密码: 123456 port: 80665. mycat里面有三个比较重要的配置文件 server.xml 配置数据库连接相关的一些信息 schema.xml 配置数据库的一些节点信息 rule.xml 配置一些路由规则6. 支持单库分表 支持跨库分表 支持配置读写分离(writeHost和readHost节点)","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"数据库","slug":"java/数据库","permalink":"https://zhilongao.github.io/categories/java/数据库/"},{"name":"mysql","slug":"java/数据库/mysql","permalink":"https://zhilongao.github.io/categories/java/数据库/mysql/"}]},{"title":"基本操作","date":"2019-08-27T09:08:25.000Z","path":"wiki/mysql-base/","text":"centos7上mysql的安装步骤 1.下载mysql的repo源 &gt; wget http://repo.mysql.com/mysql57-community-release-el7-8.noarch.rpm2.安装源&gt; rpm -ivh mysql57-community-release-el7-8.noarch.rpm3.安装数据库-&gt;yum install mysql-server4.启动数据库&gt; systemctl start mysqld5.查看mysql为root账号生成的随机密码&gt;grep \"password\" /var/log/mysqld.log 说明root@localhost:此处为随机密码6.运行mysql -uroot -p回车7.粘贴随机密码-&gt;此时已经登录到mysql数据库，需要为root账号设置密码8.由于mysql5.7有对密码设置的验证，简单密码设置不了，需要运行下面两条命令关闭验证 &gt; set global validate_password_length=1; &gt; set global validate_password_policy=0;9.修改root账号的密码 &gt; set password = password('123456');10.修改root账号的权限 &gt; GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'root' WITH GRANT OPTION;11.可以创建一个其它的用户 &gt; create user repl identified by 'repl';12.为该用户授权 &gt; grant replication slave on *.* to 'repl'@'%' identified by 'repl';(数据同步的权限) &gt; GRANT ALL ON *.* TO 'pig'@'%';(为用户pig授予所有权限) mysql配置主从同步的步骤 1.在master服务器上创建一个可以进行数据同步的账户。 &gt; create user repl identified by 'repl';2.在master服务器上为该用户授权。 &gt; grant replication slave on *.* to 'repl'@'%' identified by 'repl';3.在master服务器上修改/etc/my.cnf文件。 [mysqld] log-bin=mysql-bin server-id=1474.在master上面重启mysql &gt; systemctl restart mysqld5.在master上登录数据库，使用下面命令查看二进制文件。 &gt; show master status;6.在slave服务器上修改/etc/my.cnf文件 [mysqld] server-id=149 relay-log=slave-relay-bin relay-log-index=slave-relay-bin.index read-only=17.在slave服务器上重启mysql &gt; systemctl restart mysqld8.在slave上登录数据库, 执行下列命令，设置master相关参数。 &gt; change master to master_host='192.168.25.147',master_port=3306,master_user='repl',master_password='repl',master_log_file='mysql-bin.000003', master_log_pos=154;9.在slave上运行命令，启动服务 &gt; start slave;10.查看状态，查看主从同步设置是否成功 &gt; show slave status\\G;11.搭建完成，现在就可以玩啦，尝试在master上面创建数据库和表，在slave上会看到相应的数据库和表。","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"数据库","slug":"java/数据库","permalink":"https://zhilongao.github.io/categories/java/数据库/"},{"name":"mysql","slug":"java/数据库/mysql","permalink":"https://zhilongao.github.io/categories/java/数据库/mysql/"}]},{"title":"索引","date":"2019-08-27T09:08:17.000Z","path":"wiki/mysql-index/","text":"1.数据库四大特性 ​ A( Atomicity 原子性): 数据库最小的工作单元，整个工作单元要么一起提交成功,要么一起失败回滚。​ C( Consistency 一致性): 事物中操作的数据的状态是一致的。即写入数据的结果必须完全符合预设的规则，不会因为出现系统意外等原因导致状态的不一致。​ I( Isolation 隔离性): 一个事务所操作的数据在提交之前，对其他事务的可见性设定（一般设定为不可见）。​ D( Durability 持久性): 数据库的数据一旦提交,无法更改。 2.多个事物并发引起的数据读取问题 ​ 脏读: 是指一个事物读取到了另外一个事物未提交的数据。​ 不可重复读: 是指在一个事物未结束之前, 前后两次读取到的数据不一致现象。原因在于该事物在前后两次读取数据之间，另外一个事物修改了该数据。(不可重复读的重点在于修改)。​ 幻读: 是指当一个事物修改了数据库表中某一个范围内的数据的某一个字段，但是另外一个事物在此期间又在该范围内插入了一条新的数据，造成前一个事物出现幻觉(没有完全修改)。(幻读的重点在于新增或删除) 。 3.数据库事物的隔离级别 Read Uncommited 读未提交: 事物未提交对其它的事物也是可见的。 Read Commited 读已提交: 一个事物只能够读取到已提交的数据。(解决脏读, 未解决不可重复读)。 Repeatable Read 可重复读: 一个事物对数据的前后读取结果是一致的。(解决了不可重复读, 未解决幻读)。 Serializable 串行化: 数据库最高的隔离级别, 强制所有事物串行执行,解决了所有并发问题。 4.聚集索引和非聚集索引的区别 聚集索引: 表中的数据是按照索引的顺序来存储的。索引的叶子节点上存储了真实的数据,不会有另外单独的数据页。 非聚集索引: 表中的数据存储不依赖于索引的顺序。索引的叶子节点上存储了索引的关键字和指向真实数据的指针。 5.sql调优 ​ a. 创建索引 b.使用临时表存储中间结果-&gt;(避免多次扫描主表)。c. 避免在索引上使用计算。4.少使用select *，只返回需要的字段。 6.如何理解MVCC ​ a. 数据库每张表会单独维护两个字段，数据行版本号和删除版本号。 ​ b. 当执行insert操作时，我们开启了一个事物，执行数据插入操作时，会将这个事物的事物id设置到数据行版本号这个字段中（这个事物的事物id属于数据库一个全局属性，自增）。 ​ c. 当执行delete操作时，我们开启了一个事物，执行数据删除操作时，会将这个事物的事物id设置到删除版本号这个字段中。 ​ d. 当执行update操作时，我们开启了一个事物，指定数据更新操作时，会将这行数据copy一份，copy的这份数据数据行版本号为当前事物id，删除版本号为Null，并更新相关字段。原先那行的删除版本号会被设置为当前的事物id。 ​ e. 当我们执行数据库查询时，满足以下两点要求： ​ e1：查找数据的数据行版本号小于或等于当前事物id。(保证该条数据在当前事物开启之前就已经存在或者为该事物添加的数据。 ​ e2：查找数据的删除版本号为Null或者删除版本号大于当前事物id。（该条规则可以确保当前事物在开始之前数据还未被删除。 7.MVCC解决的问题与未解决的问题 若是一个查询先于一行的数据更新，不会出现问题。若是一个查询后于一行的数据更新，会产生脏读的问题。 8.Innodb数据库的四种隔离级别是如何实现的 ​ 读未提交：对select操作不会加锁，并发性能是最好的，但是容易造成脏读。 ​ 读已提交（互联网上默认的隔离级别）：普通的数据读取是会直接读取数据快照，加锁的select，update等操作会使用记录锁。注意：读已提交读取快照时，一个事物读取了数据，但是当第二次读取的时候，另外一个事物已经将该快照刷新了，所以会造成不可重复读的问题。 ​ 可重复读（Innodb默认的事物隔离级别）：对于普通的数据库查询，使用读取快照的方式。对于加锁的select,update等语句，他们加锁的力度取决于查询条件是使用了唯一索引还是使用了范围查询。若是使用了唯一索引，会使用记录锁的方式。若是使用了范围查询，会使用间隙锁，避免发生不可重复读。注意:当一个事物开启读取数据时，前后两次读取的都是同一个快照，这样就可以实现了可重复读。 ​ 串行化：针对所有的操作都会去加锁，普通的select操作会去加共享锁-&gt;select * from table in share mode。对于 update 等操作会加排他锁。若是一个事物查询操作时，正好有一个事物对改行的数据做修改操作。则该查询操作会阻塞，直到更新操作执行完成。 9.如何理解快照读和当前读 ​ 快照读：读取的数据是快照。当前读：读取的数据是数据库的最新的数据。","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"数据库","slug":"java/数据库","permalink":"https://zhilongao.github.io/categories/java/数据库/"},{"name":"mysql","slug":"java/数据库/mysql","permalink":"https://zhilongao.github.io/categories/java/数据库/mysql/"}]},{"title":"tcp","date":"2019-08-26T13:33:14.000Z","path":"wiki/tcp/","text":"此时握手 四次挥手 为什么要三次握手 为什么要四次挥手 socket的几种状态 ​ listen:侦听来自远方tcp端口的连接请求 ​ syn-sent:在发送连接请求后，等待匹配的连接请求。 ​ syn-receive:在收到和发送一个连接请求后，等待连接请求的确认 ​ established:代表一个打开的连接，数据可以传送给用户","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"分布式","slug":"java/分布式","permalink":"https://zhilongao.github.io/categories/java/分布式/"},{"name":"协议","slug":"java/分布式/协议","permalink":"https://zhilongao.github.io/categories/java/分布式/协议/"}]},{"title":"project-ask","date":"2019-08-26T13:26:32.000Z","path":"wiki/project-ask/","text":"项目专题 系统1 ​ 系统数据流转 ​ ​ // 大体流程1. 从原始借据表bp_collect_loan_src同步数据到bp_collect_loan，同步批次号为batch_no的数据。(同步数据时，每个线程处理数量默认为10000，若是当前批次数据量超过10000，会采用多线程来执行)2. 针对每一个原始借据，数据库里面只有可能有一条与之对应的借据，所以将bp_collect_loan存入数据库的操作采用的是insertOrUpdate操作(任务执行失败后，不会对数据库中的数据造成影响)。3. 借据同步完成之后，需要执行归案任务，就是将多个借据加工成为一个案件，以人为维度进行催收。4. 归案完成之后，需要跑规则引擎来执行分案，通过规则引擎分案之后，会在数据库表bp_collect_divide表里面生成分案记录。5. 将这些分案记录针对案件进行分案(分案记录里面存储了两类，针对个人的分案，针对组的分案)// 使用到的技术点(分布式锁 redis队列)1. 由于任务是部署在多台机器上的，多个进程执行任务时，需要获取分布式锁。项目中采用redis来实现了分布式锁，上锁命令采用set命令，外加是否存在，过期时间参数来实现。而释放锁的命令采用lua脚本来实现，因为会有两步骤操作，首先式判断上锁客户端和释放锁的客户端是否一致（存储在value中），其次是删除该锁对应的key，lua脚本保证了该操作的原子性。2. 在执行归案的过程中，针对每一个案件，需要将该案件分出去，会过规则引擎。而将分案请求交给规则引擎有两种方式，第一种是先将该案件构建成为请求，然后将该请求放到redis的同步队列里面，规则引擎那边从同步队列里面来进行消费。第二种是若同步队列已满，或者放入到同步队列出错，则会将请求直接交给规则引擎来处理。// 技术难点-如何克服","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"项目","slug":"java/项目","permalink":"https://zhilongao.github.io/categories/java/项目/"}]},{"title":"threadpool","date":"2019-08-26T13:20:13.000Z","path":"wiki/threadpool/","text":"线程池 // 创建线程池的工具类Executorspublic class Executors &#123; // 创建一个只有一个工作线程的线程池 public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); &#125; // 创建一个固定数目线程的线程池(核心线程数和最大线程数相同) public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); &#125; // 创建一个cache线程池，核心线程大小为0 public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); &#125; // 线程工厂，负责为线程池中的Worker创建线程-》可以创建个性化的线程 static class DefaultThreadFactory implements ThreadFactory &#123; private static final AtomicInteger poolNumber = new AtomicInteger(1); private final ThreadGroup group; private final AtomicInteger threadNumber = new AtomicInteger(1); private final String namePrefix; DefaultThreadFactory() &#123; SecurityManager s = System.getSecurityManager(); group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup(); namePrefix = \"pool-\" + poolNumber.getAndIncrement() + \"-thread-\"; &#125; public Thread newThread(Runnable r) &#123; // 返回的线程又将Worker做了一层封装,当该线程执行strart方法时,将会调用Worker的run方法 Thread t = new Thread(group, r, namePrefix + threadNumber.getAndIncrement(), 0); if (t.isDaemon()) t.setDaemon(false); if (t.getPriority() != Thread.NORM_PRIORITY) t.setPriority(Thread.NORM_PRIORITY); return t; &#125; &#125; &#125;// jdk定义的线程池public class ThreadPoolExecutor extends AbstractExecutorService &#123; // 核心线程数 private volatile int corePoolSize; // 最大线程数 private volatile int maximumPoolSize; // 阻塞队列 private final BlockingQueue&lt;Runnable&gt; workQueue; // 非工作线程存活时间 private volatile long keepAliveTime; // 创建线程的工厂 private volatile ThreadFactory threadFactory; // 线程池的拒绝策略 private volatile RejectedExecutionHandler handler; // 存储创建好的Worker线程 private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;(); // 主锁,对workers进行操作时会上锁 private final ReentrantLock mainLock = new ReentrantLock(); // 定义线程池内部的工作线程 private final class Worker extends AbstractQueuedSynchronizer implements Runnable&#123; // 当前Worker持有的线程 final Thread thread; // 当前Worker执行的第一个任务 Runnable firstTask; // 记录当前Worker已经完成的任务数量 volatile long completedTasks; Worker(Runnable firstTask) &#123; // 将aqs中的state值由0设置为-1,禁止中断(上锁了) setState(-1); this.firstTask = firstTask; // 调用工厂为当前的Worker创建一个Thread—&gt;传入的是当前this对象 this.thread = getThreadFactory().newThread(this); &#125; // 当前Worker线程启动需要执行的方法，该方法会由内部属性thread调用start方法时触发。 public void run() &#123; runWorker(this); &#125; // 判断线程是否被独占 protected boolean isHeldExclusively() &#123; return getState() != 0; &#125; // 尝试获取锁 protected boolean tryAcquire(int unused) &#123; if (compareAndSetState(0, 1)) &#123; setExclusiveOwnerThread(Thread.currentThread()); return true; &#125; return false; &#125; protected boolean tryRelease(int unused) &#123; setExclusiveOwnerThread(null); setState(0); return true; &#125; public void lock() &#123; acquire(1); &#125; public boolean tryLock() &#123; return tryAcquire(1); &#125; public void unlock() &#123; release(1); &#125; public boolean isLocked() &#123; return isHeldExclusively(); &#125; void interruptIfStarted() &#123; Thread t; if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) &#123; try &#123; t.interrupt(); &#125; catch (SecurityException ignore) &#123; &#125; &#125; &#125; &#125; // Worker线程执行的真正逻辑 final void runWorker(Worker w) &#123; Thread wt = Thread.currentThread(); Runnable task = w.firstTask; w.firstTask = null; w.unlock();//执行任务之前允许被打断 boolean completedAbruptly = true; try &#123; // 当前worker的task不为null或者是阻塞队列不为null,worker线程会一直运行 while (task != null || (task = getTask()) != null) &#123; // 上锁 w.lock(); if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) wt.interrupt(); try &#123; beforeExecute(wt, task); Throwable thrown = null; try &#123; // 调用worker的run方法 task.run(); &#125; catch (RuntimeException x) &#123; thrown = x; throw x; &#125; catch (Error x) &#123; thrown = x; throw x; &#125; catch (Throwable x) &#123; thrown = x; throw new Error(x); &#125; finally &#123; afterExecute(task, thrown); &#125; &#125; finally &#123; task = null; w.completedTasks++; w.unlock(); &#125; &#125; completedAbruptly = false; &#125; finally &#123; processWorkerExit(w, completedAbruptly); &#125; &#125; // 初始化一个线程池 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; &#125; // 1.若是当前工作线程数小于核心线程数, 会去创建一个核心线程。 // 2.若是当前工作线程数大于等于核心线程数，将任务放入到阻塞队列。 // 3.若是阻塞队列已满，会去创建非核心线程。 // 4.若是创建非核心线程也失败，执行拒绝策略。 public void execute(Runnable command) &#123; int c = ctl.get(); if (workerCountOf(c) &lt; corePoolSize) &#123; if (addWorker(command, true)) return; c = ctl.get(); &#125; if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; else if (!addWorker(command, false)) reject(command); &#125; // 1.尝试着将工作线程数加1，workers的个数。 // 2.创建一个Worker线程，并将其加入到workers数组中。 // 3.若是加入到workers数组成功，调用worker的thread的start方法，启动线程。 // 4.线程启动之后，会调用worker的run方法，而run方法又是调用runWorker(this)方法来执行的。 private boolean addWorker(Runnable firstTask, boolean core) &#123; retry: // 自旋 for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); if (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) return false; for (;;) &#123; int wc = workerCountOf(c); if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; if (compareAndIncrementWorkerCount(c)) break retry; c = ctl.get(); if (runStateOf(c) != rs) continue retry; &#125; &#125; boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try &#123; w = new Worker(firstTask); final Thread t = w.thread; if (t != null) &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; int rs = runStateOf(ctl.get()); if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; if (t.isAlive()) throw new IllegalThreadStateException(); // 将创建好的Worker加入到workers数组中 workers.add(w); int s = workers.size(); if (s &gt; largestPoolSize) largestPoolSize = s; workerAdded = true; &#125; &#125; finally &#123; mainLock.unlock(); &#125; if (workerAdded) &#123; t.start(); workerStarted = true; &#125; &#125; &#125; finally &#123; if (! workerStarted) addWorkerFailed(w); &#125; return workerStarted; &#125; &#125;// spring线程池-&gt;ThreadPoolTaskExecutorpublic class ThreadPoolTaskExecutor &#123; private final Object poolSizeMonitor = new Object(); // 核心线程数 private int corePoolSize = 1; // 最大线程数 private int maxPoolSize = 2147483647; // 非核心线程空闲最大存活时间 private int keepAliveSeconds = 60; // 缓存队列容量 private int queueCapacity = 2147483647; // 是否允许核心线程池超时等待(设置为false,当到达一定时间没有任务,线程池会自动关闭) private boolean allowCoreThreadTimeOut = false; private TaskDecorator taskDecorator; private ThreadPoolExecutor threadPoolExecutor; public ThreadPoolTaskExecutor() &#123; &#125; // 因为spring线程池提供了更加灵活的配置，项目中一般使用的是spring的线程池。","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"并发","slug":"java/并发","permalink":"https://zhilongao.github.io/categories/java/并发/"},{"name":"线程池","slug":"java/并发/线程池","permalink":"https://zhilongao.github.io/categories/java/并发/线程池/"}]},{"title":"lock","date":"2019-08-25T06:28:41.000Z","path":"wiki/lock/","text":"前戏java里面提供了两种锁机制，基于jvm层面实现的关键字synchronized和基于jdk层面实现的Lock锁。 synchronized关键字 基本使用：synchronized关键字可以用来修饰静态方法，普通方法，代码块，获取到的锁对象分别为当前类Class对象，当前实例对象和synchronized括号里面的对象。 加锁原理：synchronized加锁是基于对象监视器Monitor的monitorenter和monitorexit。在java中，每个对象都会有一个对象监视器，当synchronized修饰代码块时，在开始位置会加上monitorenter指令，在方法结束和异常处会插入monitorexit指令。当执行monitorentrt指令时，会去获取锁的Monitor对象，若是获取到，执行，获取不到的话，线程阻塞。 synchronized的锁升级 ​ 偏向锁：当线程执行时，会去修改对象的对象头（Mark Word）中线程id，若是修改成功，执行。若是修改不成功，需要将偏向锁升级为轻量级锁。锁升级的过程是，该获取锁的线程通知Mark Word中标识的线程，使其进入暂停状态。 ​ 轻量级锁：争抢锁的线程会去将对象的对象头（Mark Word）拷贝的线程栈中，并将对象头指向该栈（cas操作），若是执行成功，获取到锁，执行代码。若是执行失败，自旋等待其它线程释放锁。 ​ 重量级锁：当自旋超过了一定的时间之后，若是还不能获取到锁，将会升级为重量级锁，线程阻塞。 Lock接口 特性 描述 尝试非阻塞的获取锁 当前线程尝试获取锁，若这一时刻锁没有被其它线程获取到，则成功获取并持有锁。 能被中断的获取锁 获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放。 超时获取锁 在指定的时间之前获取锁，如果过了指定的时间任然无法获取到锁，则返回。 方法名称 描述 void lock() 线程获取锁，当获取到锁后，线程从该方法返回。 void lockInterruptibly() throws InteruptedExecption 与lock方法不同之处在于可以在获取锁的过程中中断当前的线程。 boolean tryLock() 尝试获取锁，获取到返回true，未获取到返回false。 boolean tryLock(long time, TimeUnit unit) throws InteruptedException; 尝试获取锁，下列三种情况下会返回：1.在指定的时间内获取到锁。2.过了超时时间为获取到锁。3.当前线程被中断。 void unlock() 释放锁 Condition newCondition() 获取等待通知组件，只有成功获取到了锁，才能创建该组件 lock和synchronized的区别 ​ 关于加锁和释放锁方式和原理的不同 synchronized是jvm层面提供的关键字，获取锁和释放锁不需要手工干预。synchronized获取锁时会获取锁定对象(静态方法-&gt;类对象，普通方法-&gt;当前对象，代码块-&gt;提供的对象)的对象监视器Monitor。一旦一个线程获取到这个对象的Monitor,其它线程就无法获取。但是同一个线程对这个Monitor可以多次获取（可重入）。对于锁的释放，当方法正常执行结束或者发生异常时，会释放该锁。 lock锁是jdk层面提供的锁，可以基于api执行上锁和解锁操作，操作更加的灵活。Lock接口实现的可重入锁ReentLock，其底层是依赖于AQS实现，AQS内部维护了一个同步队列，获取锁的线程会被加入到这个同步队列上面，等待前一个获取锁的节点释放锁时唤醒。ReentLock提供了多种获取锁的方式，可以在获取锁的时候立即响应中断。 关于等待队列和同步队列的不同 synchronized基于对象监视器，调用底层的wait方法时，会将线程加入到等待队列中，内部只维护了一个等待队列，而调用notify或者notifyAll时，会将唤醒的线程加入到同步队列。 ReentLock内部可以创建多个等待队列，可以调用await方法将获取到锁的线程加入到等待队列，也可以调用singal,singalAll唤醒线程，将其加入到同步队列中。","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"并发","slug":"java/并发","permalink":"https://zhilongao.github.io/categories/java/并发/"},{"name":"锁","slug":"java/并发/锁","permalink":"https://zhilongao.github.io/categories/java/并发/锁/"}]},{"title":"http","date":"2019-08-24T01:51:41.000Z","path":"wiki/http/","text":"对http协议的理解 ​ http协议是一种基于客户端-&gt;服务器模式的协议，客户端发送请求，服务器返回响应。http协议通过uri定位访问的资源。http协议是一种无状态的协议，服务 器无法识别同一浏览器的前后两次请求（为解决无状态,浏览器端引入了cookie机制）。 http响应状态码 状态码 类别 原因短语 1XX Informational（信息性状态码） 接收的请求正在处理 2XX Success（成功状态码） 请求正常处理完毕 3XX Redirection（重定向状态码） 需要进行附加操作以完成请求 4XX Client Error（客户端错误） 服务器无法处理请求 5XX Server Error （服务端错误） 服务器处理请求出错 http请求首部常用字段 Accept：用户代理可处理的媒体类型。 Accept-Encoding：优先的内容编码。 Accept-Language：优先的语言。 Content-Type：实体类型。 跨域问题","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"分布式","slug":"java/分布式","permalink":"https://zhilongao.github.io/categories/java/分布式/"},{"name":"协议","slug":"java/分布式/协议","permalink":"https://zhilongao.github.io/categories/java/分布式/协议/"}]},{"title":"io","date":"2019-08-23T09:43:24.000Z","path":"wiki/io/","text":"1.在jdk1.4，java引入了nio，nio是一种非阻塞io。 在nio中有三个概念 缓冲区(buffer)：java nio中数据的读取和存放需要通过缓冲区。 通道(channel)：可以理解为io中流的概念 ，与流不同的是，一个通道中既可以进行数据的读取，也可以进行数据的写入，而在io模型中，数据的读取和写入会有专门的输入和输出流来进行操作。 选择器(select)：通道可以在选择器上注册相关的事件，而选择器会有一个专门的线程来负责轮询这些事件，当某个写入事件或是读取事件可写或可读时，会交给相应的线程来处理。 通过java nio模拟一个服务端-客户端通信的实例 /** * NIO Server服务 */class NIOServer&#123; // Selector-&gt;注册channel Selector selector = null; // ServerSocketChannel-&gt;服务端channel,类似ServerSocket ServerSocketChannel serverSocketChannel; // 处理selector轮询事件 private ChannelHandle handle; // NIO服务关闭标识 private volatile boolean stop = false; NIOServer(int port) &#123; try &#123; selector = Selector.open(); serverSocketChannel = ServerSocketChannel.open(); // 设置channel为非阻塞模式 serverSocketChannel.configureBlocking(false); // 为channel绑定端口 serverSocketChannel.bind(new InetSocketAddress(port)); // 将channel注册到selector上，监听连接事件 serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT); handle = new ChannelHandle(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 启动服务 * @throws IOException */ public void start() throws IOException &#123; while (!stop) &#123; // 获取到等待处理的IO事件数量 int readyChannels = selector.select(); // 若是等待处理的IO事件数量为0,不处理 if (readyChannels == 0) &#123; continue; &#125; Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator(); // 处理这些SelectionKey while (iterator.hasNext()) &#123; // 获取到该key SelectionKey key = iterator.next(); // 移除该key iterator.remove(); // 分别处理各自事件 if (key.isAcceptable()) &#123; handle.handleAccept(key); &#125; else if (key.isReadable()) &#123; handle.handleRead(key); &#125; else if (key.isWritable()) &#123; handle.handleWrite(key); &#125; &#125; &#125; &#125; // 停止该服务 public void stop() &#123; this.stop = true; &#125;&#125;/** * 针对selector上不同事件的处理类 */class ChannelHandle &#123; /** * 处理连接事件 * @param key * @throws IOException */ public void handleAccept(SelectionKey key) throws IOException &#123; ServerSocketChannel ssc = (ServerSocketChannel) key.channel(); SocketChannel sc = ssc.accept(); sc.configureBlocking(false); sc.register(key.selector(), SelectionKey.OP_READ); &#125; /** * 处理可读事件 * @param key * @throws IOException */ public void handleRead(SelectionKey key) throws IOException &#123; SocketChannel sc = (SocketChannel) key.channel(); // fixme 对读取到的数据进行处理-&gt;相关协议解析 sc.register(key.selector(), SelectionKey.OP_WRITE); &#125; /** * 处理可写事件 * @param key * @throws IOException */ public void handleWrite(SelectionKey key) throws IOException &#123; System.out.println(\"处理写数据\"); // fixme 对输出结果按照相关协议进行封装 String header = \"HTTP/1.1 200 OK\\r\\n\"; StringBuffer result = new StringBuffer(header); result.append(\"Content-Type:application/json\\n\"); result.append(\"\\r\\n\"); result.append(\"hello,world\"); SocketChannel channel = (SocketChannel)key.channel(); ByteBuffer wrap = ByteBuffer.wrap(result.toString().getBytes()); channel.write(wrap); channel.close(); &#125;&#125;// 调用类public class NIOUtil &#123; public static void main(String[] args) &#123; // 启动一个基于NIO的服务 NIOServer nioServer = new NIOServer(8070); try &#123; nioServer.start(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 下面是通过java io的方式来实现的 public class IOUtil &#123; public static void main(String[] args) &#123; IOServer.createServer(); &#125;&#125;class IOServer &#123; private static volatile boolean stop = false; /** * 开启服务 */ static void createServer() &#123; ExecutorService executorService = Executors.newFixedThreadPool(3); ServerSocket serverSocket = null; try &#123; serverSocket = new ServerSocket(8090); System.out.println(\"服务器在端口8090上启动。。。\"); while (!stop) &#123; try &#123; Socket socket = serverSocket.accept(); // 将任务提交给线程池来处理 executorService.execute(new SocketHandle(socket)); &#125; catch (Exception e) &#123; e.printStackTrace(); break; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (serverSocket != null) &#123; serverSocket.close(); &#125; executorService.shutdown(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 关闭服务 */ static void stopServer() &#123; stop = true; &#125;&#125;/** * socket处理线程类 */class SocketHandle implements Runnable &#123; private Socket socket; SocketHandle(Socket socket) &#123; super(); this.socket = socket; &#125; @Override public void run() &#123; // 处理输入 InputStream is = null; InputStreamReader isr = null; BufferedReader br = null; try &#123; is = socket.getInputStream(); isr = new InputStreamReader(is); br = new BufferedReader(isr); String s = null; while ((s = br.readLine()) != null &amp;&amp; s.length() &gt; 0) &#123; System.out.println(s); s = null; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; &#125; // 处理输出 \\r\\n 回车换行 OutputStream os = null; try &#123; os = socket.getOutputStream(); os.write(\"HTTP/1.1 200 OK\\r\\n\".getBytes()); os.write(\"Content-Type:application/json\\n\".getBytes()); os.write(\"\\r\\n\".getBytes()); os.write(\"hello,world\".getBytes()); os.flush(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (socket != null) &#123; try &#123; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"基础","slug":"java/基础","permalink":"https://zhilongao.github.io/categories/java/基础/"},{"name":"io","slug":"java/基础/io","permalink":"https://zhilongao.github.io/categories/java/基础/io/"}]},{"title":"thread","date":"2019-08-21T05:43:50.000Z","path":"wiki/thread/","text":"为什么使用多线程 ​ 更多的处理器核心 更快的响应时间 更好的编程模型 线程的六种状态 状态 状态说明 NEW 初始状态，线程已经被构建，但是没有调用start()方法。 RUNNABLE 线程处于运行状态或者是可运行状态。 BLOCKED 阻塞状态，表示当前线程等待获取锁。 WAITING 等待状态，需要其他线程唤醒。 TIME_WAITING 超时等待状态，需要其他线程唤醒或者过了超时时间自动唤醒。 TERMINATED 终止状态，表示当前线程已经运行结束。 如何查看线程信息 ​ jps:该命令可以获取进程id。 ​ jstack:使用 jstack 进程id，可以查看线程的一些信息。 线程的初始化 private void init(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc, boolean inheritThreadLocals) &#123; if (name == null) &#123; throw new NullPointerException(\"name cannot be null\"); &#125; this.name = name; // 创建的这个线程的父线程就是当前的这个线程 Thread parent = currentThread(); SecurityManager security = System.getSecurityManager(); if (g == null) &#123; if (security != null) &#123; g = security.getThreadGroup(); &#125; if (g == null) &#123; g = parent.getThreadGroup(); &#125; &#125; g.checkAccess(); if (security != null) &#123; if (isCCLOverridden(getClass())) &#123; security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION); &#125; &#125; g.addUnstarted(); // 设置当前线程的线程组信息 this.group = g; // 将daemon priority设置为父线程的相关属性 this.daemon = parent.isDaemon(); this.priority = parent.getPriority(); if (security == null || isCCLOverridden(parent.getClass())) this.contextClassLoader = parent.getContextClassLoader(); else this.contextClassLoader = parent.contextClassLoader; this.inheritedAccessControlContext = acc != null ? acc : AccessController.getContext(); this.target = target; setPriority(priority); if (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != null) this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); this.stackSize = stackSize; tid = nextThreadID();&#125; 如何优雅的终止线程 ​ 使用volidate修饰的变量 中断线程interrupt()方法 在class所在目录下，使用javap -v HelloWorld.class指令可以查看该class的信息 管道输入输出流–&gt;用于线程之间数据的传输，传输媒介为内存 ​ PipedInputStream ​ PipedOutputStram ​ PipedReader ​ PipedWriter","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"并发","slug":"java/并发","permalink":"https://zhilongao.github.io/categories/java/并发/"},{"name":"基础","slug":"java/并发/基础","permalink":"https://zhilongao.github.io/categories/java/并发/基础/"}]},{"title":"springboot","date":"2019-08-21T01:58:17.000Z","path":"wiki/springboot/","text":"// AutoConfigurationImportSelectorpublic String[] selectImports(AnnotationMetadata annotationMetadata) &#123; // 判断自动装配是否开启，读取环境变量中spring.boot.enableautoconfiguration的属性值 if (!isEnabled(annotationMetadata)) &#123; return NO_IMPORTS; &#125; // 获取到autoConfigurationMetadata AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader .loadMetadata(this.beanClassLoader); AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata); return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());&#125;protected AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata,AnnotationMetadata annotationMetadata) &#123; // 做了重复判断 if (!isEnabled(annotationMetadata)) &#123; return EMPTY_ENTRY; &#125; // 获取到@EnableAutoConfiguration注解上的相关属性值exclude excludeName AnnotationAttributes attributes = getAttributes(annotationMetadata); // 获取到需要自动装配的类的全限定名集合 List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes); // 将互选名单先进行去重 configurations = removeDuplicates(configurations); // 获取需要排除的自动装配项exclude excludeName或者是环境变量中获取 Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes); checkExcludedClasses(configurations, exclusions); // 将需要排除的自动装配项移除 configurations.removeAll(exclusions); // 过滤掉相关的装配项 configurations = filter(configurations, autoConfigurationMetadata); // 触发自动装配组件的导入事件 fireAutoConfigurationImportEvents(configurations, exclusions); return new AutoConfigurationEntry(configurations, exclusions);&#125;protected AnnotationAttributes getAttributes(AnnotationMetadata metadata) &#123; // 获取到EnableAutoConfiguration注解的全限定名 // org.springframework.boot.autoconfigure.EnableAutoConfiguration String name = getAnnotationClass().getName(); // 获取该@EnableAutoConfiguration注解上的exclude和excludeName属性 AnnotationAttributes attributes = AnnotationAttributes.fromMap(metadata.getAnnotationAttributes(name, true)); Assert.notNull(attributes, () -&gt; \"No auto-configuration attributes found. Is \" + metadata.getClassName() + \" annotated with \" + ClassUtils.getShortName(name) + \"?\"); return attributes;&#125;// 通过spring的spi机制SpringFactoriedLoader加载需要自动装配的候选组件类全限定名protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123; List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader()); return configurations;&#125;// 获取被排除在外的类全限定名protected Set&lt;String&gt; getExclusions(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123; Set&lt;String&gt; excluded = new LinkedHashSet&lt;&gt;(); excluded.addAll(asList(attributes, \"exclude\")); excluded.addAll(Arrays.asList(attributes.getStringArray(\"excludeName\"))); excluded.addAll(getExcludeAutoConfigurationsProperty()); return excluded;&#125;// 从环境变量中获取spring.autoconfigure.exclude属性的值private List&lt;String&gt; getExcludeAutoConfigurationsProperty() &#123; if (getEnvironment() instanceof ConfigurableEnvironment) &#123; Binder binder = Binder.get(getEnvironment()); return binder.bind(PROPERTY_NAME_AUTOCONFIGURE_EXCLUDE, String[].class).map(Arrays::asList).orElse(Collections.emptyList()); &#125; String[] excludes = getEnvironment().getProperty(PROPERTY_NAME_AUTOCONFIGURE_EXCLUDE, String[].class); return (excludes != null) ? Arrays.asList(excludes) : Collections.emptyList();&#125;// 对配置项执行过滤的方法private List&lt;String&gt; filter(List&lt;String&gt; configurations, AutoConfigurationMetadata autoConfigurationMetadata) &#123; long startTime = System.nanoTime(); String[] candidates = StringUtils.toStringArray(configurations); boolean[] skip = new boolean[candidates.length]; boolean skipped = false; // 关键点-&gt;getAutoConfigurationImportFilters() for (AutoConfigurationImportFilter filter : getAutoConfigurationImportFilters()) &#123; invokeAwareMethods(filter); boolean[] match = filter.match(candidates, autoConfigurationMetadata); for (int i = 0; i &lt; match.length; i++) &#123; if (!match[i]) &#123; skip[i] = true; candidates[i] = null; skipped = true; &#125; &#125; &#125; if (!skipped) &#123; return configurations; &#125; List&lt;String&gt; result = new ArrayList&lt;&gt;(candidates.length); for (int i = 0; i &lt; candidates.length; i++) &#123; if (!skip[i]) &#123; result.add(candidates[i]); &#125; &#125; return new ArrayList&lt;&gt;(result);&#125;// AutoConfigurationImportFilter实现类加载protected List&lt;AutoConfigurationImportFilter&gt; getAutoConfigurationImportFilters() &#123; return SpringFactoriesLoader.loadFactories(AutoConfigurationImportFilter.class, this.beanClassLoader);&#125; // SpringFactoriesLoaderpublic static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) &#123; String factoryClassName = factoryClass.getName(); // 第一步:获取所有列表 第二步:获取指定key的列表 return loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());&#125;// classLoader属性值可以为nullpublic static &lt;T&gt; List&lt;T&gt; loadFactories(Class&lt;T&gt; factoryClass, @Nullable ClassLoader classLoader) &#123; // classLoader未指定,使用默认的classLoader ClassLoader classLoaderToUse = classLoader; if (classLoaderToUse == null) &#123; classLoaderToUse = SpringFactoriesLoader.class.getClassLoader(); &#125; // 调用loadFactoryNames加载指定key的扩展 List&lt;String&gt; factoryNames = loadFactoryNames(factoryClass, classLoaderToUse); List&lt;T&gt; result = new ArrayList&lt;&gt;(factoryNames.size()); for (String factoryName : factoryNames) &#123; result.add(instantiateFactory(factoryName, factoryClass, classLoaderToUse)); &#125; AnnotationAwareOrderComparator.sort(result); return result;&#125;","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"框架","slug":"java/框架","permalink":"https://zhilongao.github.io/categories/java/框架/"},{"name":"springboot","slug":"java/框架/springboot","permalink":"https://zhilongao.github.io/categories/java/框架/springboot/"}]},{"title":"spring","date":"2019-08-19T09:04:07.000Z","path":"wiki/spring/","text":"此处参考了http://www.codeceo.com/article/spring-transactions.html这篇博客，总结的挺nice的。 spring事物简介 spring基于注解的事物 ​ xml文件开启注解驱动，相关类和方法上通过@Transactional注解标识。 ​ spring在启动是会为这些class生成spring内部管理的bean，若是发现带有@Transactional注解的类和方 ​ 法，会为其生成代理类，代理类中会做相关的事物处理（正常提交，异常回滚）。 基于实现TransactionCallback接口的事物 ​ spring事物的传播属性 常量名称 常量解释 PROPAGATION_REQUIRED(propagation_required) 支持当前事物，如果当前没有事物，就新建一个事物。这是最常见的选择，也是spring默认的事物传播。 PROPAGATION_REQUIRES_NEW(propagation_requires_new) 新建事物，如果当前存在事物，就把当前事物挂起。新建的事物和挂起的事物没有任何的关系，是两个独立的事物。外层事物失败回滚之后，不能回滚内层事物执行的结果。内层事物失败抛出异常，外层事物捕获，也可以不处理回滚操作。 PROPAGATION_SUPPORTS(propagation_supports) 支持当前事物，如果当前没有事物，就以非事物的方式执行。 PROPAGATION_MANDATORY(propagation_mandatory) 支持当前事物，如果当前没有事物，就抛出异常。 PROPAGATION_NOT_SUPPORTED(propagation_not_supported) 以非事物方式执行操作，如果当前存在事物，就把当前事物挂起。 PROPAGATION_NEVER(propagation_never) 以非事物方式执行操作，如果当前存在事物，就抛出异常。 PROPAGATION_NESTED(propagation_nested) 如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务，则按REQUIRED属性执行。它使用了一个单独的事务，这个事务拥有多个可以回滚的保存点。内部事务的回滚不会对外部事务造成影响。它只对DataSourceTransactionManager事务管理器起效。 数据库隔离级别 隔离级别 隔离级别的值 导致的问题 Read Uncommited 0 允许脏读，不可重复读，幻读 Read Commited 1 避免脏读，允许不可重复读和幻读 RepeatableRead 2 避免脏读和不可重复读，允许幻读 Serializable 3 避免脏读 ，不可重复读，幻读，事物一个一个执行，执行效率低 spring中的隔离级别 常量名称 常量解释 ISOLATION_DEFAULT(isolation_default) PlatfromTransactionManager默认的事物隔离级别，使用数据库默认的事物隔离级别。 ISOLATION_READ_UNCOMMITTED(isolation_read_uncommitted) 读未提交 ISOLATION_READ_COMMITTED(isolation_read_committed) 读已提交 ISOLATION_REPEATABLE_READ(isolation_repeatable) 可重复读 ISOLATION_SERIALIZABLE(isolation_serializable) 串行化 @Resource注解和@Autowired注解的区别 1.当单独使用@Autowired注解时，会默认按照类型装配，不适用与系统里一个接口有多个实现类的情况。2.当系统内存在多个实现类时，无法按照类型装配，@Autowired可以配合@Qualifier注解按照名称进行装配3.@Resource默认按照名称装配，可以通过指定name属性来进行按照名称来装配。4.@Resource若是指定的name为空串或者是未指定name属性，会去按照类型来装配(此时系统内只能存在一个接口实现类，否则报错)5.@Resource装配的类必须存在，否则会报错。@Autowired可以配置required=false来设置装配的bean是否是必须的。6.@Resource注解属于JSR250标准的注释，属于J2EE的。而@Autowired属于spring提供的注解。使用@Resource注解可以与spring解耦。 Restful风格 参考博客：https://blog.igevin.info/posts/restful-architecture-in-general/#restful_features 特点：资源，统一接口 ，URI和无状态 资源：就是网络上面的一个实体，或者说是网络上面的一个具体信息。 统一接口：数据的元操作，分别对应于http的四个不同的方法。 URI：可以通过一个URI访问一个具体的资源。 无状态： 为啥说spring mvc是线程安全的 ​ SpringMVC是基于方法的映射，每一个controller在容器中只有一个实例对象。若是我们在controller中使用一些共享变量时，可以使用ThreadLocal关键字来实现。但是尽量不要使用共享变量。 什么是一致性hash ​ 附上一篇比较白话的博客http://www.zsythink.net/archives/1182 为什么synchronized不能锁住基本数据类型 ​ synchronized的实现原理是在synchronized修饰的代码块的开始和结束的地方添加monitorenter和monitorexit两个字节码指令，这两个字节码指令都需要一个reference类型的参数来指明要锁定和解锁的对象。就是说每一个对象会有一个monitor对象，上锁时需要获取到这个monitor对象。 偏向锁-&gt;轻量级锁-&gt;重量级锁 获取偏向锁的流程： ​ 1. 当前线程首先会去检查对象的对象头信息中有没有存储线程id，如果没有存储线程id，设置当前线程id。 ​ 2.若是对象头中存储了线程id，当前线程会去通知该id的线程，进入到暂停状态，并将对象头线程id清空。 ​ 3.两个线程会将对象头信息拷贝到各自的栈中，并尝试使用cas操作将对象头指向该栈，操作成功执行。 4. 若是操作并成功执行自旋操作。 5. 若是在自旋指定的时间内，另一个线程执行完成了，会唤醒该自旋的线程来执行。 6. 若是在自旋的时间内，另一个线程没有执行完，自旋的线程会进入到阻塞状态。","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"框架","slug":"java/框架","permalink":"https://zhilongao.github.io/categories/java/框架/"},{"name":"spring","slug":"java/框架/spring","permalink":"https://zhilongao.github.io/categories/java/框架/spring/"}]},{"title":"基本操作","date":"2019-08-18T02:58:52.000Z","path":"wiki/redis-base/","text":"安装步骤1.安装相关库gcc # yum install gcc2.下载安装包 # wget http://download.redis.io/releases/redis-3.0.0.tar.gz3.解压安装包 # tar zxvf redis-3.0.0.tar.gz4.执行make命令 # cd redis-3.0.0/src # make5.将src目录下的相关文件拷贝到/usr/redis文件夹下 # mkdir /usr/redis # cp redis-server /usr/redis # cp redis-benchmark /usr/redis # cp redis-cli /usr/redis # cp redis.conf /usr/redis6.为redis-server和redis-cli创建软链接 # ln -s /usr/redis/redis-server /usr/bin/redis-server # ln -s /usr/redis/redis-cli /usr/bin/redis-cli 服务启动与关闭# 服务启动1.启动redis # redis-server /usr/redis/redis.conf2.若是需要在后台启动，可以修改redis.conf文件中的daemonize为yes # 服务关闭1. 强制结束程序。使用kill -9 进程的pid，强行终止Redis进程可能会导致redis持久化丢失。2. 正确停止redis的方式是向redis发送shutdown命令(关闭默认端口)。 # redis-cli shutdown cluster集群搭建开启集群 修改配置文件redis.conf中的cluster-enabled yes加入到集群 127.0.0.1:6379&gt; cluster meet 192.168.25.150 6379分配hash槽 [root@localhost redis]# redis-cli -h 192.168.25.147 -p 6379 cluster addslots &#123;0..5000&#125; string基本操作#单个操作 set name value(设置某个key-value) get name(获取某个key) exists name(判断某个key是否存在) del name(删除某个key) expire name seconds(给某个key设置expire) setex name seconds value(设置key的时候同时设置expire) setnx name value(不存在存储,存在不存储)#批量操作 mset name1 value1 name2 value2(批量插入) mget name1 name2(批量获取)#特殊操作 incr key(针对值为整数的情况,value加1) incrby key 5(针对值为整数的情况,value加5)# 使用场景 保存一些JSON序列化的用户对象信息，使用时通过JSON反序列化，一次性的获取一整个用户对象，消耗网络流量。优点是存储消耗低于hash。 list基本操作#基本操作(普通操作) rpush key value1 value2 value3(存储元素) llen key(获取列表元素个数) lpop key(从左边弹出，非阻塞) rpop key(从右边弹出，非阻塞) blpop key timeout(从左边弹出，阻塞，timeout单位为秒) brpop key timeout(从右边弹出，阻塞，timeout单位为秒)# 基本操作(慢操作) lindex key index(获取某个位置上的value) ltrim key start_index end_index(保留start_index到end_index区间内的值,index可为负数,-1表示最后一个) lrange key start_index end_index(返回start_index到end_index区间内的值) # 使用场景 异步队列(rpush lpop) 栈(rpush rpop) hash基本操作#基本操作 hset key filed value(给某个key的字典中存储一个key-value) hgetall key(查看key-value,key和value间隔出现) hlen books(查看key中存储的key-value个数) hget key filed(获取某个key下filed的value值) hmset key filed1 value1 filed2 value2(批量设置key-value) hincrby key filed 1(给某个key的field字段的value加1) #使用场景 存储用户信息-&gt;针对用户信息中的每个字段单独存储，获取用户信息时可以对部分字段单独获取,节省网络流量。但是缺点是存储消耗要高于字符串。 set基本操作#基本操作 sadd key value(集合中添加一个元素) sadd key value1 value2(集合中添加多个元素) smembers key(列出key下面的value列表) sismember key value(查询key下面是否存在value) scard key(获取key的长度) spop key(弹出一个元素) #使用场景 可以用来存储中将用户的id,因为有去重功能，所以可以保证同一个用户不会中将两次。 zset基本操作#基本操作 zadd key score value(添加一个value) zrange key 0 -1(获取key元素列表，按照score排序列出) zrevrange key 0 -1(获取key元素列表，按照score逆序列出) zcard key(返回key中元素个数) zscore key value(返回某个key的score) zrangebyscore key score1 score2(根据分值区间遍历zset) zrangebyscore key -inf score withscore (根据分值区间 (-∞, score] 遍历 zset，同时返回分值。inf 代表 infinite，无穷大的意思。)#使用场景 可以用来存储粉丝列表，value值是粉丝的用户id，score是关注时间。可以对粉丝列表按照关注时间进行排序。 可以用来存储学生的成绩，value值是学生的id, score是考试成绩。可以对成绩按照分数进行排序，就可以获取到它的名次。 sort命令# redis的sort命令可以对列表键 集合键或者有序集合键的值进行排序############## 最简单的排序 sort ########## 插入元素redis&gt; rpush numbers 5 3 1 4 2(integer) 5# 按照插入顺序排列的列表元素redis&gt;lrange numbers 0 -1# 元素的输出顺序为 \"5\" \"3\" \"1\" \"4\" \"2\"# 按值从小到大有序排列的列表元素(默认升序排列asc)redis&gt; sort numbers# 元素的输出顺序为 \"1\" \"2\" \"3\" \"4\" \"5\"# 按值从大到小有序排列的列表元素redis&gt; sort numbers desc# 元素的输出顺序为 \"5\" \"4\" \"3\" \"2\" \"1\"############ 使用 sort和alpha选项对字符串进行排序######### 插入元素reids&gt; sadd alphabet a b c d e f g# 乱序排列的集合元素redis&gt; smembers alphabet# 输出顺序为 \"d\" \"a\" \"c\" \"b\" \"g\" \"e\" \"f\"# 集合元素排序，使用alpha，asc升序排列redis&gt; sort alphabet alpha# 输出顺序为 \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\"# 集合元素排序，使用alpha，desc降序排列redis&gt; sort alphabet alpha desc# 输出顺序为 \"g\" \"f\" \"e\" \"d\" \"c\" \"b\" \"a\"############ 使用sort和by选项对元素排序 ############# 插入元素redis&gt; zadd test-result 3.0 jack 3.5 peter 4.0 tom(integer) 3# 普通输出，按照元素的分值排序redis&gt; zrange test-result 0 -1# 输出顺序为 \"jack\" \"peter\" \"tom\"# 为各个元素设置序号redis&gt; mset peter_number 1 tom_number 2 jack_number 3ok# 以序号为权重，对集合中的元素进行排序redis&gt; sort test-result by *_number# 输出顺序为 \"peter\" \"tom\" \"jack\" scan命令// scan命令的使用// scan命令提供了三个参数,第一个参数是cursor整数值，第二个是key的正则模式，第三个是遍历的limit hint。第一次遍历时，cursor值为0，然后将返回结果中第一个整数值作为下一次遍历的cursor。一直遍历到返回的cursor值为0时结束。// 可以同过java的jedis客户端插入一些keyint count = 10000;Jedis jedis = new Jedis(\"192.168.25.150\", 6379);for (int i = 0; i &lt; count; i++) &#123; jedis.set(\"key\" + i, i + \"\");&#125;// 下面是redis-cli操作127.0.0.1:6379&gt; scan 0 match key99* count 10001) \"10904\"2) 1) \"key9987\" 2) \"key9924\" 3) \"key9992\" 4) \"key9941\" 5) \"key9901\" 6) \"key9945\" 7) \"key9984\" 8) \"key9903\" 127.0.0.1:6379&gt; scan 10904 match key99* count 10001) \"14028\"2) 1) \"key9989\" 2) \"key992\" 3) \"key9997\" 4) \"key9968\" 5) \"key996\" 6) \"key9958\" //下面是java客户端操作代码段String cursor = \"0\";ScanParams scanParams = new ScanParams();scanParams.match(\"key99*\");scanParams.count(1000);while (true) &#123; ScanResult&lt;String&gt; result = jedis.scan(cursor, scanParams); List&lt;String&gt; resultList = result.getResult(); for (String resultStr : resultList) &#123; System.out.print(resultStr + \"\\t\"); &#125; System.out.println(\"\\n--------------\"); String stringCursor = result.getStringCursor(); // 当游标为再次为0时,表示已经遍历完毕,直接跳出循环 if (stringCursor.equals(\"0\")) &#123; break; &#125; else &#123; cursor = stringCursor; &#125;&#125;","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"数据库","slug":"java/数据库","permalink":"https://zhilongao.github.io/categories/java/数据库/"},{"name":"redis","slug":"java/数据库/redis","permalink":"https://zhilongao.github.io/categories/java/数据库/redis/"}]},{"title":"HashMap","date":"2019-08-16T14:01:46.000Z","path":"wiki/HashMap/","text":"1.HashMap的数据结构 在jdk1.7中基于数组+链表,在jdk1.8中基于数组+链表+红黑树 2.HashMap的put方法的过程 a.首先判断当前的数组是否被初始化,若是没有被初始化,调用resize方法初始化 b.通过key的hash值和数组长度计算出该元素在数组中的位置 c1.若是数组上没有元素,构建Node节点,存储该元素 c21.若是该数组上有元素,且第一个节点的key与要存储的key相等,用变量保存该节点。 c22.若是该数组上有元素,且第一个节点的key与要存储的key不相等,需要判断该节点类型。 若是该节点属于红黑树,将元素插入到红黑树。 若是该节点属于链表,循环遍历链表,若是没有遇到key相同的,将key-value创建称为节点,插入到链表的尾部。判断是否需要转成红黑树，若是需要，将链表转成红黑树。 d.前面的操作中，若是找到与key相同的节点,根据条件判断是否需要覆盖,若是需要覆盖,直接修改原有节点的value。 f.将元素的个数size加1并判断是否需要扩容,若是需要扩容,调用resize方法扩容。 3.HashMap的resize方法 resize方法涉及到两个大的步骤,首先是确定新数组的大小已经下次的扩容时机，新数组大小为原有数组大小的两倍，扩容变量也扩大为原有的两倍。其次是将原有数组的元素迁移至新的数组中,其中数组元素只会在两个地方，一个在[原下标]的地方，另一个在[原下标+原容量]的位置。","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"源码","slug":"java/源码","permalink":"https://zhilongao.github.io/categories/java/源码/"}]},{"title":"jvm","date":"2019-08-16T04:51:03.000Z","path":"wiki/jvm/","text":"jvm的运行时数据区 堆:java垃圾回收的主要区域，唯一存在的价值就是存放对象实例，几乎所有的对象实例都会在这里分配内存。从垃圾回收的角度分为新生代和老年代。在细分一点可以划分为Eden空间,From Survivor空间,To Survivor空间。若是在堆中没有完成实例分配，并且堆也无法再扩展时，就会抛出OutOfMemoryError异常。 方法区:用于存储已经被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。当方法区无法满足内存分配的需求时，将会抛出OutOfMemoryError异常。 虚拟机栈:描述的是java方法执行的内存模型，每个方法执行时都会创建一个栈帧，栈帧中用于存储局部变量表，操作数栈，动态链接，方法出口等信息。当线程申请的栈深度大于虚拟机所允许的栈深度，将抛出StackOverflowError异常。若是虚拟机动态扩展时无法申请到足够的内存，将会抛出OutOfMemoryError异常。 程序计数器:记录当前线程执行的字节码指令的行号，不会发生OutOfMemoryError。 本地方法栈:用于执行非java方法的内存模型，也会发生StackOverflowError和OutOfMemoryError异常。 jvm垃圾回收考虑的三个问题 回收哪些对象 什么时候回收这些对象 怎么回收这些对象 jvm垃圾回收算法 标记清除：会有内存碎片 标记整理：没有内存碎片，适合新生代对象的回收 复制算法：需要留出一部分的内存空间，利用率不高 分代收集算法：新生代死亡对象多，采用复制算法。老年代死亡对象少，采用标记整理或标记清除。 jvm垃圾收集器 ​ 新生代垃圾收集器 ​ 老年代垃圾收集器","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"基础","slug":"java/基础","permalink":"https://zhilongao.github.io/categories/java/基础/"},{"name":"jvm","slug":"java/基础/jvm","permalink":"https://zhilongao.github.io/categories/java/基础/jvm/"}]},{"title":"面试题","date":"2019-08-15T12:56:11.000Z","path":"wiki/mysql/","text":"1.char(32)和varchar(32)的区别 (1):char和varchar都是数据库定义字符串类型的数据格式,char是一种定长度的类型,varchar是一种可变长度的类型。 (2):char(32)表示定义了当前字段所占用的存储空间为32个字符,不管字段长度是否达到32,占用的空间是不变的。而varchar(32)表示定义了当前字段所能够占用的最大存储空间是32个字符,实际占用空间是字段的大小。 (3):就存储效率而言,定长的char类型由于一开始就定义好了字段占用空间,不需要根据字段的长度在去申请空间,故效率相对较高,但是在占用空间上就没有varchar有优势。而varchar由于根据字段长度调整空间占用,故空间消耗较小,但是存储效率不高。 2.sql注入,如何避免sql注入概念: 所谓sql注入, 就是攻击者将sql命令插入到web表单的输入域或者是页面请求的查询字符串，欺骗服务器执行恶意的sql命令。(某些表单中的输入命令被直接用来构造(或影响)sql命令，或者是构成存储过程的输入参数, 这类表单特别容易受到sql注入式攻击)。 如何避免: (1): mybatis中多使用[#{param}],尽量避免使用[${param}],原因在于[${param}]会直接参与sql编译,容易造成sql攻击。 3.数据库的三大范式 第一范式: 每一列都是一个不可再分割的属性值,确保每一列的原子性(规范列)。 第二范式: 在满足第一范式的要求下，每一行数据只做一件事(规范行)。 第三范式: 在满足第二范式的要求下，确保数据表中的每一列数据都和主键直接相关,而不能够间接相关。","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"数据库","slug":"java/数据库","permalink":"https://zhilongao.github.io/categories/java/数据库/"},{"name":"mysql","slug":"java/数据库/mysql","permalink":"https://zhilongao.github.io/categories/java/数据库/mysql/"}]}]}