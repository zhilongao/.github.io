{"pages":[{"title":"About","date":"2019-08-15T09:07:03.165Z","path":"about/index.html","text":""},{"title":"Categories","date":"2019-08-15T09:07:03.170Z","path":"categories/index.html","text":""},{"title":"Tags","date":"2019-08-15T09:07:03.179Z","path":"tags/index.html","text":""}],"posts":[{"title":"HashMap","date":"2019-08-16T14:01:46.000Z","path":"wiki/HashMap/","text":"wiki1.HashMap的数据结构 在jdk1.7中基于数组+链表,在jdk1.8中基于数组+链表+红黑树 2.HashMap的put方法的过程 a.首先判断当前的数组是否被初始化,若是没有被初始化,调用resize方法初始化 b.通过key的hash值和数组长度计算出该元素在数组中的位置 c1.若是数组上没有元素,构建Node节点,存储该元素 c21.若是该数组上有元素,且第一个节点的key与要存储的key相等,用变量保存该节点。 c22.若是该数组上有元素,且第一个节点的key与要存储的key不相等,需要判断该节点类型。 若是该节点属于红黑树,将元素插入到红黑树。 若是该节点属于链表,循环遍历链表,若是没有遇到key相同的,将key-value创建称为节点,插入到链表的尾部。判断是否需要转成红黑树，若是需要，将链表转成红黑树。 d.前面的操作中，若是找到与key相同的节点,根据条件判断是否需要覆盖,若是需要覆盖,直接修改原有节点的value。 f.将元素的个数size加1并判断是否需要扩容,若是需要扩容,调用resize方法扩容。 3.HashMap的resize方法 resize方法涉及到两个大的步骤,首先是确定新数组的大小已经下次的扩容时机，新数组大小为原有数组大小的两倍，扩容变量也扩大为原有的两倍。其次是将原有数组的元素迁移至新的数组中,其中数组元素只会在两个地方，一个在[原下标]的地方，另一个在[原下标+原容量]的位置。","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://gzl2017.github.io/categories/java/"},{"name":"源码","slug":"java/源码","permalink":"https://gzl2017.github.io/categories/java/源码/"}]},{"title":"jvm","date":"2019-08-16T04:51:03.000Z","path":"wiki/jvm/","text":"jvm的运行时数据区 &gt; 堆:java垃圾回收的主要区域，唯一存在的价值就是存放对象实例，几乎所有的对象实例都会在这里分配内存。从垃圾回收的角度分为新生代和老年代。在细分一点可以划分为Eden空间,From Survivor空间,To Survivor空间。若是在堆中没有完成实例分配，并且堆也无法再扩展时，就会抛出OutOfMemoryError异常。&gt; &gt; 方法区:用于存储已经被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。当方法区无法满足内存分配的需求时，将会抛出OutOfMemoryError异常。&gt; &gt; 虚拟机栈:描述的是java方法执行的内存模型，每个方法执行时都会创建一个栈帧，栈帧中用于存储局部变量表，操作数栈，动态链接，方法出口等信息。当线程申请的栈深度大于虚拟机所允许的栈深度，将抛出StackOverflowError异常。若是虚拟机动态扩展时无法申请到足够的内存，将会抛出OutOfMemoryError异常。&gt; &gt; 程序计数器:记录当前线程执行的字节码指令的行号，不会发生OutOfMemoryError。&gt; &gt; 本地方法栈:用于执行非java方法的内存模型，也会发生StackOverflowError和OutOfMemoryError异常&gt;","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://gzl2017.github.io/categories/java/"},{"name":"jvm","slug":"java/jvm","permalink":"https://gzl2017.github.io/categories/java/jvm/"}]},{"title":"mysql常见面试题","date":"2019-08-15T12:56:11.000Z","path":"wiki/mysql/","text":"1.char(32)和varchar(32)的区别 (1):char和varchar都是数据库定义字符串类型的数据格式,char是一种定长度的类型,varchar是一种可变长度的类型。 (2):char(32)表示定义了当前字段所占用的存储空间为32个字符,不管字段长度是否达到32,占用的空间是不变的。而varchar(32)表示定义了当前字段所能够占用的最大存储空间是32个字符,实际占用空间是字段的大小。 (3):就存储效率而言,定长的char类型由于一开始就定义好了字段占用空间,不需要根据字段的长度在去申请空间,故效率相对较高,但是在占用空间上就没有varchar有优势。而varchar由于根据字段长度调整空间占用,故空间消耗较小,但是存储效率不高。 2.数据库的四大特性 A(Atomicity 原子性):数据库最小的工作单元，整个工作单元要么一起提交成功,要么一起回滚失败。 C(Consistency 一致性):事物中操作的数据的状态是一致的。即写入资料的结果必须完全符合预设的规则，不会因为出现系统意外等原因导致状态的不一致。 I(Isolation 隔离性):一个事务所操作的数据在提交之前，对其他事务的可见性设定（一般设定为不可见）。 D(Durability 持久性):数据库的数据一旦提交,无法更改。3.多个事物并发引发的数据读取问题 脏读:该问题是指一个事物读取到了另外一个事物未提交的问题。 不可重复读:该问题是指在一个事物未结束之前,前后两次读取到的数据不一致现象。原因在于该事物在前后两次读取数据之间，另外一个事物修改了该数据。(不可重复读的重点在于修改) 幻读:该问题是指当一个事物修改了数据库表中某一个范围内的数据的某一个字段，但是另外一个事物在此期间又在该范围内插入了一条新的数据，造成前一个事物出现幻觉(没有完全修改)。(幻读的重点在于新增或删除) 4.数据库事物的隔离级别 Read Uncommited读未提交:事物未提交对其它的事物也是可见的。 Read Commited读已提交:一个事物只能够读取到已提交的数据。(解决脏读,未解决不可重复读) Repeatable Read可重复读:一个事物对数据的前后读取结果是一致的。(解决了不可重复读,未解决幻读) Serializable串行化:数据库最高的隔离级别,强制所有事物串行执行,解决了所有并发问题。5.聚集索引和非聚集索引的区别: 聚集索引:表中的数据是按照索引的顺序来存储的。索引的叶子节点上存储了真实的数据,不会有另外单独的数据页。 非聚集索引:表中的数据存储不依赖于索引的顺序。索引的叶子节点上存储了索引的关键字和指向真实数据的指针。6.sql注入,如何避免sql注入 概念:所谓sql注入,就是攻击者将sql命令插入到web表单的输入域或者是页面请求的查询字符串，欺骗服务器执行恶意的sql命令。(某些表单中的输入命令被直接用来构造(或影响)sql命令，或者是构成存储过程的输入参数,这类表单特别容易受到sql注入式攻击)。 如何避免: (1):mybatis中多使用#&#123;param&#125;,尽量避免使用$&#123;param&#125;,原因在于$&#123;param&#125;会直接参与sql编译,容易造成sql攻击。","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://gzl2017.github.io/categories/java/"},{"name":"mysql","slug":"java/mysql","permalink":"https://gzl2017.github.io/categories/java/mysql/"}]}]}