{"pages":[{"title":"About","date":"2019-08-15T09:07:03.165Z","path":"about/index.html","text":""},{"title":"Categories","date":"2019-08-15T09:07:03.170Z","path":"categories/index.html","text":""},{"title":"Tags","date":"2019-08-15T09:07:03.179Z","path":"tags/index.html","text":""}],"posts":[{"title":"thread","date":"2019-08-21T05:43:50.000Z","path":"wiki/thread/","text":"// ThreadPoolTaskExecutorpublic class ThreadPoolTaskExecutor &#123; private final Object poolSizeMonitor = new Object(); // 核心线程数 private int corePoolSize = 1; // 最大线程数 private int maxPoolSize = 2147483647; // 非核心线程空闲最大存活时间 private int keepAliveSeconds = 60; // 缓存队列容量 private int queueCapacity = 2147483647; // 是否允许核心线程池超时等待(设置为false,当到达一定时间没有任务,线程池会自动关闭) private boolean allowCoreThreadTimeOut = false; private TaskDecorator taskDecorator; private ThreadPoolExecutor threadPoolExecutor; public ThreadPoolTaskExecutor() &#123; &#125; // 因为spring线程池提供了更加灵活的配置，项目中一般使用的是spring的线程池。 ​ // 项目准备 从原始借据表bp_collect_loan_src中获取某个批次的原始借据总数，最小id，最大id。 会有一个数量限制，若是当前批次的原始借据数目小于10000，直接调用更新借据的操作。 若是当前这个批次的原始借据数目大于10000，获取到线程池，分批次将这些任务放到线程池，每个线程调用 更新借据的操作。 更新借据的逻辑，通过原始借据id从小到大查询原始借据，每次500条。（重试机制，当查询出现异常时，重 新查询）。 将查询到的这批原始借据加工成为催收系统里面的借据。bp_collect_loan_src –&gt; bp_collect_loan。 调用bp_collect_loan表操作mapper的insertOrUpdate方法将原始借据插入或更新到系统中。 bp_collect_loan会针对客户计算出一个hash值，作为bp_collect_loan的loadId，loadId在借据表中作为唯一 索引，当有数据的时候会更新，没有数据的时候会最添加。 上游每天会更新他们的借据信息，我们在这边只是做一个数据同步的功能。","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://gzl2017.github.io/categories/java/"},{"name":"多线程","slug":"java/多线程","permalink":"https://gzl2017.github.io/categories/java/多线程/"}]},{"title":"springboot","date":"2019-08-21T01:58:17.000Z","path":"wiki/springboot/","text":"// AutoConfigurationImportSelectorpublic String[] selectImports(AnnotationMetadata annotationMetadata) &#123; // 判断自动装配是否开启，读取环境变量中spring.boot.enableautoconfiguration的属性值 if (!isEnabled(annotationMetadata)) &#123; return NO_IMPORTS; &#125; // 获取到autoConfigurationMetadata AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader .loadMetadata(this.beanClassLoader); AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata); return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());&#125;protected AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata,AnnotationMetadata annotationMetadata) &#123; // 做了重复判断 if (!isEnabled(annotationMetadata)) &#123; return EMPTY_ENTRY; &#125; // 获取到@EnableAutoConfiguration注解上的相关属性值exclude excludeName AnnotationAttributes attributes = getAttributes(annotationMetadata); // 获取到需要自动装配的类的全限定名集合 List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes); // 将互选名单先进行去重 configurations = removeDuplicates(configurations); // 获取需要排除的自动装配项exclude excludeName或者是环境变量中获取 Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes); checkExcludedClasses(configurations, exclusions); // 将需要排除的自动装配项移除 configurations.removeAll(exclusions); // 过滤掉相关的装配项 configurations = filter(configurations, autoConfigurationMetadata); // 触发自动装配组件的导入事件 fireAutoConfigurationImportEvents(configurations, exclusions); return new AutoConfigurationEntry(configurations, exclusions);&#125;protected AnnotationAttributes getAttributes(AnnotationMetadata metadata) &#123; // 获取到EnableAutoConfiguration注解的全限定名 // org.springframework.boot.autoconfigure.EnableAutoConfiguration String name = getAnnotationClass().getName(); // 获取该@EnableAutoConfiguration注解上的exclude和excludeName属性 AnnotationAttributes attributes = AnnotationAttributes.fromMap(metadata.getAnnotationAttributes(name, true)); Assert.notNull(attributes, () -&gt; \"No auto-configuration attributes found. Is \" + metadata.getClassName() + \" annotated with \" + ClassUtils.getShortName(name) + \"?\"); return attributes;&#125;// 通过spring的spi机制SpringFactoriedLoader加载需要自动装配的候选组件类全限定名protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123; List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader()); return configurations;&#125;// 获取被排除在外的类全限定名protected Set&lt;String&gt; getExclusions(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123; Set&lt;String&gt; excluded = new LinkedHashSet&lt;&gt;(); excluded.addAll(asList(attributes, \"exclude\")); excluded.addAll(Arrays.asList(attributes.getStringArray(\"excludeName\"))); excluded.addAll(getExcludeAutoConfigurationsProperty()); return excluded;&#125;// 从环境变量中获取spring.autoconfigure.exclude属性的值private List&lt;String&gt; getExcludeAutoConfigurationsProperty() &#123; if (getEnvironment() instanceof ConfigurableEnvironment) &#123; Binder binder = Binder.get(getEnvironment()); return binder.bind(PROPERTY_NAME_AUTOCONFIGURE_EXCLUDE, String[].class).map(Arrays::asList).orElse(Collections.emptyList()); &#125; String[] excludes = getEnvironment().getProperty(PROPERTY_NAME_AUTOCONFIGURE_EXCLUDE, String[].class); return (excludes != null) ? Arrays.asList(excludes) : Collections.emptyList();&#125;// 对配置项执行过滤的方法private List&lt;String&gt; filter(List&lt;String&gt; configurations, AutoConfigurationMetadata autoConfigurationMetadata) &#123; long startTime = System.nanoTime(); String[] candidates = StringUtils.toStringArray(configurations); boolean[] skip = new boolean[candidates.length]; boolean skipped = false; // 关键点-&gt;getAutoConfigurationImportFilters() for (AutoConfigurationImportFilter filter : getAutoConfigurationImportFilters()) &#123; invokeAwareMethods(filter); boolean[] match = filter.match(candidates, autoConfigurationMetadata); for (int i = 0; i &lt; match.length; i++) &#123; if (!match[i]) &#123; skip[i] = true; candidates[i] = null; skipped = true; &#125; &#125; &#125; if (!skipped) &#123; return configurations; &#125; List&lt;String&gt; result = new ArrayList&lt;&gt;(candidates.length); for (int i = 0; i &lt; candidates.length; i++) &#123; if (!skip[i]) &#123; result.add(candidates[i]); &#125; &#125; return new ArrayList&lt;&gt;(result);&#125;// AutoConfigurationImportFilter实现类加载protected List&lt;AutoConfigurationImportFilter&gt; getAutoConfigurationImportFilters() &#123; return SpringFactoriesLoader.loadFactories(AutoConfigurationImportFilter.class, this.beanClassLoader);&#125; // SpringFactoriesLoaderpublic static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) &#123; String factoryClassName = factoryClass.getName(); // 第一步:获取所有列表 第二步:获取指定key的列表 return loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());&#125;// classLoader属性值可以为nullpublic static &lt;T&gt; List&lt;T&gt; loadFactories(Class&lt;T&gt; factoryClass, @Nullable ClassLoader classLoader) &#123; // classLoader未指定,使用默认的classLoader ClassLoader classLoaderToUse = classLoader; if (classLoaderToUse == null) &#123; classLoaderToUse = SpringFactoriesLoader.class.getClassLoader(); &#125; // 调用loadFactoryNames加载指定key的扩展 List&lt;String&gt; factoryNames = loadFactoryNames(factoryClass, classLoaderToUse); List&lt;T&gt; result = new ArrayList&lt;&gt;(factoryNames.size()); for (String factoryName : factoryNames) &#123; result.add(instantiateFactory(factoryName, factoryClass, classLoaderToUse)); &#125; AnnotationAwareOrderComparator.sort(result); return result;&#125;","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://gzl2017.github.io/categories/java/"},{"name":"springboot","slug":"java/springboot","permalink":"https://gzl2017.github.io/categories/java/springboot/"}]},{"title":"spring","date":"2019-08-19T09:04:07.000Z","path":"wiki/spring/","text":"此处参考了http://www.codeceo.com/article/spring-transactions.html这篇博客，总结的挺nice的。 spring事物简介 spring基于注解的事物 ​ xml文件开启注解驱动，相关类和方法上通过@Transactional注解标识。 ​ spring在启动是会为这些class生成spring内部管理的bean，若是发现带有@Transactional注解的类和方 ​ 法，会为其生成代理类，代理类中会做相关的事物处理（正常提交，异常回滚）。 基于实现TransactionCallback接口的事物 ​ spring事物的传播属性 常量名称 常量解释 PROPAGATION_REQUIRED(propagation_required) 支持当前事物，如果当前没有事物，就新建一个事物。这是最常见的选择，也是spring默认的事物传播。 PROPAGATION_REQUIRES_NEW(propagation_requires_new) 新建事物，如果当前存在事物，就把当前事物挂起。新建的事物和挂起的事物没有任何的关系，是两个独立的事物。外层事物失败回滚之后，不能回滚内层事物执行的结果。内层事物失败抛出异常，外层事物捕获，也可以不处理回滚操作。 PROPAGATION_SUPPORTS(propagation_supports) 支持当前事物，如果当前没有事物，就以非事物的方式执行。 PROPAGATION_MANDATORY(propagation_mandatory) 支持当前事物，如果当前没有事物，就抛出异常。 PROPAGATION_NOT_SUPPORTED(propagation_not_supported) 以非事物方式执行操作，如果当前存在事物，就把当前事物挂起。 PROPAGATION_NEVER(propagation_never) 以非事物方式执行操作，如果当前存在事物，就抛出异常。 PROPAGATION_NESTED(propagation_nested) 如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务，则按REQUIRED属性执行。它使用了一个单独的事务，这个事务拥有多个可以回滚的保存点。内部事务的回滚不会对外部事务造成影响。它只对DataSourceTransactionManager事务管理器起效。 数据库隔离级别 隔离级别 隔离级别的值 导致的问题 Read Uncommited 0 允许脏读，不可重复读，幻读 Read Commited 1 避免脏读，允许不可重复读和幻读 RepeatableRead 2 避免脏读和不可重复读，允许幻读 Serializable 3 避免脏读 ，不可重复读，幻读，事物一个一个执行，执行效率低 spring中的隔离级别 常量名称 常量解释 ISOLATION_DEFAULT(isolation_default) PlatfromTransactionManager默认的事物隔离级别，使用数据库默认的事物隔离级别。 ISOLATION_READ_UNCOMMITTED(isolation_read_uncommitted) 读未提交 ISOLATION_READ_COMMITTED(isolation_read_committed) 读已提交 ISOLATION_REPEATABLE_READ(isolation_repeatable) 可重复读 ISOLATION_SERIALIZABLE(isolation_serializable) 串行化 @Resource注解和@Autowired注解的区别 1.当单独使用@Autowired注解时，会默认按照类型装配，不适用与系统里一个接口有多个实现类的情况。2.当系统内存在多个实现类时，无法按照类型装配，@Autowired可以配合@Qualifier注解按照名称进行装配3.@Resource默认按照名称装配，可以通过指定name属性来进行按照名称来装配。4.@Resource若是指定的name为空串或者是未指定name属性，会去按照类型来装配(此时系统内只能存在一个接口实现类，否则报错)5.@Resource装配的类必须存在，否则会报错。@Autowired可以配置required=false来设置装配的bean是否是必须的。6.@Resource注解属于JSR250标准的注释，属于J2EE的。而@Autowired属于spring提供的注解。使用@Resource注解可以与spring解耦。 Restful风格 参考博客：https://blog.igevin.info/posts/restful-architecture-in-general/#restful_features 特点：资源，统一接口 ，URI和无状态 资源：就是网络上面的一个实体，或者说是网络上面的一个具体信息。 统一接口：数据的元操作，分别对应于http的四个不同的方法。 URI：可以通过一个URI访问一个具体的资源。 无状态： 什么是一致性hash","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://gzl2017.github.io/categories/java/"},{"name":"spring","slug":"java/spring","permalink":"https://gzl2017.github.io/categories/java/spring/"}]},{"title":"redis","date":"2019-08-18T02:58:52.000Z","path":"wiki/redis/","text":"redis和zk实现分布式锁的区别 实现方式 优点 缺点 基于redis 性能高 锁的失效时间很难把控 基于zk 实现简单 有效解决单点问题 不可重入问题 锁无法释放问题 非阻塞问题 性能没redis高 对于临时节点的删除和创建需要leader节点来处理 然后同步给flow节点 cap原则 缓存数据的同步方式 先写入数据库，在写入缓存 查询数据库，然后写入缓存 定时刷新数据写入缓存 redis特点 一种缓存中间件 key-value的存储形式 默认16个db（0-15）个空间 支持数据的持久化 redis五种数据结构 数据结构 使用场景 string session共享 短信验证码 ip限制 序列自增 list 分布式队列 栈 hash 对象的存储（用户信息） set 用户标签(定点推送) 求交集 并集 sorted set 过期时间 消极方法 当应用访问key时，发现key已经过期，就会删除。 积极方法： 周期性的从设置了过期时间的key中选择一部分的key进行删除。 随机测试20个带有timeout信息的key。 如果超过25%的key被删除，则重复执行整个流程 pub/sub 发布订阅模式 redis持久化及原理 RDB 概念：当符合【条件】的时候，fork子进程，生成dump.rdb快照文件。 缺点：数据丢失 规则 配置规则，配置文件配置 save或者bgsave命令触发 flushall命令触发，且满足配置规则 执行复制操作 AOF 概念：需要配置文件开启(默认关闭)，aof文件的写入，只针对事物操作。AOF重写 缺点： 规则 redis内存回收策略 ​ redis单线程性能高的原因 内存和网络的宽带 多路复用（同一时间处理多个请求） 避免线程切换 纯内存操作 lua脚本在redis中的应用 pipeline管道模型 减少网络开销去执行多个指令 满足原子性 复用性 redis.call(“set”, “gupao”, “123”) redis.call(“get”, “gupao”); lua脚本可以存储在服务端-&gt;生成摘要 redis集群 解决单点问题 主从复制(master-slave) 数据同步: 全量复制(初始化) 增量复制 无磁盘复制 选主(哨兵) 哨兵机制 监控master和slave是否正常运行 当master出现故障的时候，从slave中选取一个新的master Redis-Cluster Redis的实践应用","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://gzl2017.github.io/categories/java/"},{"name":"redis","slug":"java/redis","permalink":"https://gzl2017.github.io/categories/java/redis/"}]},{"title":"HashMap","date":"2019-08-16T14:01:46.000Z","path":"wiki/HashMap/","text":"1.HashMap的数据结构 在jdk1.7中基于数组+链表,在jdk1.8中基于数组+链表+红黑树 2.HashMap的put方法的过程 a.首先判断当前的数组是否被初始化,若是没有被初始化,调用resize方法初始化 b.通过key的hash值和数组长度计算出该元素在数组中的位置 c1.若是数组上没有元素,构建Node节点,存储该元素 c21.若是该数组上有元素,且第一个节点的key与要存储的key相等,用变量保存该节点。 c22.若是该数组上有元素,且第一个节点的key与要存储的key不相等,需要判断该节点类型。 若是该节点属于红黑树,将元素插入到红黑树。 若是该节点属于链表,循环遍历链表,若是没有遇到key相同的,将key-value创建称为节点,插入到链表的尾部。判断是否需要转成红黑树，若是需要，将链表转成红黑树。 d.前面的操作中，若是找到与key相同的节点,根据条件判断是否需要覆盖,若是需要覆盖,直接修改原有节点的value。 f.将元素的个数size加1并判断是否需要扩容,若是需要扩容,调用resize方法扩容。 3.HashMap的resize方法 resize方法涉及到两个大的步骤,首先是确定新数组的大小已经下次的扩容时机，新数组大小为原有数组大小的两倍，扩容变量也扩大为原有的两倍。其次是将原有数组的元素迁移至新的数组中,其中数组元素只会在两个地方，一个在[原下标]的地方，另一个在[原下标+原容量]的位置。","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://gzl2017.github.io/categories/java/"},{"name":"源码","slug":"java/源码","permalink":"https://gzl2017.github.io/categories/java/源码/"}]},{"title":"jvm","date":"2019-08-16T04:51:03.000Z","path":"wiki/jvm/","text":"jvm的运行时数据区 堆:java垃圾回收的主要区域，唯一存在的价值就是存放对象实例，几乎所有的对象实例都会在这里分配内存。从垃圾回收的角度分为新生代和老年代。在细分一点可以划分为Eden空间,From Survivor空间,To Survivor空间。若是在堆中没有完成实例分配，并且堆也无法再扩展时，就会抛出OutOfMemoryError异常。 方法区:用于存储已经被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。当方法区无法满足内存分配的需求时，将会抛出OutOfMemoryError异常。 虚拟机栈:描述的是java方法执行的内存模型，每个方法执行时都会创建一个栈帧，栈帧中用于存储局部变量表，操作数栈，动态链接，方法出口等信息。当线程申请的栈深度大于虚拟机所允许的栈深度，将抛出StackOverflowError异常。若是虚拟机动态扩展时无法申请到足够的内存，将会抛出OutOfMemoryError异常。 程序计数器:记录当前线程执行的字节码指令的行号，不会发生OutOfMemoryError。 本地方法栈:用于执行非java方法的内存模型，也会发生StackOverflowError和OutOfMemoryError异常。 jvm垃圾回收考虑的三个问题 回收哪些对象 什么时候回收这些对象 怎么回收这些对象 jvm垃圾回收算法 标记清除：会有内存碎片 标记整理：没有内存碎片，适合新生代对象的回收 复制算法：需要留出一部分的内存空间，利用率不高 分代收集算法：新生代死亡对象多，采用复制算法。老年代死亡对象少，采用标记整理或标记清除。 jvm垃圾收集器 ​ 新生代垃圾收集器 ​ 老年代垃圾收集器","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://gzl2017.github.io/categories/java/"},{"name":"jvm","slug":"java/jvm","permalink":"https://gzl2017.github.io/categories/java/jvm/"}]},{"title":"mysql常见面试题","date":"2019-08-15T12:56:11.000Z","path":"wiki/mysql/","text":"1.char(32)和varchar(32)的区别 (1):char和varchar都是数据库定义字符串类型的数据格式,char是一种定长度的类型,varchar是一种可变长度的类型。 (2):char(32)表示定义了当前字段所占用的存储空间为32个字符,不管字段长度是否达到32,占用的空间是不变的。而varchar(32)表示定义了当前字段所能够占用的最大存储空间是32个字符,实际占用空间是字段的大小。 (3):就存储效率而言,定长的char类型由于一开始就定义好了字段占用空间,不需要根据字段的长度在去申请空间,故效率相对较高,但是在占用空间上就没有varchar有优势。而varchar由于根据字段长度调整空间占用,故空间消耗较小,但是存储效率不高。 2.数据库的四大特性 A(Atomicity 原子性):数据库最小的工作单元，整个工作单元要么一起提交成功,要么一起回滚失败。 C(Consistency 一致性):事物中操作的数据的状态是一致的。即写入资料的结果必须完全符合预设的规则，不会因为出现系统意外等原因导致状态的不一致。 I(Isolation 隔离性):一个事务所操作的数据在提交之前，对其他事务的可见性设定（一般设定为不可见）。 D(Durability 持久性):数据库的数据一旦提交,无法更改。 3.多个事物并发引发的数据读取问题 脏读:该问题是指一个事物读取到了另外一个事物未提交的问题。 不可重复读:该问题是指在一个事物未结束之前,前后两次读取到的数据不一致现象。原因在于该事物在前后两次读取数据之间，另外一个事物修改了该数据。(不可重复读的重点在于修改) 幻读:该问题是指当一个事物修改了数据库表中某一个范围内的数据的某一个字段，但是另外一个事物在此期间又在该范围内插入了一条新的数据，造成前一个事物出现幻觉(没有完全修改)。(幻读的重点在于新增或删除) 4.数据库事物的隔离级别 Read Uncommited读未提交:事物未提交对其它的事物也是可见的。 Read Commited读已提交:一个事物只能够读取到已提交的数据。(解决脏读,未解决不可重复读) Repeatable Read可重复读:一个事物对数据的前后读取结果是一致的。(解决了不可重复读,未解决幻读) Serializable串行化:数据库最高的隔离级别,强制所有事物串行执行,解决了所有并发问题。 5.聚集索引和非聚集索引的区别: 聚集索引:表中的数据是按照索引的顺序来存储的。索引的叶子节点上存储了真实的数据,不会有另外单独的数据页。 非聚集索引:表中的数据存储不依赖于索引的顺序。索引的叶子节点上存储了索引的关键字和指向真实数据的指针。 6.sql注入,如何避免sql注入 概念:所谓sql注入,就是攻击者将sql命令插入到web表单的输入域或者是页面请求的查询字符串，欺骗服务器执行恶意的sql命令。(某些表单中的输入命令被直接用来构造(或影响)sql命令，或者是构成存储过程的输入参数,这类表单特别容易受到sql注入式攻击)。 如何避免: (1):mybatis中多使用[#{param}],尽量避免使用[${param}],原因在于[${param}]会直接参与sql编译,容易造成sql攻击。 7.数据库的三大范式 第一范式: 每一列都是一个不可再分割的属性值,确保每一列的原子性(规范列)。 第二范式: 在满足第一范式的要求下，每一行数据只做一件事(规范行)。 第三范式: 在满足第二范式的要求下，确保数据表中的每一列数据都和主键直接相关,而不能够间接相关。","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://gzl2017.github.io/categories/java/"},{"name":"mysql","slug":"java/mysql","permalink":"https://gzl2017.github.io/categories/java/mysql/"}]}]}