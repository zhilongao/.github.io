{"pages":[{"title":"微简历","date":"2019-09-25T01:07:15.261Z","path":"about/index.html","text":"职业：java开发工程师 地点：北京 邮箱：303547207@qq.com 微信：gzl17743516545"},{"title":"Categories","date":"2019-08-15T09:07:03.170Z","path":"categories/index.html","text":""},{"title":"Tags","date":"2019-08-15T09:07:03.179Z","path":"tags/index.html","text":""}],"posts":[{"title":"spring扩展","date":"2019-11-30T07:53:47.000Z","path":"wiki/fra-spring-xml-extend/","text":"spring除了可以解析自定的标签外，也可以解析用户自定义的标签。解析自定义标签需要添加一些扩展。下面以一个实例展示这个过程。 1.在resources/META-INF目录下新建文件spring-test.xsd &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"targetNamespace=\"http://www.test.com/schema/user\"&gt; &lt;xs:element name=\"user\"&gt; &lt;xs:complexType&gt; &lt;xs:attribute name=\"id\" type=\"xs:string\"&gt;&lt;/xs:attribute&gt; &lt;xs:attribute name=\"userName\" type=\"xs:string\"&gt;&lt;/xs:attribute&gt; &lt;xs:attribute name=\"email\" type=\"xs:string\"&gt;&lt;/xs:attribute&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt;&lt;/xs:schema&gt; 2.在resource/META-INF目录下创建spring.schema文件，并添加以下内容。 http\\://www.test.com/schema/user.xsd=META-INF/spring-test.xsd 3.创建自定义bean解析器类UserBeanDefinitionParser,该类需要继承AbstractSingleBeanDefinitionParser public class UserBeanDefinitionParser extends AbstractSingleBeanDefinitionParser &#123; @Override protected Class&lt;?&gt; getBeanClass(Element element) &#123; return User.class; &#125; // 从element中解析并提取相应的元素 @Override protected void doParse(Element element, BeanDefinitionBuilder builder) &#123; String userName = element.getAttribute(\"userName\"); String email = element.getAttribute(\"email\"); if (StringUtils.hasText(userName)) &#123; builder.addPropertyValue(\"userName\", userName); &#125; if (StringUtils.hasText(email)) &#123; builder.addPropertyValue(\"email\", email); &#125; &#125;&#125; 4.创建自定义namespace处理器类MyNamespaceHandler,该类需要继承NamespaceHandlerSupport public class MyNamespaceHandler extends NamespaceHandlerSupport &#123; @Override public void init() &#123; registerBeanDefinitionParser(\"user\", new UserBeanDefinitionParser()); &#125;&#125; 5.定义一个实体类 @Datapublic class User &#123; private String id; private String userName; private String email; @Override public String toString() &#123; return this.getUserName() + \"--\" + this.getEmail(); &#125;&#125; 6.创建一个xml文件,beans3.xml,使用自定义标签定义bean &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:myname=\"http://www.test.com/schema/user\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.test.com/schema/user http://www.test.com/schema/user.xsd\"&gt; &lt;myname:user id=\"testbean\" userName=\"aaa\" email=\"bbb\"/&gt;&lt;/beans&gt; 7.定义一个测试类，测试能否成功加载该bean public class TestApp &#123; public static void main(String[] args) &#123; XmlBeanFactory factory = new XmlBeanFactory(new ClassPathResource(\"beans3.xml\")); User u1 = (User)factory.getBean(\"testbean\"); System.out.println(u1); &#125;&#125; 输出结果 aaa--bbbf","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"框架","slug":"java/框架","permalink":"https://zhilongao.github.io/categories/java/框架/"},{"name":"spring","slug":"java/框架/spring","permalink":"https://zhilongao.github.io/categories/java/框架/spring/"}]},{"title":"事件监听","date":"2019-11-19T13:54:24.000Z","path":"wiki/fra-springboot-1/","text":"spring事件和事件监听器 在spring框架中有许多事件监听的应用。定义事件监听一般有三种角色：事件(event)，事件监听器(listener)，事件的发布者(multicaster)。 事件：在java.util包下面有一个类 EventObject，该类只定义了一个Object:source 属性(事件源)。spring事件定义是在该类上面扩展的，ApplicationEvent -&gt; EventObject 监听器：在java.util包下面定义了监听器的顶层接口 EventListener，该接口没有定义任何方法。spring事件监听器接口继承了该接口，ApplicationListener -&gt; EventListener 事件发布器：在spring中有一个类 SimpleApplicationEventMulticaster，该类可以实现spring事件的发布。 spring事件发布的简单示例： public class Test &#123; public static void main(String[] args) &#123; // 1. 定义一个事件发布器 SimpleApplicationEventMulticaster multicaster = new SimpleApplicationEventMulticaster(); // 2.添加WorkEventListener和FreeEventListener事件监听器 multicaster.addApplicationListener(new WorkEventListener()); multicaster.addApplicationListener(new FreeEventListener()); // 3.发布WorkEvent和FreeEvent事件 multicaster.multicastEvent(new WorkEvent(new Object())); multicaster.multicastEvent(new FreeEvent(new Object())); &#125; // WorkEvent 事件-&gt;继承自spring的ApplicationEvent。 public static class WorkEvent extends ApplicationEvent&#123; public WorkEvent(Object source)&#123; super(source); &#125; &#125; // FreeEvent 事件-&gt;继承自spring的ApplicationEvent。 public static class FreeEvent extends ApplicationEvent&#123; public FreeEvent(Object source)&#123; super(source); &#125; &#125; // WorkEvent事件监听器-&gt;继承自spring的ApplicationListener,通过泛型可以限制该listener只可接受WorkEvent类型的事件。 public static class WorkEventListener implements ApplicationListener&lt;WorkEvent&gt;&#123; @Override public void onApplicationEvent(WorkEvent workEvent) &#123; System.out.println(\"WorkEventListener received event-&gt;\" + workEvent.getClass().getSimpleName()); &#125; &#125; // FreeEvent事件监听器-&gt;继承自spring的ApplicationListener,通过泛型可以限制该listener只可接受FreeEvent类型的事件。 public static class FreeEventListener implements ApplicationListener&lt;FreeEvent&gt;&#123; @Override public void onApplicationEvent(FreeEvent freeEvent) &#123; System.out.println(\"FreeEventListener received event-&gt;\" + freeEvent.getClass().getSimpleName()); &#125; &#125; &#125;// 输出结果：// WorkEventListener received event-&gt;WorkEvent// FreeEventListener received event-&gt;FreeEvent 由于ApplicationListener接口定义每个实现类只能接收一种事件，但对于一个监听器处理多个事件无能为力。故 spring 又在 ApplicationListener接口上扩展了一个接口SmartApplicationListener，该接口可以通过判断事件和事件源来决定是否处理该事件，更加的灵活。 public class Test &#123; public static void main(String[] args) &#123; SimpleApplicationEventMulticaster multicaster = new SimpleApplicationEventMulticaster(); multicaster.addApplicationListener(new MySmartListener()); multicaster.multicastEvent(new WorkEvent(new Object())); multicaster.multicastEvent(new FreeEvent(new Object())); &#125; // 定义WorkEvent public static class WorkEvent extends ApplicationEvent&#123; public WorkEvent(Object source)&#123; super(source); &#125; &#125; // 定义FreeEvent public static class FreeEvent extends ApplicationEvent&#123; public FreeEvent(Object source)&#123; super(source); &#125; &#125; public static class MySmartListener implements SmartApplicationListener &#123; // WorkEvent和FreeEvent均可以处理 @Override public boolean supportsEventType(Class&lt;? extends ApplicationEvent&gt; aClass) &#123; String workEventName = WorkEvent.class.getSimpleName(); String freeEventName = FreeEvent.class.getSimpleName(); return aClass.getSimpleName().equals(workEventName) || aClass.getSimpleName().equals(freeEventName); &#125; // 对于属性源不加限制 @Override public boolean supportsSourceType(Class&lt;?&gt; sourceType) &#123; return true; &#125; @Override public void onApplicationEvent(ApplicationEvent applicationEvent) &#123; System.out.println(\"MySmartListener received event \" + applicationEvent.getClass().getSimpleName()); &#125; &#125;&#125;","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"框架","slug":"java/框架","permalink":"https://zhilongao.github.io/categories/java/框架/"},{"name":"spring","slug":"java/框架/spring","permalink":"https://zhilongao.github.io/categories/java/框架/spring/"}]},{"title":"java开发常见问题","date":"2019-11-17T06:28:50.000Z","path":"wiki/java-dev-problem/","text":"maven仓库地址证书过期问题：在idea中创建了一个maven项目,在pom文件中引入几个依赖。但是这几个依赖包一直下载不下来，提示下载失败。排查问题： 1. 推断可能是maven哪里配置出现了问题，下载失败肯定会有日志记录。 2. idea菜单的 help -&gt; show log in explore 会直接跳转到idea日志目录。 3. 查看idea.log文件。 4. 该日志文件中出现如下的日志信息。 Caused by: java.lang.RuntimeException: org.eclipse.aether.transfer.ArtifactTransferException: Failure to transfer org.springframework:spring-context:pom:5.1.8.RELEASE from http://maven.aliyun.com/nexus/content/groups/public/ was cached in the local repository, resolution will not be reattempted until the update interval of datanucleus has elapsed or updates are forced. Original error: Could not transfer artifact org.springframework:spring-context:pom:5.1.8.RELEASE from/to datanucleus (http://maven.aliyun.com/nexus/content/groups/public/): sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target 5. 该信息显示无法找到合法的证书。解决：为该站点生成证书信息-&gt; 运行下面的java类，然后在控制台输入1，会在该类所在项目路径下生成一个证书，文件名为 ssecacerts。 将该文件拷贝到 $JAVA_HOME/jre/lib/security 目录下。 import java.io.BufferedReader;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.InputStream;import java.io.InputStreamReader;import java.io.OutputStream;import java.security.KeyStore;import java.security.MessageDigest;import java.security.cert.CertificateException;import java.security.cert.X509Certificate;import javax.net.ssl.SSLContext;import javax.net.ssl.SSLException;import javax.net.ssl.SSLSocket;import javax.net.ssl.SSLSocketFactory;import javax.net.ssl.TrustManager;import javax.net.ssl.TrustManagerFactory;import javax.net.ssl.X509TrustManager;public class InstallCert &#123; public static final String HOSTNAME = \"repo.maven.apache.org\"; public static void main(String[] args) throws Exception &#123; args = new String[]&#123;HOSTNAME&#125;; String host; int port; char[] passphrase; if ((args.length == 1) || (args.length == 2)) &#123; String[] c = args[0].split(\":\"); host = c[0]; port = (c.length == 1) ? 443 : Integer.parseInt(c[1]); //java keytool默认的密码是changeit String p = (args.length == 1) ? \"changeit\" : args[1]; passphrase = p.toCharArray(); &#125; else &#123; System.out.println(\"Usage: java InstallCacerts &lt;host&gt;[:port] [passphrase]\"); return; &#125; File file = new File(\"jssecacerts\"); if (file.isFile() == false) &#123; File dir = new File(System.getProperty(\"java.home\") + File.separatorChar + \"lib\" + File.separatorChar + \"security\"); //先看默认的证书库jssecacerts是否存在 file = new File(dir, \"jssecacerts\"); //如果不存在则使用cacerts(它随J2SDK一起发行,含有数量有限的可信任的基本证书) if (file.isFile() == false) &#123; file = new File(dir, \"cacerts\"); &#125; &#125; System.out.println(\"Loading KeyStore \" + file + \"...\"); InputStream in = new FileInputStream(file); KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType()); ks.load(in, passphrase); in.close(); SSLContext context = SSLContext.getInstance(\"TLS\"); TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); tmf.init(ks); X509TrustManager defaultTrustManager = (X509TrustManager) tmf.getTrustManagers()[0]; SavingTrustManager tm = new SavingTrustManager(defaultTrustManager); context.init(null, new TrustManager[]&#123;tm&#125;, null); SSLSocketFactory factory = context.getSocketFactory(); System.out.println(\"Opening connection to \" + host + \":\" + port + \"...\"); SSLSocket socket = (SSLSocket) factory.createSocket(host, port); socket.setSoTimeout(10000); try &#123; System.out.println(\"Starting SSL handshake...\"); socket.startHandshake(); socket.close(); System.out.println(); System.out.println(\"No errors, certificate is already trusted\"); &#125; catch (SSLException e) &#123; System.out.println(); e.printStackTrace(System.out); &#125; X509Certificate[] chain = tm.chain; if (chain == null) &#123; System.out.println(\"Could not obtain server certificate chain\"); return; &#125; BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); System.out.println(); System.out.println(\"Server sent \" + chain.length + \" certificate(s):\"); System.out.println(); MessageDigest sha1 = MessageDigest.getInstance(\"SHA1\"); MessageDigest md5 = MessageDigest.getInstance(\"MD5\"); for (int i = 0; i &lt; chain.length; i++) &#123; X509Certificate cert = chain[i]; System.out.println(\" \" + (i + 1) + \" Subject \" + cert.getSubjectDN()); System.out.println(\" Issuer \" + cert.getIssuerDN()); sha1.update(cert.getEncoded()); System.out.println(\" sha1 \" + toHexString(sha1.digest())); md5.update(cert.getEncoded()); System.out.println(\" md5 \" + toHexString(md5.digest())); System.out.println(); &#125; System.out.println(\"Enter certificate to add to trusted keystore or 'q' to quit: [1]\"); String line = reader.readLine().trim(); int k; try &#123; k = (line.length() == 0) ? 0 : Integer.parseInt(line) - 1; &#125; catch (NumberFormatException e) &#123; System.out.println(\"KeyStore not changed\"); return; &#125; X509Certificate cert = chain[k]; String alias = host + \"-\" + (k + 1); ks.setCertificateEntry(alias, cert); OutputStream out = new FileOutputStream(\"ssecacerts\"); ks.store(out, passphrase); out.close(); System.out.println(); System.out.println(cert); System.out.println(); System.out.println(\"Added certificate to keystore 'jssecacerts' using alias '\" + alias + \"'\"); &#125; private static final char[] HEXDIGITS = \"0123456789abcdef\".toCharArray(); private static String toHexString(byte[] bytes) &#123; StringBuilder sb = new StringBuilder(bytes.length * 3); for (int b : bytes) &#123; b &amp;= 0xff; sb.append(HEXDIGITS[b &gt;&gt; 4]); sb.append(HEXDIGITS[b &amp; 15]); sb.append(' '); &#125; return sb.toString(); &#125; private static class SavingTrustManager implements X509TrustManager &#123; private final X509TrustManager tm; private X509Certificate[] chain; SavingTrustManager(X509TrustManager tm) &#123; this.tm = tm; &#125; @Override public X509Certificate[] getAcceptedIssuers() &#123; throw new UnsupportedOperationException(); &#125; @Override public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; throw new UnsupportedOperationException(); &#125; @Override public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; this.chain = chain; tm.checkServerTrusted(chain, authType); &#125; &#125;&#125;","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"}]},{"title":"加密算法","date":"2019-11-09T10:10:08.000Z","path":"wiki/java-base-security/","text":"对称加密与非对称加密对称加密：在对称加密中存在密钥的概念，加密时使用密钥加密，解密时使用密钥解密。非对称加密：非对称加密中存在私钥和公钥的概念，一般加密时使用公钥加密，解密时使用私钥解密。 MD5MD5算法可以为一段给定的字符串或者某个文本生成唯一的一个字符串（数字签名）。 // 通过apache的commons-lang实现md5&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.3.2&lt;/version&gt;&lt;/dependency&gt;/*** md5加密* @param text* @param key* @return*/public static String md5(String text, String key) &#123; return DigestUtils.md5Hex(text + key);&#125; BASE64BASE64属于对称加密的一种，可以使用该方式实现文本的编码和节码。java中关于base64编码和解码有三种方式实现，第一种是使用 sun.misc 包下面的 BASE64Encoder 和 BASE64Decoder。第二种方式是使用 java.util包下的工具类 Base64。第三种方式是使用 org.apache.commons.codec包下的类。 /*** 编码* @param text* @return*/public static String encodeA(String text) &#123; BASE64Encoder base64Encoder = new BASE64Encoder(); byte[] bytes = null; String res = null; try &#123; bytes = text.getBytes(\"UTF-8\"); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; if (bytes != null) &#123; res = base64Encoder.encode(bytes); &#125; return res;&#125;/*** 节码* @param text* @return*/public static String decodeA(String text) &#123; BASE64Decoder base64Decoder = new BASE64Decoder(); byte[] bytes = null; String res = null; try &#123; bytes = base64Decoder.decodeBuffer(text); res = new String(bytes, \"UTF-8\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return res;&#125; /*** 编码* @param text* @return*/public static String encodeB(String text) &#123; Base64.Encoder encoder = Base64.getEncoder(); byte[] bytes = null; String res = null; try &#123; bytes = text.getBytes(\"UTF-8\"); byte[] encode = encoder.encode(bytes); res = new String(encode, \"UTF-8\"); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; return res;&#125;/*** 节码* @param text* @return*/public static String decodeB(String text) &#123; Base64.Decoder decoder = Base64.getDecoder(); String res = null; byte[] decode = decoder.decode(text); try &#123; res = new String(decode, \"UTF-8\"); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; return res;&#125; /*** 编码* @param text* @return*/public static String encodeC(String text)&#123; org.apache.commons.codec.binary.Base64 base64 = new org.apache.commons.codec.binary.Base64(); byte[] bytes = null; String res = null; try &#123; bytes = text.getBytes(\"UTF-8\"); res = base64.encodeToString(bytes); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; return res;&#125;/*** 解码* @param text* @return*/public static String decodeC(String text) &#123; org.apache.commons.codec.binary.Base64 base64 = new org.apache.commons.codec.binary.Base64(); String res = null; byte[] bytes = null; bytes = base64.decode(text); try &#123; res = new String(bytes, \"UTF-8\"); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; return res;&#125; AESAES属于一种对称加密算法，加密和解密使用同一密钥。 /*** AES加密* @param src* @param key* @return* @throws Exception*/public static String encodeAes(String src, String key) throws Exception&#123; if (key == null || key.length() != 16) &#123; System.out.print(\"Key为空null\"); return null; &#125; byte[] raw = key.getBytes(\"UTF-8\"); SecretKeySpec keySpec = new SecretKeySpec(raw, \"AES\"); Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");//\"算法/模式/补码方式\" cipher.init(Cipher.ENCRYPT_MODE, keySpec); byte[] encrypted = cipher.doFinal(src.getBytes(\"utf-8\")); //此处使用BASE64做转码功能，同时能起到2次加密的作用。 return new org.apache.commons.codec.binary.Base64().encodeToString(encrypted);&#125;/*** AES解密* @param src* @param key* @return* @throws Exception*/public static String decodeAes(String src, String key) throws Exception&#123; if (key == null || key.length() != 16) &#123; System.out.print(\"Key为空null\"); return null; &#125; byte[] raw = key.getBytes(\"utf-8\"); SecretKeySpec keySpec = new SecretKeySpec(raw, \"AES\"); Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\"); cipher.init(Cipher.DECRYPT_MODE, keySpec); //先用base64解密 byte[] encrypted1 = new org.apache.commons.codec.binary.Base64().decode(src); try &#123; byte[] original = cipher.doFinal(encrypted1); String originalString = new String(original,\"utf-8\"); return originalString; &#125; catch (Exception e) &#123; System.out.println(e.toString()); return null; &#125;&#125;","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"基础","slug":"java/基础","permalink":"https://zhilongao.github.io/categories/java/基础/"},{"name":"安全","slug":"java/基础/安全","permalink":"https://zhilongao.github.io/categories/java/基础/安全/"}]},{"title":"环境","date":"2019-10-29T13:46:46.000Z","path":"wiki/spring-base-environment/","text":"在spring框架中对于配置文件的配置属性，java的系统属性，以及系统的环境变量，都抽象在了Environment接口中，通过该接口可以获取我们之前配置好的一些属性。下面是关于Environment接口的简单使用。 public static void main(String[] args) &#123; // 1. 创建 Environment 对象 StandardEnvironment environment = new StandardEnvironment(); // 2. 在environment中存储了类型为 PropertySources类型的属性，该属性中存储 PropertySource列表 MutablePropertySources propertySources = environment.getPropertySources(); // 3. 创建第一个 PropertySource Map&lt;String, Object&gt; mapA = new HashMap&lt;String, Object&gt;(); mapA.put(\"java\", \"version7\"); PropertySource propertySourceA = new MapPropertySource(\"mapA\", mapA); // 4. 创建第二个 PropertySource Map&lt;String, Object&gt; mapB = new HashMap&lt;String, Object&gt;(); mapB.put(\"java\", \"version8\"); PropertySource propertySourceB = new MapPropertySource(\"mapB\", mapB); // 5.将 PropertySource添加到 propertySources中 propertySources.addLast(propertySourceA); propertySources.addLast(propertySourceB); System.out.println(environment.getProperty(\"java\")); // 输出 version7 propertySources.addLast(propertySourceA); propertySources.addFirst(propertySourceB); System.out.println(environment.getProperty(\"java\")); // 输出 version8&#125;","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"框架","slug":"java/框架","permalink":"https://zhilongao.github.io/categories/java/框架/"},{"name":"spring","slug":"java/框架/spring","permalink":"https://zhilongao.github.io/categories/java/框架/spring/"}]},{"title":"ClassLoader","date":"2019-10-13T03:19:08.000Z","path":"wiki/java-base-classloader/","text":"类加载器的区别java中提供了三种类加载器，分别是启动类加载器，扩展类加载器，系统类加载器。三种类加载器通过双亲委派机制来实现类的加载。 类加载器 名称 加载路径 实现 启动类加载器 BootStrap ClassLoader 核心库：java.lang.*，系统属性：sun.boot.class.path所指路径 c++ 扩展类加载器 Extension ClassLoader 扩展库：jre\\lib\\ext 目录下的包，系统属性：java.ext.dirs所指路径 纯java 系统类加载器 System ClassLoader 环境变量 classpath 或系统属性 java.class.path 指定目录中加载类 纯java 双亲委派机制类的双亲委派机制是指子类加载器加载类时，首先会检查该类是否已经被加载。若是该类未被加载，会将加载任务委托给父类加载器，父类加载器又会委托给更上一层类加载器，直到启动类加载器。启动类加载器会检查其加载路径，有则加载，无则加载任务给扩展类加载器，扩展类有会检查路径并执行加载。 自定义类加载器在测试之前，需要将Test.java编译成Test.class文件，将该文件放如到路径D:\\jar\\com\\study\\zl\\classloader下，并将项目中的Test.java和Test.class文件删除，以免该类被系统类加载器加载到。 package com.study.zl.classloader;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;/** * @Author long * @Date 2019/10/13 10:24 */public class App &#123; public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123; SelfClassLoader selfClassLoader = new SelfClassLoader(\"D:\\\\jar\"); Class&lt;?&gt; cls = selfClassLoader.loadClass(\"com.study.zl.classloader.Test\"); if (cls != null) &#123; // 创建一个cls类型的对象 Object o = cls.newInstance(); // 获取该对象的say方法 Method say = cls.getMethod(\"say\", null); // 调用该类型的say方法 say.invoke(o, null); // 查看 cls 的类加载器 System.out.println(cls.getClassLoader().toString()); &#125; &#125; // 输出结果 // hello,world // com.study.zl.classloader.SelfClassLoader@7f31245a&#125;package com.study.zl.classloader;public class Test &#123; public void say()&#123; System.out.println(\"hello,world\"); &#125;&#125; 自定义一个类加载器，该类加载器继承自ClassLoader，重写 findClass 方法来获取 Class。该方法首先会调用getData方法来获取类的字节码，然后调用父类的defineClass方法将字节码转化未 Class并返回。 package com.study.zl.classloader;import java.io.*;/** * @Author long * @Date 2019/10/13 10:40 */public class SelfClassLoader extends ClassLoader &#123; private String classpath; public SelfClassLoader(String classpath) &#123; this.classpath = classpath; &#125; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; try &#123; byte[] data = getData(name); if (data != null) &#123; // 调用 defineClass 方法将字节码转化为Class return defineClass(name, data, 0 , data.length); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return super.findClass(name); &#125; /** * 返回类的字节码 * * @param className * @return * @throws IOException */ private byte[] getData(String className) throws IOException &#123; InputStream in = null; ByteArrayOutputStream out = null; String path = classpath + File.separatorChar + className.replace('.', File.separatorChar) + \".class\"; try &#123; in = new FileInputStream(path); out = new ByteArrayOutputStream(); byte[] buffer = new byte[2048]; int len = 0; while ((len = in.read(buffer)) != -1) &#123; out.write(buffer, 0, len); &#125; return out.toByteArray(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; in.close(); out.close(); &#125; return null; &#125;&#125; 资源文件的读取在 java 中可以使用 Class 或者是 ClassLoader 读取资源文件。比如现在项目的resources目录下面有一个 application.properties文件，可以使用项目中某个类的class.getResource方法或者某个类的类加载器class.getClassLoader().getResource方法。方法所传资源文件路径是向对于resources的目录。 package com.study.zl.classloader.p2;import java.net.URL;/** * @Author long * @Date 2019/10/13 14:26 */public class App &#123; public static void main(String[] args) &#123; Class&lt;App&gt; appClass = App.class; // 通过 class 获取资源时，必须有 / ,否则会从该类所在包下面读取 URL resource1 = appClass.getResource(\"/application.properties\"); // 通过 ClassLoader 读取资源，所不同的是 ClassLoader 还有一个 getResources 方法 URL resource2 = appClass.getClassLoader().getResource(\"application.properties\"); System.out.println(resource1.toString()); System.out.println(resource2.toString()); &#125; // 输出结果 // file:/D:/code/struct-parent/interview-ready/target/classes/application.properties // file:/D:/code/struct-parent/interview-ready/target/classes/application.properties&#125; 读取Properties文件在spring核心包中提供了一个工具类PropertiesLoaderUtils，该工具类可以将ClassLoader读取到的资源转换未Properties文件。 // pom.xml文件引入 spring framework 核心包依赖&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;2.5.6&lt;/version&gt;&lt;/dependency&gt;// application.properties文件加入内容#Tue Jun 18 23:47:55 GMT 2019server.port=8080server.name=spring-boot-applicationpackage com.study.zl.classloader.p2;import org.springframework.core.io.UrlResource;import org.springframework.core.io.support.PropertiesLoaderUtils;import java.io.IOException;import java.net.URL;import java.util.Enumeration;import java.util.Properties;/** * @Author long * @Date 2019/10/13 14:26 */public class App &#123; public static void main(String[] args) &#123; Class&lt;App&gt; appClass = App.class; // 定义Properties对象 Properties properties = new Properties(); try &#123; // 读取资源集合 Enumeration&lt;URL&gt; urls = appClass.getClassLoader().getResources(\"application.properties\"); while (urls.hasMoreElements()) &#123; // 使用工具类加载 properties.putAll(PropertiesLoaderUtils.loadProperties(new UrlResource(urls.nextElement()))); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 输出 System.out.println(properties); &#125; // 输出结果 // &#123;server.port=8080, server.name=spring-boot-application&#125;&#125;","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"基础","slug":"java/基础","permalink":"https://zhilongao.github.io/categories/java/基础/"},{"name":"ClassLoader","slug":"java/基础/ClassLoader","permalink":"https://zhilongao.github.io/categories/java/基础/ClassLoader/"}]},{"title":"CountDownLatch","date":"2019-09-30T13:29:36.000Z","path":"wiki/ans-countdownlatch-source/","text":"应用场景① 下一步的任务需要等待上一步任务执行完成才能执行的场景。比如：有一批任务交给线程池来处理，我们需要知道任务从开始到结束一共执行了多长的时间。下面的代码展示了这种场景的使用。 public void unite(JobExecutionContext jobContext) throws Exception &#123; Set&lt;String&gt; batchNoSet = getBatchSet(jobContext); Set&lt;String&gt; idCardSet = updateLoanInfoFromSrc(batchNoSet); // 任务开始之前获取到系统现在的时间 Long start = System.currentTimeMillis(); // 创建 CountDownLatch 对象，以任务个数做为该对象的初始化参数 CountDownLatch latch = new CountDownLatch(idCardSet.size()); for (String idCard : idCardSet) &#123; // 创建任务线程 CaseUnitedThread thread = new CaseUnitedThread(idCard.trim(), latch); // 任务交给线程池处理-&gt;每执行一次任务，CountDownLatch对象的 state值减去1 threadPool.execute(thread); &#125; // 等待归户完毕 latch.await(); logger.info(\"case united finish: total time = &#123;&#125;\", System.currentTimeMillis() - start);&#125; 源码分析 类结构 CountDownLatch类内部定义比较简单，有一个类型为Sync:sync属性，而CountDownLatch最重要的两个方法countDown和await的内部实现是由Sync:sync来完成的。而Sync类又继承自AQS。 // jdk1.8public class CountDownLatch &#123; // 内部属性，相关操作会交由该对象来完成 private final Sync sync; // 构造函数，初始化 sync 属性 public CountDownLatch(int count) &#123; // 参数值必须大于等于0 if (count &lt; 0) throw new IllegalArgumentException(\"count &lt; 0\"); this.sync = new Sync(count); &#125; public void await() throws InterruptedException &#123; sync.acquireSharedInterruptibly(1); &#125; public boolean await(long timeout, TimeUnit unit) throws InterruptedException &#123; return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout)); &#125; public void countDown() &#123; sync.releaseShared(1); &#125; ... ... // 静态内部类，继承了AQS private static final class Sync extends AbstractQueuedSynchronizer &#123; // 对外提供的构造函数，初始化对象时，会将 AQS 中的 state 值设置为 count Sync(int count) &#123; setState(count); &#125; ... // 尝试获取共享锁，若是 state 值为0，返回 1，否则返回 -1 protected int tryAcquireShared(int acquires) &#123; return (getState() == 0) ? 1 : -1; &#125; // 尝试释放共享锁 protected boolean tryReleaseShared(int releases) &#123; // 自旋，可能多个线程同时尝试释放共享锁，同时修改 state 值，造成线程安全问题 for (;;) &#123; int c = getState(); // 若是 state 的值已经为 0，则尝试释放共享锁失败。 if (c == 0) &#123; return false; &#125; // 通过 CAS 操作将原有 state 的值减去1，失败重试 int nextc = c-1; if (compareAndSetState(c, nextc)) &#123; // state值为0时，返回 true return nextc == 0; &#125; &#125; &#125; &#125;&#125; countDown方法 当某个线程调用CountDownLatch 的 countDown方法时，内部操作的原理其实是将AQS中的state属性值减1。 ① 当一个线程调用countDown方法时，该方法内部会调用Sync:sync的releaseShared(int arg)方法。而releaseShared(int arg)方法则是由Sync的父类AQS定义的方法。 ② AQS的releaseShared(int arg)方法首先调用tryReleaseShared(int arg)方法，该方法在AQS中是一个空方法，具体逻辑在其子类Sync中实现。 ③ Sync的tryReleaseShared(int arg)方法尝试释放共享锁。由于可能会有多个线程同时调用countDown方法修改state的值，故对state值的修改需要使用自旋加CAS操作。若修改前读到state的值为0，直接返回false。若修改前state的值不为0，通过CAS操作将其值修改为state-1，若修改后的值为0，返回true。 ④ 第 ③ 方法其实是执行了两个操作，第一是将state的值减去1，第二是判断修改后的state值是否为0。若是第 ③ 步返回值为true，证明state的值已经为0，可以做一些操作来唤醒调用await方法的线程。故第 ② 步判断返回值为true的话，执行doReleaseShared()方法。 ⑤ doReleaseShared释放共享锁，一段自旋操作。① 该方法首先获取到头节点，使用变量h保存。若是当前h节点不为空并且h节点不等于尾节点时，执行操作（这么判断的原因在于，若是头节点等于尾节点，就没必要唤醒线程。因为若是只有一个头节点时，没有需要唤醒的线程）。② 若节点h的waitStatus属性值为Node.SIGNAL，则CAS操作将其设置为0。若设置成功，调用unparkSuccessor方法唤醒线程。若设置失败，继续执行for循环。③ 若节点h的waitStatus属性值为0，则通过CAS操作将其设置为Node.PROPAGATE。若设置失败，继续执行for循环。若设置成功，继续执行后面的语句，即当h==head时，跳出for循环。 ⑥ 在上述步骤 ⑤ 中，将waitStatus状态值由Node.SIGNAL设置为0成功后，调用了unparkSuccessor方法，该方法会唤醒传入节点的下一个节点的线程。① 该方法首先会获取到传入节点node的waitStatus属性值，若是该值小于0，通过CAS操作将该值修改为0。② 获取到node节点的下一个节点s，该节点需要是waitStatus属性值小于等于0的。③ 调用LockSupport的unpark方法唤醒s节点所对应的线程。 // CountDownLatchpublic void countDown() &#123; // 调用sync的releaseShared方法 sync.releaseShared(1);&#125;// AQSpublic final boolean releaseShared(int arg) &#123; // tryReleaseShared if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false;&#125;// AQSprotected boolean tryReleaseShared(int arg) &#123; throw new UnsupportedOperationException();&#125;// Syncprotected boolean tryReleaseShared(int releases) &#123; // 自旋，可能多个线程同时尝试释放共享锁，同时修改 state 值，造成线程安全问题 for (;;) &#123; int c = getState(); // 若是 state 的值已经为 0，则尝试释放共享锁失败。 if (c == 0) &#123; return false; &#125; // 通过 CAS 操作将原有 state 的值减去1，失败重试 int nextc = c-1; if (compareAndSetState(c, nextc)) &#123; // state值为0时，返回 true return nextc == 0; &#125; &#125;&#125;// AQS-&gt; 释放共享模式的动作private void doReleaseShared() &#123; for (;;) &#123; // 保存头节点 Node h = head; // 头节点不为空并且头节点不为尾节点 if (h != null &amp;&amp; h != tail) &#123; // 获取到头节点的等待状态 int ws = h.waitStatus; // 若是头节点的等待状态为SIGNAL if (ws == Node.SIGNAL) &#123; // 节点的状态由 Node.SIGNAL更新为0失败，继续执行自旋 if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) &#123; continue; &#125; // 节点状态由 Node.SIGNAL更新为0成功，调用unparkSuccessor(Node node)唤醒后继节点 unparkSuccessor(h); // 若是该节点的状态为0，并且由0设置为PROPAGATE失败，继续执行自旋 &#125; else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) &#123; continue; &#125; &#125; if (h == head) &#123; break; &#125; &#125;&#125;private void unparkSuccessor(Node node) &#123; int ws = node.waitStatus; // ws小于0的状态有三个 SIGNAL(-1) CONDITION(-2) PROPAGATE(-3) // 若是 ws 小于0,CAS操作将其修改为0 if (ws &lt; 0) &#123; compareAndSetWaitStatus(node, ws, 0); &#125; // ws大于0仅有一种情况，即 CANCELLED(1) Node s = node.next; if (s == null || s.waitStatus &gt; 0) &#123; s = null; // 从尾节点找到一个距离node节点最近的状态值&lt;=0的节点 for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) &#123; if (t.waitStatus &lt;= 0) &#123; s = t; &#125; &#125; &#125; // 若是该节点不为null，直接唤醒该节点线程 if (s != null) &#123; LockSupport.unpark(s.thread); &#125; &#125; await 当一个线程调用一个CountDownLatch对象的await方法时，该线程会等到其state值为0时执行，否则不会执行。 ① 当调用 CountDownLatch 的 await 方法时，会调用Sync:sync的acquireSharedInterruptibly(int arg)方法，而acquireSharedInterruptibly(int arg)方法是由Sync:sync的父类AQS定义的方法。 ② AQS的acquireSharedInterruptibly(int arg)方法首先会去判断当前线程是否被中断，若是当前线程已经被中断，则直接抛出中断异常。若是当前线程没被中断，会去调用tryAcquireShared(int arg)方法。而该tryAcquireShared(int arg)方法在AQS中是一个空方法，具体的逻辑是由子类Sync来实现的。 ③ Sync重写父类的tryAcquireShared(int arg)方法，其方法的目的就是判断当前state的值是否为0，若是该值为0，返回1，否则返回-1。 ④ 步骤 ② 会根据步骤 ③ 方法返回的值进行判断。若是返回值不小于0，该方法什么也不做（不会挂起当前的线程）；若是返回值小于0，证明state的值不为0，当前线程不能执行，需要执行进一步的操作，即调用doAcquireSharedInterruptibly(int arg)方法。 ⑤ doAcquireSharedInterruptibly方法，添加到等待队列，AQS里面的方法。① 该方法首先会在队列中添加一个共享模式的节点。② 一段自旋操作，获取到该节点node的前一个节点p，若是p节点正好为head节点，调用tryAcquireShared方法尝试获取共享锁（state为0返回1，否则返回-1）,若是获取共享锁成功，调用setHeadAndPropagate方法，该方法可能会唤醒当前线程。 ③ 若是上一步操做获取共享锁失败，首先调用shouldParkAfterFailedAcquire方法判断当前线程是否可以被挂起。若是该方法返回值为true，调用parkAndCheckInterrupt方法挂起当前线程，并返回当前线程的中断标识。若是中断标识为true，立即抛出中断异常。 // CountDownLatch// 1.委托给sync的acquireSharedInterruptibly方法public void await() throws InterruptedException &#123; sync.acquireSharedInterruptibly(1);&#125;// AQS// 2.尝试获取，若获取不到在调用doAcquireSharedInterruptibly方法public final void acquireSharedInterruptibly(int arg) throws InterruptedException &#123; // 若是当前线程已经被中断，直接抛出中断异常 if (Thread.interrupted()) &#123; throw new InterruptedException(); &#125; // 若是当前 state的值不为0 if (tryAcquireShared(arg) &lt; 0) &#123; doAcquireSharedInterruptibly(arg); &#125; &#125;// AQSprotected int tryAcquireShared(int arg) &#123; throw new UnsupportedOperationException();&#125;// CountDownLatch-Syncprotected int tryAcquireShared(int acquires) &#123; // 若是当前 state 的值为0，返回1，否则返回-1 return (getState() == 0) ? 1 : -1;&#125;// AQS-&gt;获取共享锁的方法private void doAcquireSharedInterruptibly(int arg) throws InterruptedException &#123; // 将当前线程封装成为 Node 节点，添加到等待队列(此时waitStatus值为0) final Node node = addWaiter(Node.SHARED); // 判断是否执行失败的标识，失败时会将该节点清除 boolean failed = true; try &#123; for (;;) &#123; // 获取 node 节点的前一个节点p final Node p = node.predecessor(); // 若是节点p为等待队列的头节点 if (p == head) &#123; // 若是p为头节点，尝试一下获取共享锁(具体逻辑由Sync实现) int r = tryAcquireShared(arg); // r &gt;= 0 证明 state 的值已经为 0，即获取到了共享锁。CountDownLatch:Sync返回1 if (r &gt;= 0) &#123; setHeadAndPropagate(node, r); p.next = null; failed = false; return; &#125; &#125; // 1. 当获取锁失败后判断是否需要挂起线程 // 2. 若是需要挂起线程，则挂起线程并检查中断 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) &#123; throw new InterruptedException(); &#125; &#125; &#125; finally &#123; // 若是执行失败，调用 cancelAcquire(Node node)方法将这个节点从等待队列中删除 if (failed) &#123; cancelAcquire(node); &#125; &#125;&#125;// 在自旋操作期间成功获取到共享锁执行的操作(此处传入的propagate值为1,节点为当前节点新加入队列的节点)private void setHeadAndPropagate(Node node, int propagate) &#123; // 首先保留原始头节点，然后将当前的节点设置为头节点 Node h = head; setHead(node); // 已经将node节点设置为了头结点，需要唤醒下一个节点啦 // 1.若是传入的值大于0 // 2.若是传入的值小于等于0，原始头结点为null // 3.若是传入的值小于等于0，原始头节点不为null，原始头结点的waitStatus状态值小于0 // 4.给h重新赋了一次值后h为null // 5.给h重新赋了一次值后h不为null,其waitStatus状态值小于0 if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 || (h = head) == null || h.waitStatus &lt; 0) &#123; // 获取传入节点的下一个节点s Node s = node.next; // 若是s为null或者是s节点是共享模式，执行doReleaseShared方法 if (s == null || s.isShared()) &#123; doReleaseShared(); &#125; &#125;&#125;private void doReleaseShared() &#123; for (;;) &#123; // 首先保存头结点 Node h = head; // 若是头结点不为空并且头结点不等于尾节点(证明不只有一个节点) if (h != null &amp;&amp; h != tail) &#123; // 获取头结点的waitStatus状态值 int ws = h.waitStatus; // 若是该状态值为SIGNAL if (ws == Node.SIGNAL) &#123; // 尝试将节点h的waitStatus状态值由SIGNAL修改为0 if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) &#123; continue; &#125; // 若是修改成功，执行unparkSuccessor方法，唤醒当前节点的下一个节点 unparkSuccessor(h); // 若是该状态值为0,将其设置为PROPAGATE &#125; else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) &#123; continue; &#125; &#125; if (h == head) &#123; break; &#125; &#125;&#125;// 唤醒node节点的下一个节点private void unparkSuccessor(Node node) &#123; // ws小于0，存在三种状态 // SIGNAL(-1) CONDITION(-2) PROPAGATE(-3) int = node.waitStatus; if (ws &lt; 0) &#123; compareAndSetWaitStatus(node, ws, 0); &#125; // 获取node节点的下一个节点 Node s = node.next; // 去除一些无用的节点 if (s == null || s.waitStatus &gt; 0) &#123; s = null; for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) &#123; if (t.waitStatus &lt;= 0) &#123; s = t; &#125; &#125; &#125; // 唤醒操作 if (s != null) &#123; LockSupport.unpark(s.thread); &#125; &#125;","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"源码","slug":"java/源码","permalink":"https://zhilongao.github.io/categories/java/源码/"}]},{"title":"基础知识","date":"2019-09-30T02:08:09.000Z","path":"wiki/fra-spring-base/","text":"spring事务spring关于事务提供了两种编程模型，注解和接口编程。 基于注解：① xml文件开启注解驱动，相关类和方法上通过@Transactional注解标识。② spring在启动是会为这些class生成spring内部管理的bean，若是发现带有@Transactional注解的类和方法，会为其生成代理类，代理类中会做相关的事物处理（正常提交，异常回滚）。 基于接口：需要实现TransactionCallback接口。 spring事务传播属性 常量名称 常量解释 PROPAGATION_REQUIRED(propagation_required) 支持当前事物，如果当前没有事物，就新建一个事物。这是最常见的选择，也是spring默认的事物传播。 PROPAGATION_REQUIRES_NEW(propagation_requires_new) 新建事物，如果当前存在事物，就把当前事物挂起。新建的事物和挂起的事物没有任何的关系，是两个独立的事物。外层事物失败回滚之后，不能回滚内层事物执行的结果。内层事物失败抛出异常，外层事物捕获，也可以不处理回滚操作。 PROPAGATION_SUPPORTS(propagation_supports) 支持当前事物，如果当前没有事物，就以非事物的方式执行。 PROPAGATION_MANDATORY(propagation_mandatory) 支持当前事物，如果当前没有事物，就抛出异常。 PROPAGATION_NOT_SUPPORTED(propagation_not_supported) 以非事物方式执行操作，如果当前存在事物，就把当前事物挂起。 PROPAGATION_NEVER(propagation_never) 以非事物方式执行操作，如果当前存在事物，就抛出异常。 PROPAGATION_NESTED(propagation_nested) 如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务，则按REQUIRED属性执行。它使用了一个单独的事务，这个事务拥有多个可以回滚的保存点。内部事务的回滚不会对外部事务造成影响。它只对DataSourceTransactionManager事务管理器起效。 数据库事务隔离级别 隔离级别 隔离级别的值 导致的问题 Read Uncommited 0 允许脏读，不可重复读，幻读 Read Commited 1 避免脏读，允许不可重复读和幻读 RepeatableRead 2 避免脏读和不可重复读，允许幻读 Serializable 3 避免脏读 ，不可重复读，幻读，事物一个一个执行，执行效率低 spring事务隔离级别 常量名称 常量解释 ISOLATION_DEFAULT(isolation_default) PlatfromTransactionManager默认的事物隔离级别，使用数据库默认的事物隔离级别。 ISOLATION_READ_UNCOMMITTED(isolation_read_uncommitted) 读未提交 ISOLATION_READ_COMMITTED(isolation_read_committed) 读已提交 ISOLATION_REPEATABLE_READ(isolation_repeatable) 可重复读 ISOLATION_SERIALIZABLE(isolation_serializable) 串行化 参考深入了解spring事务原理 Restful风格 一致性hash","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"框架","slug":"java/框架","permalink":"https://zhilongao.github.io/categories/java/框架/"},{"name":"spring","slug":"java/框架/spring","permalink":"https://zhilongao.github.io/categories/java/框架/spring/"}]},{"title":"注解驱动","date":"2019-09-30T02:07:41.000Z","path":"wiki/fra-spring-annotation/","text":"元注解(Meta-Annotations)所谓元注解，是指能够声明在其他注解上的注解，若是一个注解标注在其他注解上，那么他就是元注解。如java的@Documented @Repeatable @Inherited等注解，spring的@Component等注解。 spring内建模式注解spring中提供了诸如@Repository @Service @Controller @Configuration等的注解，用以标记某一领域内的对象，故称这类注解为模式注解。这些注解均派生自@Component，spring可以通过这些注解的元标注@Component来扫描并注册这些组件。 // @Controller注解定义@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Componentpublic @interface Controller &#123; String value() default \"\";&#125; 自定义模式注解// 自定义派生注解@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Componentpublic @interface StringRepository &#123; /** * 属性方法名称必须与@Component#value()一致 * @return */ String value() default \"\";&#125;// 被自定义注解修饰的bean@StringRepository(value = \"stringService\")public class StringService &#123; public List&lt;String&gt; findAll()&#123; return Arrays.asList(\"jack\", \"tom\", \"seven\"); &#125;&#125;// 启动类public class App &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(); context.setConfigLocation(\"classpath:beans1.xml\"); context.refresh(); StringService stringService = (StringService)context.getBean(\"stringService\"); System.out.printf(\"stringService.findAll() = %s \\n\", stringService.findAll()); &#125; // 输出结果 // stringService.findAll() = [jack, tom, seven] &#125; &lt;!-- beans1.xml --&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd\"&gt; &lt;context:annotation-config/&gt; &lt;context:component-scan base-package=\"com.study.annotation.component\"/&gt;&lt;/beans&gt; 原理分析spring 会在初始化解析xml 文件时读取 /META-INF/spring.handlers 文件中的配置，该配置文件中定义了一些命名空间的处理类。比如 context 命名空间的处理类为 ContextNamespaceHandler，aop命名空间的处理类为AopNamespaceHandler。这些命名空间处理类在spring应用上下文启动时，调用其init方法。该方法会去注册该命名空间下所有local元素的Bean定义解析器。如context命名空间处理类会去注册annotation-config，component-scan的Bean定义解析器。 // spring.handlers文件http\\://www.springframework.org/schema/context=org.springframework.context.config.ContextNamespaceHandlerhttp\\://www.springframework.org/schema/aop=org.springframework.aop.config.AopNamespaceHandler public class ContextNamespaceHandler extends NamespaceHandlerSupport &#123; public void init() &#123; ... // 注册annotation-config解析器 registerJava5DependentParser(\"annotation-config\", \"org.springframework.context.annotation.AnnotationConfigBeanDefinitionParser\"); // 注册component-scan解析器 registerJava5DependentParser(\"component-scan\", \"org.springframework.context.annotation.ComponentScanBeanDefinitionParser\"); ... &#125;&#125; 关于&lt;context:component-scan&gt;元素的Bean定义解析器ComponentScanBeanDefinitionParser。该类实现了BeanDefinitionParser接口，解析至该元素时，会去调用parse方法。 // ComponentScanBeanDefinitionParser处理public class ComponentScanBeanDefinitionParser implements BeanDefinitionParser &#123; ... // 包扫描路径 private static final String BASE_PACKAGE_ATTRIBUTE = \"base-package\"; // 使用默认过滤器属性 private static final String USE_DEFAULT_FILTERS_ATTRIBUTE = \"use-default-filters\"; private static final String RESOURCE_PATTERN_ATTRIBUTE = \"resource-pattern\"; @Override public BeanDefinition parse(Element element, ParserContext parserContext) &#123; // 1. 解析 base-package 属性，获取到一个扫包路径数组 String basePackage = element.getAttribute(BASE_PACKAGE_ATTRIBUTE); basePackage = parserContext.getReaderContext().getEnvironment().resolvePlaceholders(basePackage); String[] basePackages = StringUtils.tokenizeToStringArray(basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS); // 2. 配置 ClassPathBeanDefinitionScanner 对象 ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element); // 3. ClassPathBeanDefinitionScanner执行 doScan 方法，获取 BeanDefinitionHolder集合 Set&lt;BeanDefinitionHolder&gt; beanDefinitions = scanner.doScan(basePackages); // 4. 注册集合中的这些 BeanDefinitionHolder registerComponents(parserContext.getReaderContext(), beanDefinitions, element); return null; &#125; /**************配置ClassPathBeanDefinitionScanner**************/ protected ClassPathBeanDefinitionScanner configureScanner(ParserContext parserContext, Element element) &#123; // 1. 关于 use-default-filters 属性，若是用户配置了，取用户配置的值，否则默认为 true boolean useDefaultFilters = true; if (element.hasAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE)) &#123; useDefaultFilters = Boolean.valueOf(element.getAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE)); &#125; // 2. 调用 createScanner 方法创建一个 ClassPathBeanDefinitionScanner 对象，并设置相关属性 ClassPathBeanDefinitionScanner scanner = createScanner(parserContext.getReaderContext(), useDefaultFilters); scanner.setBeanDefinitionDefaults(parserContext.getDelegate().getBeanDefinitionDefaults()); scanner.setAutowireCandidatePatterns(parserContext.getDelegate().getAutowireCandidatePatterns()); // 3. 若是元素中包含 resource-pattern 属性 if (element.hasAttribute(RESOURCE_PATTERN_ATTRIBUTE)) &#123; scanner.setResourcePattern(element.getAttribute(RESOURCE_PATTERN_ATTRIBUTE)); &#125; try &#123; parseBeanNameGenerator(element, scanner); &#125; catch (Exception ex) &#123; ... &#125; try &#123; parseScope(element, scanner); &#125; catch (Exception ex) &#123; ... &#125; parseTypeFilters(element, scanner, parserContext); return scanner; &#125; // 创建一个 ClassPathBeanDefinitionScanner对象 protected ClassPathBeanDefinitionScanner createScanner(XmlReaderContext readerContext, boolean useDefaultFilters) &#123; return new ClassPathBeanDefinitionScanner( readerContext.getRegistry(), useDefaultFilters, readerContext.getEnvironment(), readerContext.getResourceLoader()); &#125; ...&#125; ClassPathBeanDefinitionScanner执行doScan方法 // ClassPathBeanDefinitionScanner处理public class ClassPathBeanDefinitionScanner extends ClassPathScanningCandidateComponentProvider &#123; // BeanDefinition注册器 private final BeanDefinitionRegistry registry; // Environment环境 private Environment environment; private BeanDefinitionDefaults beanDefinitionDefaults = new BeanDefinitionDefaults(); public ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry) &#123; this(registry, true); &#125; public ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters) &#123; this(registry, useDefaultFilters, getOrCreateEnvironment(registry)); &#125; public ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters, Environment environment) &#123; this(registry, useDefaultFilters, environment, (registry instanceof ResourceLoader ? (ResourceLoader) registry : null)); &#125; // 构造函数 BeanDefinitionRegistry useDefaultFilters Environment ResourceLoader public ClassPathBeanDefinitionScanner( BeanDefinitionRegistry registry, boolean useDefaultFilters, Environment environment, ResourceLoader resourceLoader) &#123; // 1. 设置 BeanDefinitionRegistry this.registry = registry; // 2. 若是使用默认过滤器，执行父类 ClassPathScanningCandidateComponentProvider方法 if (useDefaultFilters) &#123; registerDefaultFilters(); &#125; // 3. 父类 ClassPathScanningCandidateComponentProvider 方法 setEnvironment(environment); // 4. 父类 ClassPathScanningCandidateComponentProvider 方法 setResourceLoader(resourceLoader); &#125; /************************doScan方法****************/ protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123; // 1. 创建一个存储 BeanDefinitinHolder的集合 Set&lt;BeanDefinitionHolder&gt; beanDefinitions = new LinkedHashSet&lt;BeanDefinitionHolder&gt;(); // 2. 循环遍历给定的包路径数组 for (String basePackage : basePackages) &#123; // 3. 调用 findCandidateComponents 方法找到给定包下的 BeanDefinition Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage); // 4. 遍历这些 BeanDefinition for (BeanDefinition candidate : candidates) &#123; // 5.获取scope元信息ScopeMetadata并设置到candidate的scope属性中，如：single ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate); candidate.setScope(scopeMetadata.getScopeName()); // 6. 为这个 candidate 生成一个 beanName String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry); // 7. 若是 candidate 是 AbstractBeanDefinition 的子类，调用 postProcessBeanDefinition方法 if (candidate instanceof AbstractBeanDefinition) &#123; postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName); &#125; // 8. 若是 candidiate 是 AnnotatedBeanDefinition 的子类 if (candidate instanceof AnnotatedBeanDefinition) &#123; AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);&#125; // 9. 调用 checkCandidate 方法检验 if (checkCandidate(beanName, candidate)) &#123; BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName); definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); beanDefinitions.add(definitionHolder); registerBeanDefinition(definitionHolder, this.registry); &#125; &#125; &#125; // 返回BeanDefinitionHolder集合，在类 ComponentScanBeanDefinitionParser 中注册 return beanDefinitions; &#125; ...&#125; ClassPathScanningCandidateComponentProvider public class ClassPathScanningCandidateComponentProvider implements EnvironmentCapable, ResourceLoaderAware &#123; // 组件包含项过滤器列表 private final List&lt;TypeFilter&gt; includeFilters = new LinkedList&lt;TypeFilter&gt;(); // 组件排除项过滤器列表 private final List&lt;TypeFilter&gt; excludeFilters = new LinkedList&lt;TypeFilter&gt;(); // MetadataReaderFactory-&gt;CachingMetadataReaderFactory private MetadataReaderFactory metadataReaderFactory; private ResourcePatternResolver resourcePatternResolver; // 通过给定的包路径寻找候选组件 public Set&lt;BeanDefinition&gt; findCandidateComponents(String basePackage) &#123; // 1. 创建一个集合，用以存储 BeanDefinition Set&lt;BeanDefinition&gt; candidates = new LinkedHashSet&lt;BeanDefinition&gt;(); try &#123; // 2. 将包路径(com.study.annotation.component)转化为class文件路径 // (classpath*:com/study/annotation/component/**/*.class) String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + resolveBasePackage(basePackage) + '/' + this.resourcePattern; // 3. 将class文件路径转化packageSearchPath转化为Resource数组 Resource[] resources = this.resourcePatternResolver.getResources(packageSearchPath); // 4. 循环遍历Resource数组 for (Resource resource : resources) &#123; // 5.若是这个资源Resource可读 if (resource.isReadable()) &#123; try &#123; // 6.获取这个资源Resource的MetadataReader对象 MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(resource); // 7. 判断metadataReader是否是候选组件 //org.springframework.core.type.classreading.SimpleMetadataReader if (isCandidateComponent(metadataReader)) &#123; // 8. 生成一个 ScannedGenericBeanDefinition对象 ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader); sbd.setResource(resource); sbd.setSource(resource); // 9.若ScannedGenericBeanDefinition是候选组件，加入到candidates中 if (isCandidateComponent(sbd)) &#123; ... candidates.add(sbd); &#125; else &#123; ... &#125; &#125; else &#123; ... &#125; &#125; catch (Throwable ex) &#123; throw new BeanDefinitionStoreException(); &#125; &#125; else &#123; ... &#125; &#125; &#125; catch (IOException ex) &#123; throw new BeanDefinitionStoreException(); &#125; return candidates; &#125; // 判断给定的 MetadataReader 是否是候选组件(SimpleMetadataReader) protected boolean isCandidateComponent(MetadataReader metadataReader) throws IOException &#123; // 循环排除项过滤器 for (TypeFilter tf : this.excludeFilters) &#123; if (tf.match(metadataReader, this.metadataReaderFactory)) &#123; return false; &#125; &#125; // 循环包含项过滤器 for (TypeFilter tf : this.includeFilters) &#123; if (tf.match(metadataReader, this.metadataReaderFactory)) &#123; return isConditionMatch(metadataReader); &#125; &#125; return false; &#125; private boolean isConditionMatch(MetadataReader metadataReader) &#123; if (this.conditionEvaluator == null) &#123; this.conditionEvaluator = new ConditionEvaluator(getRegistry(), getEnvironment(), getResourceLoader()); &#125; return !this.conditionEvaluator.shouldSkip(metadataReader.getAnnotationMetadata()); &#125; // 判断给定的 AnnotatedBeanDefinition 是否是候选组件 protected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) &#123; // 1. 获取AnnotatedBeanDefinition的AnnotationMetadata注解元信息，实现类为 // org.springframework.core.type.classreading.AnnotationMetadataReadingVisitor AnnotationMetadata metadata = beanDefinition.getMetadata(); return (metadata.isIndependent() &amp;&amp; (metadata.isConcrete() || (metadata.isAbstract() &amp;&amp; metadata.hasAnnotatedMethods(Lookup.class.getName())))); &#125; // 注册默认的过滤器-&gt;@Component @ManagedBean @Named protected void registerDefaultFilters() &#123; this.includeFilters.add(new AnnotationTypeFilter(Component.class)); ClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader(); try &#123; this.includeFilters.add(new AnnotationTypeFilter( ((Class&lt;? extends Annotation&gt;) ClassUtils.forName(\"javax.annotation.ManagedBean\", cl)), false)); &#125; catch (ClassNotFoundException ex) &#123; ... &#125; try &#123; this.includeFilters.add(new AnnotationTypeFilter( ((Class&lt;? extends Annotation&gt;) ClassUtils.forName(\"javax.inject.Named\", cl)), false)); &#125; catch (ClassNotFoundException ex) &#123; ... &#125; &#125; // 设置环境Environment public void setEnvironment(Environment environment) &#123; this.environment = environment; this.conditionEvaluator = null; &#125; @Override public void setResourceLoader(@Nullable ResourceLoader resourceLoader) &#123; // 设置resourcePatternResolver this.resourcePatternResolver = ResourcePatternUtils.getResourcePatternResolver(resourceLoader); // 设置metadataReaderFactory this.metadataReaderFactory = new CachingMetadataReaderFactory(resourceLoader); this.componentsIndex = CandidateComponentsIndexLoader.loadIndex(this.resourcePatternResolver.getClassLoader()); &#125; &#125; 关于MetadataReaderFactory // 顶层接口，提供两种方式获取MetadataReader-&gt;className和Resourcepublic interface MetadataReaderFactory &#123; MetadataReader getMetadataReader(String className) throws IOException; MetadataReader getMetadataReader(Resource resource) throws IOException;&#125;public class SimpleMetadataReaderFactory implements MetadataReaderFactory &#123; private final ResourceLoader resourceLoader; // 根据给定的Resource返回一个MetadataReader对象 @Override public MetadataReader getMetadataReader(Resource resource) throws IOException &#123; return new SimpleMetadataReader(resource, this.resourceLoader.getClassLoader()); &#125;&#125;public class CachingMetadataReaderFactory extends SimpleMetadataReaderFactory &#123; public static final int DEFAULT_CACHE_LIMIT = 256; private volatile int cacheLimit = DEFAULT_CACHE_LIMIT; // Resource-&gt;MetadataReader映射 private final Map&lt;Resource, MetadataReader&gt; metadataReaderCache = new LinkedHashMap&lt;Resource, MetadataReader&gt;(DEFAULT_CACHE_LIMIT, 0.75f, true)&#123; @Override protected boolean removeEldestEntry(Map.Entry&lt;Resource, MetadataReader&gt; eldest) &#123; return size() &gt; getCacheLimit(); &#125; &#125;; // 基于Resource方式获取MetadataReader @Override public MetadataReader getMetadataReader(Resource resource) throws IOException &#123; // 缓存限制小于等于0，直接调用父类SimpleMetadataReaderFactory方法获取 if (getCacheLimit() &lt;= 0) &#123; return super.getMetadataReader(resource); &#125; // 缓存限制大于0，锁定缓存 synchronized (this.metadataReaderCache) &#123; // 从缓存加载，若是加载不到，调用父类方法加载，存入缓存并返回 MetadataReader metadataReader = this.metadataReaderCache.get(resource); if (metadataReader == null) &#123; metadataReader = super.getMetadataReader(resource); this.metadataReaderCache.put(resource, metadataReader); &#125; return metadataReader; &#125; &#125; public int getCacheLimit() &#123; return this.cacheLimit; &#125;&#125; 关于MetadataReader // 元信息读取接口public interface MetadataReader &#123; // 获取资源信息Resource Resource getResource(); // 获取Class的元信息ClassMetadata ClassMetadata getClassMetadata(); // 获取注解Annotation的元信息AnnotationMetadata AnnotationMetadata getAnnotationMetadata();&#125;// 元信息读取接口的简单实现class SimpleMetadataReader implements MetadataReader &#123; private final Resource resource; private final ClassMetadata classMetadata; private final AnnotationMetadata annotationMetadata; // 构造方法，通过给定的Resource和ClassLoader创建一个SimpleMetadataReader对象 SimpleMetadataReader(Resource resource, ClassLoader classLoader) throws IOException &#123; InputStream is = new BufferedInputStream(resource.getInputStream()); ClassReader classReader; try &#123; classReader = new ClassReader(is); &#125; catch (IllegalArgumentException ex) &#123; throw new NestedIOException(); &#125; finally &#123; is.close(); &#125; // 创建AnnotationMetadataReadingVisitor对象 AnnotationMetadataReadingVisitor visitor = new AnnotationMetadataReadingVisitor(classLoader); classReader.accept(visitor, ClassReader.SKIP_DEBUG); // 将SimpleMetadataReader的annotationMetadata和classMetadata属性均设置为visitor this.annotationMetadata = visitor; this.classMetadata = visitor; // 将SimpleMetadataReader的resource设置为resource this.resource = resource; &#125; @Override public Resource getResource() &#123; return this.resource; &#125; @Override public ClassMetadata getClassMetadata() &#123; return this.classMetadata; &#125; @Override public AnnotationMetadata getAnnotationMetadata() &#123; return this.annotationMetadata; &#125;&#125; 关于加载BeanDefinition时的过滤器 TypeFilter // 上层接口public interface TypeFilter &#123; boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException;&#125;// 抽象类public abstract class AbstractTypeHierarchyTraversingFilter implements TypeFilter &#123; // 是否考虑继承 private final boolean considerInherited; // 是否考虑接口 private final boolean considerInterfaces; // 实现上层接口 TypeFilter 的 match 方法 @Override public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException &#123; // 1. 调用 matchSelf方法，若是返回 true，直接返回 if (matchSelf(metadataReader)) &#123; return true; &#125; // 2. 获取 metadatdaReader的 ClassMetadata ClassMetadata metadata = metadataReader.getClassMetadata(); if (matchClassName(metadata.getClassName())) &#123; return true; &#125; // 3. 若时考虑继承，则匹配父类 if (this.considerInherited) &#123; // 从Class元信息ClassMetadata中判断该类是否有父类 if (metadata.hasSuperClass()) &#123; // 若是该类有父类，调用matchSuperClass方法 Boolean superClassMatch = matchSuperClass(metadata.getSuperClassName()); if (superClassMatch != null) &#123; if (superClassMatch.booleanValue()) &#123; return true; &#125; &#125; else &#123; try &#123; if (match(metadata.getSuperClassName(), metadataReaderFactory)) &#123; return true; &#125; &#125; catch (IOException ex) &#123; ... &#125; &#125; &#125; &#125; if (this.considerInterfaces) &#123; for (String ifc : metadata.getInterfaceNames()) &#123; Boolean interfaceMatch = matchInterface(ifc); if (interfaceMatch != null) &#123; if (interfaceMatch.booleanValue()) &#123; return true; &#125; &#125; else &#123; try &#123; if (match(ifc, metadataReaderFactory)) &#123; return true; &#125; &#125; catch (IOException ex) &#123; ... &#125; &#125; &#125; &#125; return false; &#125; protected boolean matchSelf(MetadataReader metadataReader) &#123; return false; &#125; protected boolean matchClassName(String className) &#123; return false; &#125; protected Boolean matchSuperClass(String superClassName) &#123; return null; &#125; &#125;// 实现类public class AnnotationTypeFilter extends AbstractTypeHierarchyTraversingFilter &#123; private final Class&lt;? extends Annotation&gt; annotationType; private final boolean considerMetaAnnotations; // MetadataReader时SimpleMetadataReader @Override protected boolean matchSelf(MetadataReader metadataReader) &#123; //获取到 MetadataReader 的注解元信息 AnnotationMetadata AnnotationMetadata metadata = metadataReader.getAnnotationMetadata(); //该MetadataReader直接被annotationType注解修饰返回true //修饰该MetadataReader注解的元注解中有annotationType返回true return metadata.hasAnnotation(this.annotationType.getName()) || (this.considerMetaAnnotations &amp;&amp; metadata.hasMetaAnnotation(this.annotationType.getName())); &#125; @Override protected Boolean matchSuperClass(String superClassName) &#123; return hasAnnotation(superClassName); &#125; protected Boolean hasAnnotation(String typeName) &#123; if (Object.class.getName().equals(typeName)) &#123; return false; &#125; else if (typeName.startsWith(\"java\")) &#123; if (!this.annotationType.getName().startsWith(\"java\")) &#123; return false; &#125; try &#123; Class&lt;?&gt; clazz = ClassUtils.forName(typeName, getClass().getClassLoader()); return ((this.considerMetaAnnotations ? AnnotationUtils.getAnnotation(clazz, this.annotationType) : clazz.getAnnotation(this.annotationType)) != null); &#125; catch (Throwable ex) &#123; &#125; &#125; return null; &#125;&#125; 关于ClassReader // Class信息读取类ClassReaderpublic class ClassReader &#123; public ClassReader(final InputStream is) throws IOException &#123; this(readClass(is, false)); &#125; public void accept(final ClassVisitor classVisitor, final int flags) &#123; accept(classVisitor, new Attribute[0], flags); &#125; public void accept(final ClassVisitor classVisitor, final Attribute[] attrs, final int flags) &#123; ... &#125;&#125; 关于AnnotationMetadata /*************************** AnnotatioMetadata接口 **************/public interface AnnotationMetadata extends ClassMetadata, AnnotatedTypeMetadata &#123; Set&lt;String&gt; getAnnotationTypes(); Set&lt;String&gt; getMetaAnnotationTypes(String annotationName); boolean hasAnnotation(String annotationName); boolean hasMetaAnnotation(String metaAnnotationName); boolean hasAnnotatedMethods(String annotationName); Set&lt;MethodMetadata&gt; getAnnotatedMethods(String annotationName);&#125;public interface ClassMetadata &#123; String getClassName(); boolean isInterface(); boolean isAnnotation(); boolean isAbstract(); boolean isConcrete(); boolean isFinal(); boolean isIndependent(); boolean hasEnclosingClass(); String getEnclosingClassName(); boolean hasSuperClass(); String getSuperClassName(); String[] getInterfaceNames(); String[] getMemberClassNames();&#125;public interface AnnotatedTypeMetadata &#123; boolean isAnnotated(String annotationName); Map&lt;String, Object&gt; getAnnotationAttributes(String annotationName); Map&lt;String, Object&gt; getAnnotationAttributes(String annotationName, boolean classValuesAsString); MultiValueMap&lt;String, Object&gt; getAllAnnotationAttributes(String annotationName); MultiValueMap&lt;String, Object&gt; getAllAnnotationAttributes(String annotationName, boolean classValuesAsString);&#125; 关于ClassMetadataReadingVisitor class ClassMetadataReadingVisitor extends ClassVisitor implements ClassMetadata &#123; private String enclosingClassName; private boolean independentInnerClass; private boolean isInterface; private boolean isAbstract; @Override public boolean isIndependent() &#123; return (this.enclosingClassName == null || this.independentInnerClass); &#125; @Override public boolean isConcrete() &#123; return !(this.isInterface || this.isAbstract); &#125; @Override public boolean isAbstract() &#123; return this.isAbstract; &#125;&#125;public abstract class ClassVisitor &#123; &#125;public interface ClassMetadata &#123; &#125; 关于 AnnotationMetadataReadingVisitor public class AnnotationMetadataReadingVisitor extends ClassMetadataReadingVisitor implements AnnotationMetadata &#123; @Override public boolean hasAnnotatedMethods(String annotationName) &#123; for (MethodMetadata methodMetadata : this.methodMetadataSet) &#123; if (methodMetadata.isAnnotated(annotationName)) &#123; return true; &#125; &#125; return false; &#125; &#125;public interface AnnotationMetadata extends ClassMetadata, AnnotatedTypeMetadata &#123; &#125;public interface AnnotatedTypeMetadata &#123; &#125; // AnnotatedBeanDefinition基于注解的BeanDefinitionpublic interface AnnotatedBeanDefinition extends BeanDefinition &#123; AnnotationMetadata getMetadata(); MethodMetadata getFactoryMethodMetadata();&#125;// GenericBeanDefinition层次性的BeanDefinition定义public class GenericBeanDefinition extends AbstractBeanDefinition &#123; private String parentName; public GenericBeanDefinition() &#123; super(); &#125; public GenericBeanDefinition(BeanDefinition original) &#123; super(original); &#125; @Override public void setParentName(String parentName) &#123; this.parentName = parentName; &#125; @Override public String getParentName() &#123; return this.parentName; &#125; @Override public AbstractBeanDefinition cloneBeanDefinition() &#123; return new GenericBeanDefinition(this); &#125; @Override public boolean equals(Object other) &#123; return (this == other || (other instanceof GenericBeanDefinition &amp;&amp; super.equals(other))); &#125; @Override public String toString() &#123; StringBuilder sb = new StringBuilder(\"Generic bean\"); if (this.parentName != null) &#123; sb.append(\" with parent '\").append(this.parentName).append(\"'\"); &#125; sb.append(\": \").append(super.toString()); return sb.toString(); &#125;&#125;// ScannedGenericBeanDefinition 基于扫描获取到的 BeanDefinitionpublic class ScannedGenericBeanDefinition extends GenericBeanDefinition implements AnnotatedBeanDefinition &#123; private final AnnotationMetadata metadata; public ScannedGenericBeanDefinition(MetadataReader metadataReader) &#123; ... this.metadata = metadataReader.getAnnotationMetadata(); setBeanClassName(this.metadata.getClassName()); &#125; @Override public final AnnotationMetadata getMetadata() &#123; return this.metadata; &#125; @Override public MethodMetadata getFactoryMethodMetadata() &#123; return null; &#125;&#125; spring组合注解spring注解属性别名和覆盖Enable条件装配","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"框架","slug":"java/框架","permalink":"https://zhilongao.github.io/categories/java/框架/"},{"name":"spring","slug":"java/框架/spring","permalink":"https://zhilongao.github.io/categories/java/框架/spring/"}]},{"title":"Unsafe","date":"2019-09-27T09:19:05.000Z","path":"wiki/ans-unsafe-source/","text":"Unsafe类// jdk核心类库可操作的apipublic final class Unsafe &#123; // 对外暴露的实例属性，类加载阶段加载 private static final Unsafe theUnsafe; static &#123; ... theUnsafe = new Unsafe(); ... &#125; private Unsafe() &#123;&#125; // 该类中的 theUnsafe 属性为该类的一个实例，对外只提供给jdk核心类库使用。我们在平常的开发中无法通过该方法来获取 theUnsafe 对象。（可以通过万能的反射方式获取） @CallerSensitive public static Unsafe getUnsafe() &#123; Class var0 = Reflection.getCallerClass(); if (!VM.isSystemDomainLoader(var0.getClassLoader())) &#123; throw new SecurityException(\"Unsafe\"); &#125; else &#123; return theUnsafe; &#125; &#125; // native方法，阻塞当前线程 public native void park(boolean var1, long var2); // native方法，唤醒指定的线程 public native void unpark(Object var1);&#125; Unsafe操作 获取Unsafe实例 由于Unsafe实例获取方法添加了类加载器验证，所以我们代码中编写的类是无法直接使用Unsafe类的。一般我们可以有两种方式获取Unsafe实例。① 从限制条件入手，修改引导类加载路径，将我们编写的路径添加到引导类路径中。② 通过反射的方式获取。 public static void main(String[] args) throws InterruptedException &#123; // 获取到Unsafe实例 Unsafe unsafe = getUnsafe(); System.out.println(unsafe);&#125;// 1.通过反射获取 Unsafe 实例private static Unsafe getUnsafe() &#123; Unsafe unsafe = null; try &#123; Field field = Unsafe.class.getDeclaredField(\"theUnsafe\"); field.setAccessible(true); unsafe = (Unsafe)field.get(null); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return unsafe;&#125; 非常规对象实例化 public static void main(String[] args) throws InterruptedException &#123; // 非常规对象实例化 People p1 = (People)getInstance(People.class); People p2 = (People)getInstance(People.class); System.out.println(p1); System.out.println(p2); // 输出结果 // null:0 // null:0&#125;// 获取指定类的实例，该方式不会调用指定类的构造方法public static Object getInstance (Class clazz) &#123; Unsafe unsafe = getUnsafe(); Object p = null; try &#123; p = unsafe.allocateInstance(clazz); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; return p;&#125;// 可操作类class People &#123; String name; int age; public People()&#123; this.name = \"default\"; this.age = 18; &#125; public People(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return this.name + \":\" + this.age; &#125;&#125; 多线程同步(CAS操作) juc提供了一些原子操作类，这些类中使用了 Unsafe 类中提供的一些方法。 public class AtomicInteger extends Number implements java.io.Serializable &#123; // 获取到 Unsafe 类对象 private static final Unsafe unsafe = Unsafe.getUnsafe(); // value属性在内存地址中的偏移量 private static final long valueOffset; // 静态代码块，初始化 valueOffset 属性 static &#123; try &#123; valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField(\"value\")); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125; // 该类所持有的值 private volatile int value; // 获取当前值，并将其加1 // 调用 UnSafe 类的 getAndAddInt 方法，返回 this 对象上地址偏移量为 valueOffset 处的值，并将其加1 public final int getAndIncrement() &#123; return unsafe.getAndAddInt(this, valueOffset, 1); &#125;&#125;public final class Unsafe &#123; ... // 某个对象的某个地址偏移处的值加上某个值，并将原始值返回 public final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; // 获取到原始值 var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5; &#125; // 获取 public native int getIntVolatile(Object var1, long var2); // CAS更新 public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5); ... &#125; 挂起与恢复 在LockSupport中提供了两个方法，park与unpark方法，而这两个方法实际上又是调用的Unsafe类中的native方法。park是将当前调用线程阻塞，而unpark方法则是唤醒指定的线程。 public class LockSupport &#123; // 加载 Unsafe 类型的 UNSAFE 实例 private static final sun.misc.Unsafe UNSAFE; static &#123; try &#123; ... UNSAFE = sun.misc.Unsafe.getUnsafe(); ... &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125; // LockSupport提供了挂起当前线程的多个方法 public static void park() &#123; UNSAFE.park(false, 0L); &#125; public static void park(Object blocker) &#123; Thread t = Thread.currentThread(); setBlocker(t, blocker); UNSAFE.park(false, 0L); setBlocker(t, null); &#125; // 调用 Unsafe 类的unpark方法唤醒指定的线程 public static void unpark(Thread thread) &#123; if (thread != null) &#123; UNSAFE.unpark(thread); &#125; &#125;&#125; public final class Unsafe &#123; ... // 操作系统底层提供的挂起线程的方法(阻塞线程) public native void park(boolean var1, long var2); // 操作系统底层提供的唤醒线程的方法(取消阻塞线程) public native void unpark(Object var1); // 几个过期的方法 // 获得对象锁(可重入锁) @Deprecated public native void monitorEnter(Object var1); // 释放对象锁 @Deprecated public native void monitorExit(Object var1); // 尝试获取对象锁 @Deprecated public native boolean tryMonitorEnter(Object var1); ...&#125; 内存管理 // 内存分配public native long allocateMemory(long var1);// 扩充内存public native long reallocateMemory(long var1, long var3);// 释放内存public native void freeMemory(long var1);// 在给定的内存块中设置值public native void setMemory(Object var1, long var2, long var4, byte var6);// 内存拷贝public native void copyMemory(Object var1, long var2, Object var4, long var5, long var7);// 关于堆外内存的使用// 使用原因: 垃圾回收停顿的改善 提升程序IO操作的性能// java实现堆外内存操作的类 DirectByteBufferclass DirectByteBuffer extends MappedByteBuffer implements DirectBuffer &#123; &#125; 数组操作 内存屏障","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"源码","slug":"java/源码","permalink":"https://zhilongao.github.io/categories/java/源码/"}]},{"title":"AQS","date":"2019-09-27T06:19:27.000Z","path":"wiki/ans-aqs-source/","text":"AQS类内部结构public abstract class AbstractQueuedSynchronizer &#123; private transient volatile Node head; // 同步队列头节点 private transient volatile Node tail; // 同步队列尾节点 private volatile int state; // 锁状态值 static final class Node &#123; /*nextWaiter 属性的几个状态值*/ static final Node SHARED = new Node(); // 标记节点在共享模式下等待 static final Node EXCLUSIVE = null; // 标记节点在排他模式下等待 /*waitStatus 属性的几个状态值*/ static final int CANCELLED = 1; // 表示节点已经被取消 static final int SIGNAL = -1; // 表示后面节点的线程需要被唤醒。 static final int CONDITION = -2; // 表示节点在条件队列上 static final int PROPAGATE = -3; // 关于共享锁的状态 volatile int waitStatus; volatile Node prev; // 前驱 volatile Node next; // 后继 volatile Thread thread; // 节点封装的线程 Node nextWaiter; // 下一个等待的节点 // addWaiter方法调用时，会构造一个Node节点 Node(Thread thread, Node mode) &#123; this.nextWaiter = mode; this.thread = thread; &#125; &#125;&#125; acquire方法该方法定义为获取，ReentrantLock内部获取锁的操作会调用该方法。该方法的执行流程为： ① 执行tryAcquire，若是该方法返回为true，直接结束。否则执行下一步操作。(tryAcquire是一个空方法，具体逻辑由子类来实现)。 ② 执行addWaiter方法，参数值为Node.EXCLUSIVE。① 该操作首先会将当前线程封装成为一个Node节点，该Node节点的thread值为当前线程，nextWaiter值为null。② 将创建好的该节点添加到同步队列的尾部。③ 将该节点返回。 ③ 执行 acquireQueued(Node node, int arg)方法。该方法以自旋开始。① 获取到给定节点node的前驱节点p。若是p为头节点并且尝试获取锁成功，则将node节点设置为头节点（thread和prev属性设置为null），将p节点清除，返回线程中断表标识。② 若上面条件不满足或执行失败，执行shouldParkAfterFailedAcquire方法和parkAndCheckInterrupt方法。③ 首先是会执行shouldParkAfterFailedAcquire(p, node)方法的，该方法是判断当前线程获取锁失败后，是否需要挂起。执行逻辑是：判断前一个节点p的waitStatus状态值，若是该值为Node.SIGNAL，返回true。其它情况返回false。④ 若是shouldParkAfterFailedAcquire(p, node)方法返回值为true，执行parkAndCheckInterrupt方法，否则执行 ①。⑤ parkAndCheckInterrupt方法首先将当前线程挂起，然后返回线程的中断标识，若是为true，会将interrupted属性设置为true。 ④ 由于acquireQueued(Node node, int agr)方法返回的是当前线程的中断标识，若是返回为true，立马中断当前线程。 public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) &#123; selfInterrupt(); &#125; &#125;// 一个空方法，具体逻辑由子类来实现protected boolean tryAcquire(int arg) &#123; throw new UnsupportedOperationException();&#125;// addWaiter方法，添加一个节点到同步队列private Node addWaiter(Node mode) &#123; Node node = new Node(Thread.currentThread(), mode); Node pred = tail; if (pred != null) &#123; node.prev = pred; if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; enq(node); return node;&#125;// 添加一个节点到同步队列，直到成功为止private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail; if (t == null) &#123; // Must initialize if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125;&#125;// 一段自旋操作中，成功获取到锁，该方法才会结束。final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) &#123; interrupted = true; &#125; &#125; &#125; finally &#123; if (failed) &#123; cancelAcquire(node); &#125; &#125;&#125;// 将给定的节点设置为头节点，① head指向node ② node的thread属性指向null ③ node的prev属性指向nullprivate void setHead(Node node) &#123; head = node; node.thread = null; node.prev = null;&#125;// 当尝试获取锁失败后，判断是否应该将当前的线程挂起private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; int ws = pred.waitStatus; // 前一个节点waitStatus状态值为SIGNAL(-1),线程可以被安全的挂起 if (ws == Node.SIGNAL) &#123; return true; &#125; // 若是前一个节点被取消了(1)，跳过该节点 if (ws &gt; 0) &#123; do &#123; // pred和node.prev重新赋值 node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); // 将pred的next指向node节点 pred.next = node; &#125; else &#123; // 其它情况，CAS操作将 pred的状态值修改为 SIGNAL compareAndSetWaitStatus(pred, ws, Node.SIGNAL); &#125; return false;&#125;// 挂起当前线程并且返回当前线程的中断状态private final boolean parkAndCheckInterrupt() &#123; LockSupport.park(this); return Thread.interrupted();&#125; release方法在ReentrantLock的unlock方法中，会直接调用此方法。该方法也是一个模板方法，① 首先会去调用tryRelease(arg)方法，此方法在AQS中是一个空方法，具体逻辑由子类来实现。 ② 若是 ① 调用后返回值为true，执行unparkSuccessor(Node node)方法。unparkSuccessor(Node node)方法会去唤醒node节点的下一个节点。③ 若是 ① 调用后返回值为false，直接返回false。 // 首先执行子类的tryRelease方法，根据其返回值执行具体的操作public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) &#123; unparkSuccessor(h); &#125; return true; &#125; return false;&#125;// 抽象方法，由具体的子类来实现protected boolean tryRelease(int arg) &#123; throw new UnsupportedOperationException();&#125;// 若是node节点存在后继节点，则将其唤醒private void unparkSuccessor(Node node) &#123; int ws = node.waitStatus; if (ws &lt; 0) &#123; compareAndSetWaitStatus(node, ws, 0); &#125; Node s = node.next; // 当node节点的next节点为null或者其已经被取消时，从尾节点向前遍历,找到一个节点 if (s == null || s.waitStatus &gt; 0) &#123; s = null; for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) &#123; if (t.waitStatus &lt;= 0) &#123; s = t; &#125; &#125; &#125; // 找到了一个不为null的节点，将其唤醒 if (s != null) &#123; LockSupport.unpark(s.thread); &#125; &#125; Condition与ConditionObject在AQS内部定义了一个类ConditionObject，该类实现了Condition接口。类直接的定义关系如下： public abstract class AbstractQueuedSynchronizer&#123; ... public class ConditionObject implements Condition &#123; // 条件队列头节点 private transient Node firstWaiter; // 条件队列尾节点 private transient Node lastWaiter; &#125; ...&#125; await方法该方法是将当前线程添加到条件队列上。执行逻辑：① 若是当前线程已经被打断，直接抛出异常。 ② 调用addConditionWaiter方法，将当前的线程封装成为一个 Node 节点，添加到等待队列的尾部，并返回该节点。③ 调用fullyRelease方法释放当前线程获取到的锁。④ while循环，调用 isOnSyncQueue 方法判断节点是否在同步队列，没在同步队列执行 while 循环体，挂起当前线程。 public final void await() throws InterruptedException &#123; // 判断中断，抛出异常 if (Thread.interrupted()) &#123; throw new InterruptedException(); &#125; // 添加到等待队列 Node node = addConditionWaiter(); // 释放该线程获取的锁 int savedState = fullyRelease(node); int interruptMode = 0; while (!isOnSyncQueue(node)) &#123; LockSupport.park(this); if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; &#125; if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) interruptMode = REINTERRUPT; if (node.nextWaiter != null) // clean up if cancelled unlinkCancelledWaiters(); if (interruptMode != 0) reportInterruptAfterWait(interruptMode);&#125;// 添加一个新的节点到等待队列。// 1. 清除被取消的节点// 2. 将当前线程封装成Node节点，添加到等待队列private Node addConditionWaiter() &#123; Node t = lastWaiter; if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) &#123; unlinkCancelledWaiters(); t = lastWaiter; &#125; Node node = new Node(Thread.currentThread(), Node.CONDITION); if (t == null) firstWaiter = node; else t.nextWaiter = node; lastWaiter = node; return node;&#125;// 释放当前线程获取到的锁// 1. 获取到锁状态 state 的值// 2. 调用 release 方法释放锁// 3. 释放成功，返回state 之前的值。// 4. 释放失败，抛出异常。// 5. 若是释放失败，将当前线程节点的 waitStatus 状态值设置为 Node.CANCELLED（取消）final int fullyRelease(Node node) &#123; boolean failed = true; try &#123; int savedState = getState(); if (release(savedState)) &#123; failed = false; return savedState; &#125; else &#123; throw new IllegalMonitorStateException(); &#125; &#125; finally &#123; if (failed) &#123; node.waitStatus = Node.CANCELLED; &#125; &#125;&#125;// 判定给定的节点是否在同步队列上final boolean isOnSyncQueue(Node node) &#123; if (node.waitStatus == Node.CONDITION || node.prev == null) &#123; return false; &#125; if (node.next != null) &#123; return true; &#125; return findNodeFromTail(node);&#125; signal方法① 调用isHeldExclusively方法，返回false，直接抛出异常，否则执行下一步。② 获取到等待队列的第一个节点，将其做为参数，调用doSignal方法。③ doSignal方法会将给定的节点从等待队列放到同步队列的尾部。 public final void signal() &#123; if (!isHeldExclusively()) throw new IllegalMonitorStateException(); Node first = firstWaiter; if (first != null) &#123; doSignal(first); &#125; &#125;// 判断获取到锁的线程是否为当前线程protected boolean isHeldExclusively() &#123; throw new UnsupportedOperationException();&#125;// ReentrantLock的Sync的内部实现protected final boolean isHeldExclusively() &#123; return getExclusiveOwnerThread() == Thread.currentThread();&#125;// 将 first 节点从等待队列移动到同步队列// 1. 将first节点从等待队列中去除// 2. 调用 transferForSignal 方法将 first节点放到同步队列// 3. 若是上一步失败，尝试下一个节点private void doSignal(Node first) &#123; do &#123; if ( (firstWaiter = first.nextWaiter) == null) &#123; lastWaiter = null; &#125; first.nextWaiter = null; &#125; while (!transferForSignal(first) &amp;&amp; (first = firstWaiter) != null);&#125;// 将 node 节点添加到同步队列的尾部// 1. cas操作将 node 节点的 waitStatus 状态值由 Node.CONDITION修改为0,修改失败返回false。// 2. 将node节点添加到同步队列的尾部// 3. 若是node节点的waitStatus状态值大于0,或者将node节点的状态值设置为SIGNAL失败，唤醒该节点线程。// 4. 返回 true。final boolean transferForSignal(Node node) &#123; if (!compareAndSetWaitStatus(node, Node.CONDITION, 0)) &#123; return false; &#125; Node p = enq(node); int ws = p.waitStatus; if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)) LockSupport.unpark(node.thread); return true;&#125; signalAll方法具体逻辑：大体和signal方法相同，但其会执行doSignalAll(first)方法而不是doSignal(first)方法。 public final void signalAll() &#123; if (!isHeldExclusively()) throw new IllegalMonitorStateException(); Node first = firstWaiter; if (first != null) doSignalAll(first);&#125;// 1. 清除等待队列 lastWaiter = firstWaiter = null;// 2. 从 first节点开始，依次调用 transferForSignal方法，直到节点为null。private void doSignalAll(Node first) &#123; lastWaiter = firstWaiter = null; do &#123; Node next = first.nextWaiter; first.nextWaiter = null; transferForSignal(first); first = next; &#125; while (first != null);&#125;","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"源码","slug":"java/源码","permalink":"https://zhilongao.github.io/categories/java/源码/"}]},{"title":"lambda和stream","date":"2019-09-23T11:11:56.000Z","path":"wiki/java-style-lambda/","text":"参考文章1 参考文章2 功能性接口的简化 lambda表达式可以简化Runnable，Comparator这种接口的写法。 /*****lambda表达式简化线程的创建*****/// 普通写法Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; // do something &#125;&#125;);// lambda写法Thread t2 = new Thread(()-&gt;&#123; // do something &#125;);/*****lambda表达式简化 Collections.sort 排序*****/// 普通写法Collections.sort(list, new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; return o1 - o2; &#125;&#125;);// lambda写法Collections.sort(list, (x, y) -&gt; x - y);/*****自定义功能接口*****/List&lt;String&gt; params = Arrays.asList(new String[]&#123;\"app\", \"red\", \"blue\"&#125;);// 映射List中元素的length集合List&lt;Integer&gt; res1 = new CollectionUtils&lt;String, Integer&gt;().map(params, (String param) -&gt; param.length());// 映射list中以元素的大写集合List&lt;String&gt; res2 = new CollectionUtils&lt;String, String&gt;().map(params, (String param) -&gt; param.toUpperCase());// 定义函数式接口@FunctionalInterfaceinterface MyOP&lt;P, R&gt; &#123; R apply(P obj);&#125;// 集合操作类class CollectionUtils&lt;P, R&gt; &#123; // 对集合中的元素进行操作，操作完成之后返回一个新的集合 public List&lt;R&gt; map(List&lt;P&gt; input, MyOP&lt;P, R&gt; myOp) &#123; List&lt;R&gt; result = new ArrayList(); for (P obj : input) &#123; result.add(myOp.apply(obj)); &#125; return result; &#125;&#125; 方法和构造方法的引用 // lambda表达式的一般写法params.forEach((v) -&gt; System.out.print(v + \"\\t\"));// lambda的简化写法params.forEach(System.out::print);// lambda构造方法的简写 Date::newList&lt;Long&gt; dateValues = Arrays.asList(new Long[] &#123;0L, 1000L&#125;);List&lt;Date&gt; map = new CollectionUtils&lt;Long, Date&gt;().map(dateValues, Date::new); 接口的默认方法 1. 解决了接口的演化问题（接口中新增默认实现方法，不影响原先的实现类）2. 实现了行为的多继承 （一个类可以实现多个接口的默认方法） stream Stream原理：流式操作，由 jdk 内部分配多个线程来执行 stream 内部的操作。并发流使用的默认线程数等于你机器的处理器核心数。 Stream场景：由于 Stream 是由 jdk 内部来为任务分配线程，所以在 一些耗时操作慎用 Stream。 Stream应用：Stream.of()方法，可以接收单个参数，也可以接收一个数组参数，将其转换为一个Stream对象。下面是几个Stream的简单应用demo。 （1）实例代码(forEach方法遍历)-&gt;接收一个参数, 通过forEach方法接收一个功能接口。 List&lt;Integer&gt; list = new ArrayList&lt;&gt;();list.add(1);list.add(2);list.add(3);Stream.of(list).forEach(System.out::println);// 输出结果// [1, 2, 3] （2）实例代码(forEach方法遍历)-&gt;接收一个数组，通过forEach方法接收一个功能接口。 Stream.of(list.toArray()).forEach(System.out::println);// 输出结果// 1// 2// 3 （3）实例代码(filter方法过滤)-&gt; 找处以小写字母’a’开头的字符串 Stream.of(\"Abc\", \"abc\", \"ccc\", \"asD\") .filter((str) -&gt; &#123;return str.startsWith(\"a\");&#125;) .forEach(System.out::println);// 输出结果// abc// asD （4）实例方法-&gt;(map方法建立映射)-&gt; 统计给出数组中每个字符串的长度 Stream.of(\"A\", \"abc\", \"cc\", \"a\") .map((str) -&gt; str.length()) .forEach(System.out::println);// 输出结果// 1// 3// 2// 1 （5）实例方法-&gt;(reduce方法的使用) -&gt; 初始值为 100，计算初始值加1到5的值 List&lt;Integer&gt; integerList = Arrays.asList(1, 2, 3, 4, 5);int init = 100;Integer result = integerList.stream() .reduce(init, (a, b) -&gt; a + b);System.out.println(\"result-&gt;\" + result);// 输出结果// 115","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"新特性","slug":"java/新特性","permalink":"https://zhilongao.github.io/categories/java/新特性/"}]},{"title":"负载均衡","date":"2019-09-21T01:31:06.000Z","path":"wiki/fra-spring-cloud-loadbalance/","text":"完善中。。。。 负载均衡算法基础(理论)参考资料 负载均衡分类：客户端负载均衡 服务端负载均衡 负载均衡算法 ​ 随机 轮询 ​ 权重 Ribbon的实现(设计)设计分析 // 核心接口com.netflix.loadbalancer.IRulecom.netflix.loadbalancer.ILoadBalancer// 服务实例定义实体Netflix Eureka com.netflix.appinfo.InstanceInfoSpring Cloud Commonsorg.springframework.cloud.client.ServiceInstanceNetflix Ribboncom.netflix.loadbalancer.Server","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"框架","slug":"java/框架","permalink":"https://zhilongao.github.io/categories/java/框架/"},{"name":"spring-cloud","slug":"java/框架/spring-cloud","permalink":"https://zhilongao.github.io/categories/java/框架/spring-cloud/"}]},{"title":"ReentrantLock","date":"2019-09-18T12:31:57.000Z","path":"wiki/ans-reentlock-source/","text":"类关系与锁初始化在ReentrantLock类内部有一个属性，Sync:sync，该属性对应的类是定义在ReentrantLock内部的一个静态类（抽象类）。ReentrantLock内部又为Sync定义了两个子类NonfairSync和FairSync。根据类名便可看到非公平与公平之分。我们通过api使用ReentrantLock类时，会调用其构造函数创建一个该类型的对象，构造函数可传参数true|false，确定创建公平或非公平锁。若没传递参数，会默认创建非公平锁。 // 几个类定义关系图public class ReentrantLock&#123; ... private final Sync sync; abstract static class Sync extends AbstractQueuedSynchronizer &#123; &#125; static final class NonfairSync extends Sync &#123; ... &#125; static final class FairSync extends Sync &#123; ... &#125;&#125;public abstract class AbstractQueuedSynchronizer&#123; ...&#125;// 默认创建非公平锁public ReentrantLock() &#123; sync = new NonfairSync();&#125;// 参数为 true 创建公平锁，false 创建非公平锁public ReentrantLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync();&#125; 方法调用关系调用ReentrantLock:lock方法或是ReentrantLock:unlock方法时，ReentrantLock会委托Sync来执行具体的上锁或者是释放锁的逻辑。① 关于lock，在Sync内部定义了一个抽象方法Sync:lock，在其子类FairSync和NonfairSync均实现了这个方法。这两个实现类的lock方法最终又会调用Sync的父类AQS的acquire方法。② 关于unlock，实际上调用的是Sync的父类AQS的release方法。 /*****ReentrantLock*****/// 上锁，调用sync的lock方法public void lock() &#123; sync.lock();&#125;// 解锁，调用sync的父类aqs的release方法public void unlock() &#123; sync.release(1);&#125;/*****Sync*****/// 上锁-&gt; 抽象方法，具体逻辑由子类FairSync或NonfairSync来实现abstract void lock();// 解锁-&gt; Sync的父类AbstractQueuedSynchronizer定义的方法public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false;&#125;// FairSync类实现的lock方法final void lock() &#123; acquire(1);&#125;// NonfairSync类实现的lock方法final void lock() &#123; if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1);&#125; lock之公平与非公平① NonfairSync:lock方法在执行时，首先会通过CAS操作直接修改锁状态state的值，若是执行成功，则成功获取到锁，若是执行失败，调用AbstractQueuedSynchronizer:acquire(1)方法来执行普通的上锁逻辑。FairSync:lock方法在执行时，直接调用 AbstractQueuedSynchronizer:acquire(1)方法来执行普通的上锁逻辑。（非公平锁直接忽略了排队等待获取锁的线程） /*****NonfairSync*****/final void lock() &#123; if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1);&#125;/*****FairSync*****/final void lock() &#123; acquire(1);&#125; ② 在上面的分析中，非公平锁的实现类在尝试设置锁失败时，直接调用AQS的acquire方法，而公平锁的实现类直接调用AQS的acquire方法。AQS:acquire方法属于一个模板方法，内部定义了获取锁的操作步骤。其中tryAcquire方法是其第一个调用的方法，也是一个没有实现的空方法，具体的实现逻辑由其子类来实现。 NonfairSync:tryAcquire方法内部会调用其父类的Sync:nonfairTryAcquire方法，该方法语义为非公平尝试获取。具体逻辑：首先判断锁的状态，若是没有线程获取到锁，执行通过CAS操作修改锁状态，若是成功返回true。若是未成功，继续判断获取锁的线程是否为当前线程，若是当前线程，将锁状态值加上方法传入的值，并将锁状态值更新（可重入），返回true，否则返回false。 FairSync:tryAcquire方法的执行逻辑：判断是 否有线程获取到锁，若是没有线程获取到锁，继续判断是否有线程等待获取锁，若是无线程等待获取锁，CAS操作获取锁，成功返回true。操作获取锁失败，或者有线程等待获取锁，或者已有线程获取到锁，继续判断当前获取到锁的线程是否为当前线程，是则执行可重入锁操作并返回true，否则返回false。 /*****AbstractQueuedSynchronizer *****/// AQS中定义的获取锁的模板方法public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125;// 一个未实现的方法，具体逻辑由子类来实现protected boolean tryAcquire(int arg) &#123; throw new UnsupportedOperationException();&#125;/*****NonfairSync*****/protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires);&#125;/*****Sync*****/final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error(\"Maximum lock count exceeded\"); setState(nextc); return true; &#125; return false;&#125;/*****FairSync*****/protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error(\"Maximum lock count exceeded\"); setState(nextc); return true; &#125; return false;&#125; unlock执行逻辑调用ReentrantLock:unlock方法时，Sync会调用父类的AbstractQueuedSynchronizer：release方法。 具体逻辑是：① 首先tryRelease方法会被调用，而这个方法在AQS中是一个没有具体实现的空方法，具体逻辑由子类Sync来实现。② 子类中首先会去判断当前线程是否就是获取到锁的线程，若不是直接抛出异常，否则执行下一步的逻辑。③ 获取到锁状态state的值，并用state值减去方法传的参数值（释放多少次），计算出一个结果。④ 若是计算出来的这个结果为0，将state的值设置为0，并将获取锁的线程设置为null，并返回true。⑤ 若是计算出来的这个结果不为0，将state的值设置为计算得到的值，返回false。 子类执行完tryRelease方法后，会返回一个值。① 若是该值为true，AQS:release方法会执行其它逻辑，执行完返回true。② 若是该值为false，AQS:release方法直接返回false。 /*****ReentrantLock *****/public void unlock() &#123; sync.release(1);&#125; /*****AbstractQueuedSynchronizer *****/public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false;&#125;protected boolean tryRelease(int arg) &#123; throw new UnsupportedOperationException();&#125;/*****Sync*****/protected final boolean tryRelease(int releases) &#123; int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) &#123; free = true; setExclusiveOwnerThread(null); &#125; setState(c); return free;&#125; LockSupport与Unsafe 在LockSupport中提供了两个方法，park与unpark方法，而这两个方法实际上又是调用的Unsafe类中的native方法。park是将当前调用线程阻塞，而unpark方法则是唤醒指定的线程。 public class LockSupport &#123; // jdk内部用于操作内存地址的类 private static final sun.misc.Unsafe UNSAFE; static &#123; try &#123; ... UNSAFE = sun.misc.Unsafe.getUnsafe(); ... &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125; // 调用 Unsafe 类的park方法将当前线程阻塞 public static void park(Object blocker) &#123; Thread t = Thread.currentThread(); setBlocker(t, blocker); UNSAFE.park(false, 0L); setBlocker(t, null); &#125; // 调用 Unsafe 类的unpark方法唤醒指定的线程 public static void unpark(Thread thread) &#123; if (thread != null) &#123; UNSAFE.unpark(thread); &#125; &#125;&#125; // jdk核心类库可操作的apipublic final class Unsafe &#123; private static final Unsafe theUnsafe; static &#123; ... theUnsafe = new Unsafe(); ... &#125; private Unsafe() &#123;&#125; // 该类中的 theUnsafe 属性为该类的一个实例，对外只提供给jdk核心类库使用。我们在平常的开发中无法通过该方法来获取 theUnsafe 对象。（可以通过万能的反射方式获取） @CallerSensitive public static Unsafe getUnsafe() &#123; Class var0 = Reflection.getCallerClass(); if (!VM.isSystemDomainLoader(var0.getClassLoader())) &#123; throw new SecurityException(\"Unsafe\"); &#125; else &#123; return theUnsafe; &#125; &#125; // native方法，阻塞当前线程 public native void park(boolean var1, long var2); // native方法，唤醒指定的线程 public native void unpark(Object var1);&#125; 关于可重入锁的Condition分析—-&gt; 等待队列 // ReentrantLockpublic Condition newCondition() &#123; return sync.newCondition();&#125;// Syncfinal ConditionObject newCondition() &#123; return new ConditionObject();&#125;// AQS-&gt;ConditionObjectpublic class ConditionObject implements Condition, java.io.Serializable &#123; private static final long serialVersionUID = 1173984872572414699L; private transient Node firstWaiter; private transient Node lastWaiter; public ConditionObject() &#123; &#125; // 添加一个等待的线程 // 若是最后一个节点不为null，并且其 waitStatus 状态值不为 CONDITION。 private Node addConditionWaiter() &#123; Node t = lastWaiter; // 添加之前先清理一番 if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) &#123; unlinkCancelledWaiters(); t = lastWaiter; &#125; // 创建一个节点， 将其加入到同步队列的尾部 Node node = new Node(Thread.currentThread(), Node.CONDITION); if (t == null) &#123; firstWaiter = node; &#125; else &#123; t.nextWaiter = node; &#125; lastWaiter = node; return node; &#125; // 这个方法的目的就一个: 从等待队列中清除 waitStatus 状态值不为 CONDITION 的节点 private void unlinkCancelledWaiters() &#123; Node t = firstWaiter; Node trail = null; // 在节点 t 不为 null 的情况下，不断的执行循环操作 while (t != null) &#123; // 首先保存下一个节点，然后判断当前节点 Node next = t.nextWaiter; // 若是节点的 waitStatus 状态值不为 CONDITION，将节点 t 的 nextWaiter指向为null if (t.waitStatus != Node.CONDITION) &#123; t.nextWaiter = null; // 这种情况是: 第一个节点的 waitStatus状态值已经不为 CONDITION 了，可能 next节点为等待节点，故先将 firstWaiter指向 next。若是当前的 trail不为null, 则 trail的nextWaiter也应该指向 next if (trail == null) &#123; firstWaiter = next; &#125; else &#123; trail.nextWaiter = next; &#125; // 这种情况是: 遍历到了最后一个节点，并且其 waitStatus 状态值不为 CONDITION，故需要在跳出循环之前将lastWaiter节点更新为 trail节点。 if (next == null) &#123; lastWaiter = trail; &#125; // 若是节点的 waitStatus 状态值为 CONDITION &#125; else &#123; trail = t; &#125; // 下一次循环遍历的节点 t = next; &#125; &#125; /****************************************************/ final int fullyRelease(Node node) &#123; boolean failed = true; try &#123; // 获取锁状态标识(0: 未上锁 &gt;=1 上锁) int savedState = getState(); // 释放成功，返回释放前 state 的值 if (release(savedState)) &#123; failed = false; return savedState; // 否则直接抛出异常 &#125; else &#123; throw new IllegalMonitorStateException(); &#125; &#125; finally &#123; // 若是操作失败，将当前节点的waitStatus状态值设置未CANCELLED if (failed) &#123; node.waitStatus = Node.CANCELLED; &#125; &#125; &#125; // 缩放锁-&gt;在调用await方法时，释放掉当前线程所持有的锁 public final boolean release(int arg) &#123; // tryRelease时 ReentrantLock的内部类Sync的方法，成功释放锁返回true，否则返回 false。 if (tryRelease(arg)) &#123; Node h = head; // 当前线程已经进入到await状态，唤醒啦一个线程来获取锁 if (h != null &amp;&amp; h.waitStatus != 0) &#123; unparkSuccessor(h); &#125; return true; &#125; // 其它情况返回 false return false; &#125; // 节点添加到同步队列和条件队列的区别(两点区别判断给定节点当前所处位置) // 同步队列: 双向列表，节点有 prev 和 next 指针指向前驱节点和后继节点。nextWaiter 状态值为 null。 // 条件队列: 单向列表，节点有 nextWaiter 指针指向后继节点。waitStatus 状态值为 Node.CONDITION // 若是节点已经在同步队列上，则返回 true final boolean isOnSyncQueue(Node node) &#123; // 若是 waitStatus 为 Node.CONDITION，证明在条件队列，返回 false。 // 若不是在条件队列，但是节点的 prev 为 null，也返回 false。 if (node.waitStatus == Node.CONDITION || node.prev == null) &#123; return false; &#125; // 若是节点的 next 指针不指向 null，直接返回 true if (node.next != null) &#123; return true; &#125; // 从同步队列的尾部找 return findNodeFromTail(node); &#125; // 1. 若是在同步队列中找到了，返回 true。 // 2. 若是在同步队列中没有找到，返回 false。 private boolean findNodeFromTail(Node node) &#123; Node t = tail; for (;;) &#123; // 若是找到的化，直接返回 true if (t == node) &#123; return true; &#125; // 已经找了一遍，但还是没有找到，返回 false if (t == null) &#123; return false; &#125; // 获取前一个节点判断 t = t.prev; &#125; &#125; // private int checkInterruptWhileWaiting(Node node) &#123; return Thread.interrupted() ? (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) : 0; &#125; // 关于await方法 // 1. 若是当前线程已经被中断，直接抛出异常，结束方法的运行。 // 2. 调用 addConditionWaiter 方法， 将当前的线程封装成为一个 Node 节点，添加到等待队列的尾部。 // 3. 调用 fullyRelease 方法，释放当前线程所获取到的锁。 // 4. while循环，调用 isOnSyncQueue 方法判断节点是否在同步队列，没在同步队列执行 while 循环体。挂起当前线程。 // public final void await() throws InterruptedException &#123; if (Thread.interrupted()) &#123; throw new InterruptedException(); &#125; // 加入到等待队列 Node node = addConditionWaiter(); // 释放锁 int savedState = fullyRelease(node); int interruptMode = 0; // 线程没在同步队列。 while (!isOnSyncQueue(node)) &#123; // 挂起当前线程 LockSupport.park(this); // 当前线程被唤醒时，执行。检查线程是否被打断，若是已经被打断，结束执行。 if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) &#123; break; &#125; &#125; if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) &#123; interruptMode = REINTERRUPT; &#125; if (node.nextWaiter != null) &#123; unlinkCancelledWaiters(); &#125; if (interruptMode != 0) &#123; reportInterruptAfterWait(interruptMode); &#125; &#125; // final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; // 获取节点的前驱节点 final Node p = node.predecessor(); // 前驱节点为 head，尝试获取锁，并获取成功 if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; // 获取锁失败执行 park 操作。 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) &#123; interrupted = true; &#125; &#125; &#125; finally &#123; if (failed) &#123; cancelAcquire(node); &#125; &#125; &#125; // signal 方法分析 public final void signal() &#123; // 拥有锁的线程非当前线程，直接抛出异常 if (!isHeldExclusively()) &#123; throw new IllegalMonitorStateException(); &#125; // 获取到条件队列的第一个节点，对其执行 doSignal 操作。 Node first = firstWaiter; if (first != null) &#123; doSignal(first); &#125; &#125; // signalAll 方法分析 public final void signalAll() &#123; // 同 signal if (!isHeldExclusively()) &#123; throw new IllegalMonitorStateException(); &#125; // 获取都条件队列的第一个节点，对其执行 doSignall 操作 Node first = firstWaiter; if (first != null) &#123; doSignalAll(first); &#125; &#125; // 操作是将给定的节点从条件队列转移至同步队列。若是操作失败，会去尝试给定节点的下一个节点，直到条件队列中已经没有节点了。 private void doSignal(Node first) &#123; do &#123; // 总会执行的操作: firstWaiter 指向 first 节点的 nextWaiter 节点。 if ( (firstWaiter = first.nextWaiter) == null) &#123; // 若是 firstWaiter 为 null 了，则 lastWaiter 也将指向 null。 lastWaiter = null; &#125; // 下面的操作是将 first 节点添加到 同步队列，故将其 nextWaiter 属性值指向为 null。 first.nextWaiter = null; // 若是将 first 节点从条件队列转移至同步队列失败并且 firstWaiter 不为 null。 &#125; while (!transferForSignal(first) &amp;&amp; (first = firstWaiter) != null); &#125; // Node 节点 waitStatus 属性的几个状态值。 // static final int CANCELLED = 1; 表示节点已经被取消 // static final int SIGNAL = -1; 表示后面节点的线程需要被唤醒。 // static final int CONDITION = -2; 表示节点在条件队列上 // static final int PROPAGATE = -3; 关于共享锁的状态 // 0; 非以上值，取0 // Node 节点 nextWaiter 属性的几个状态值 // static final Node SHARED = new Node(); 标记节点在共享模式下等待 // static final Node EXCLUSIVE = null; 标记节点在排他模式下等待 // 操作: 将节点从条件队列转移至同步队列，操作成功返回 true。 final boolean transferForSignal(Node node) &#123; // case 操作尝试，失败返回 false。 if (!compareAndSetWaitStatus(node, Node.CONDITION, 0)) &#123; return false; &#125; // 将该节点添加到同步队列的尾部，并返回该节点的前一个节点 Node p = enq(node); // 获取返回节点的 waitStatus 状态值 int ws = p.waitStatus; // ws 节点被取消 // ws 未被取消，尝试将其waitStatus状态值从 ws 设置为 SIGNAL失败 if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)) &#123; // 唤醒该节点的线程 LockSupport.unpark(node.thread); &#125; // 返回 true。 return true; &#125; // 将节点插入到队列，必要时初始化。 返回值为 node 节点的前一个节点 private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail; // 同步队列为 null，初始化 head 和 tail。 if (t == null) &#123; if (compareAndSetHead(new Node())) &#123; tail = head; &#125; &#125; else &#123; node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125; &#125; // doSignalAll, 唤醒条件队列上的所有线程 private void doSignalAll(Node first) &#123; // 清除条件队列 lastWaiter = firstWaiter = null; // 循环操作，从第一个节点开始，将条件队列上的所有节点添加到同步队列 do &#123; // 保存下一个节点 Node next = first.nextWaiter; // 清除 first 节点的 nextWaiter属性 first.nextWaiter = null; // 将 first 节点转移至同不队列 transferForSignal(first); // 更新 first 节点 first = next; &#125; while (first != null); &#125;&#125;","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"源码","slug":"java/源码","permalink":"https://zhilongao.github.io/categories/java/源码/"}]},{"title":"监听器模式","date":"2019-09-13T02:58:12.000Z","path":"wiki/design-pattern-listener/","text":"监听器模式针对监听器模式，jdk提供了EventListener接口和EventObject类，分别定义事件监听器和事件对象。下面是通过扩展这两个接口实现一个简单的事件监听器模式。 /** * @Author long * @Date 2019/9/13 11:03 */public class App &#123; public static void main(String[] args) &#123; // 事件源 MyEventSource eventSource = new MyEventSource(); // 创建事件监听器-&gt;处理EventObject StartEventListener startEventListener = new StartEventListener(); ClosedEventListener closedEventListener = new ClosedEventListener(); // 添加事件监听器 eventSource.addEventListener(startEventListener); eventSource.addEventListener(closedEventListener); // 创建事件对象 EventObject startEventObject = new EventObject(\"start\"); EventObject closedEventObject = new EventObject(\"closed\"); // 事件源-&gt;通知事件监听者来处理 eventSource.notifyListenerEvents(startEventObject); eventSource.notifyListenerEvents(closedEventObject); &#125;&#125;/** * @Author long * @Date 2019/9/13 11:00 * 扩展的监听器接口 */public interface MyEventListener extends EventListener &#123; /** * 处理EventObject * @param event */ void handleEvent(EventObject event);&#125;/** * @Author long * @Date 2019/9/13 11:21 * 启动事件监听器 */public class StartEventListener implements MyEventListener &#123; @Override public void handleEvent(EventObject event) &#123; Object source = event.getSource(); if (source.equals(\"start\")) &#123; System.out.println(\"context has start!\"); &#125; &#125;&#125;/** * @Author long * @Date 2019/9/13 11:24 * 关闭事件监听器 */public class ClosedEventListener implements MyEventListener &#123; @Override public void handleEvent(EventObject event) &#123; Object source = event.getSource(); if (source.equals(\"closed\")) &#123; System.out.println(\"context has closed!\"); &#125; &#125;&#125;/** * @Author long * @Date 2019/9/13 11:03 * 事件源-&gt;添加 删除 通知 */public class MyEventSource &#123; /** * 监听器列表 */ private Vector&lt;EventListener&gt; listeners = new Vector&lt;&gt;(); /** * 注册监听器 * @param eventListener */ public void addEventListener(EventListener eventListener) &#123; if (!listeners.contains(eventListener)) &#123; listeners.add(eventListener); &#125; &#125; /** * 移除监听器 * @param eventListener */ public void removeEventListener(EventListener eventListener) &#123; listeners.remove(eventListener); &#125; /** * 接收外部的事件-&gt;将事件交给事件监听者来处理 * @param event */ public void notifyListenerEvents(EventObject event) &#123; for (EventListener eventListener : listeners) &#123; ((MyEventListener)eventListener).handleEvent(event); &#125; &#125;&#125; jdk中监听器模式的实现jdk针对监听器模式并未定义太多的实现，只是定义了一个EventListener接口和一个EventObject类，我们可以扩展EventListener接口来定义处理EventObject的方法。在EventObject中有一个属性Object:source，该属性可以在定义EventObject的时候，传入一些参数值。 public interface EventListener &#123; &#125;public class EventObject implements java.io.Serializable &#123; protected transient Object source; public EventObject(Object source) &#123; if (source == null) throw new IllegalArgumentException(\"null source\"); this.source = source; &#125; public Object getSource() &#123; return source; &#125; public String toString() &#123; return getClass().getName() + \"[source=\" + source + \"]\"; &#125;&#125; spring中监听器模式的实现在spring中定义了ApplicationListener接口和ApplicationEvent类，其中ApplicationListener接口实现了jdk中定义的EventListener接口，并定义了onApplicationEvent方法来处理事件，并且每个ApplicationListener只会处理特定的事件。ApplicationEvent类继承了jdk中定义的EventObject类，用以定义事件对象。 // 扩展的事件监听器接口-&gt;采用泛型public interface ApplicationListener&lt;E extends ApplicationEvent&gt; extends EventListener &#123; void onApplicationEvent(E event);&#125;// 扩展的EventObjectpublic abstract class ApplicationEvent extends EventObject &#123; private static final long serialVersionUID = 7099057708183571937L; private final long timestamp; public ApplicationEvent(Object source) &#123; super(source); this.timestamp = System.currentTimeMillis(); &#125; public final long getTimestamp() &#123; return this.timestamp; &#125;&#125; spring中监听器模式的使用/** * @Author long * @Date 2019/9/13 11:46 */public class App &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(); // 注册监听器 context.addApplicationListener(new ApplicationListener&lt;MyApplicationEvent&gt;() &#123; // 接收到事件 @Override public void onApplicationEvent(MyApplicationEvent event) &#123; System.out.println(event.getSource()); &#125; &#125;); context.refresh(); // 发布事件 context.publishEvent(new MyApplicationEvent(\"study spring！\")); &#125;&#125;class MyApplicationEvent extends ApplicationEvent&#123; MyApplicationEvent(Object source) &#123; super(source); &#125;&#125;","tags":[],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://zhilongao.github.io/categories/设计模式/"}]},{"title":"观察者模式","date":"2019-09-13T01:54:53.000Z","path":"wiki/design-pattern-observer/","text":"观察者模式可以通过jdk中提供的Observable类和Observer接口来实现观察者模式。下面通过简单的会员订阅频道，然后频道定期的去给订阅的会员推送消息，展示jdk中观察者模式的使用。 /** * @Author long * @Date 2019/9/13 9:16 */public class App &#123; public static void main(String[] args) &#123; // 科技频道 TechnologyChannel technologyChannel = new TechnologyChannel(); technologyChannel.setTitle(\"科技频道\"); // 用户 Members member1 = new Members(); Members member2 = new Members(); // 用户订阅该科技频道 technologyChannel.addObserver(member1); technologyChannel.addObserver(member2); // 给会员定时推送消息 String[] messages = &#123;\"华为\", \"小米\", \"苹果\"&#125;; Random random = new Random(); for (int i = 0; i &lt; 10 ; i++) &#123; // 创建消息 NotifyMessage message = new NotifyMessage(); String id = UUID.randomUUID().toString(); message.setId(id); message.setCreateTime(System.currentTimeMillis()); message.setTitle(\"手机\"); message.setContent(messages[random.nextInt(3)] + \"又出新机，赶快来订购吧!\"); // 评到发送消息给订阅的会员 technologyChannel.setChanged(); technologyChannel.notifyObservers(message); try &#123; TimeUnit.MILLISECONDS.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;/** * @Author long * @Date 2019/9/13 9:14 * 频道 */@Datapublic class TechnologyChannel extends Observable &#123; private String title; public synchronized void setChanged() &#123; super.setChanged(); &#125;&#125;/** * @Author long * @Date 2019/9/13 9:13 * 会员 */public class Members implements Observer &#123; @Override public void update(Observable o, Object arg) &#123; if (o instanceof TechnologyChannel) &#123; TechnologyChannel channel = (TechnologyChannel)o; String title = channel.getTitle(); NotifyMessage message = (NotifyMessage)arg; System.out.println(\"channel:\" + title); System.out.println(\"message:\" + message); System.out.println(\"=======================\"); &#125; &#125;&#125;/** * @Author long * @Date 2019/9/13 9:28 * 消息通知 */@Data@NoArgsConstructor@AllArgsConstructorpublic class NotifyMessage implements Serializable &#123; private String id; private Long createTime; private String title; private String content;&#125; jdk中观察者模式的实现 观察者（类似订阅模式中的订阅者）。jdk中定义了一个公共的接口Observer，里面定义了一个update方法，该方法可以接收被观察者对象和一个参数对象。我们可以通过实现该接口，重写update方法来实现观察者的逻辑。 被观察者（类似订阅模式中的被订阅者）。jdk中定义了一个类Observable，可以实现添加，移除，通知观察者。该类里面有两个属性boolean:changed和Vector:obs。当我们执行addObserver方法来添加观察者时，若是该观察者还未被加入到Vector:obs中，会将观察者加入到该集合。当我们执行notifyObservers方法来通知观察者时，只有changed属性为true时，才会依次调用观察者的update方法。若是该值为true，在调用观察者的update方法之前，又会将该值设置为false。 public interface Observer &#123; void update(Observable o, Object arg);&#125;public class Observable &#123; private boolean changed = false; private Vector&lt;Observer&gt; obs; public Observable() &#123; obs = new Vector&lt;&gt;(); &#125; // 添加观察者 public synchronized void addObserver(Observer o) &#123; if (o == null) &#123; throw new NullPointerException(); &#125; if (!obs.contains(o)) &#123; obs.addElement(o); &#125; &#125; // 通知所有的观察者，可以传递一个参数 public void notifyObservers(Object arg) &#123; Object[] arrLocal; synchronized (this) &#123; // 若是状态未变化，不做任何事情 if (!changed) &#123; return; &#125; // 将Vector转化为一个数组 arrLocal = obs.toArray(); // 将changed设置为false clearChanged(); &#125; // 循环遍历Observer数组，调用其update方法 for (int i = arrLocal.length-1; i&gt;=0; i--) ((Observer)arrLocal[i]).update(this, arg); &#125;&#125;","tags":[],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://zhilongao.github.io/categories/设计模式/"}]},{"title":"分布式配置","date":"2019-09-12T03:55:17.000Z","path":"wiki/fra-spring-cloud-config/","text":"分布式配置 相关产品国内：Disconf(百度) Apollo(携程) Nacos(阿里)国外: Spring-Cloud-Config Netfix Archaius 客户端// 关于配置项的刷新-&gt;主动刷新(拉的模式)1. 客户端可以通过接口 http://127.0.0.1:8082/actuator/refresh 来主动刷新配置(post方法) ，但是该接口的调用需要修改配置文件里面的值。 management.endpoint.refresh.enabled=true2. 当配置项发生变化时，bean里面引用的配置项并未发生变化。需要使用 @RefreshScope 注解来标记，只有使用该注解标记的类，当配置项发生变化时，引用的配置项才会发生变化。@RestController@RefreshScope// (开关 阈值 文案等配置，其它配置可以重启服务器)public class EchoController &#123; @Value(\"$&#123;my.name&#125;\") private String myName = \"jack-1\"; @GetMapping(\"/myName\") public String getMyName() &#123; return myName; &#125;&#125;3. 可以配置定时器来每隔指定的时间去主动刷新配置@SpringBootApplication@EnableScheduling // 开启定时任务public class ConfigClientApp &#123; public static void main(String[] args) &#123; SpringApplication.run(ConfigClientApp.class, args); &#125; // 定时刷新配置 private final ContextRefresher contextRefresher; private final Environment environment; public ConfigClientApp(ContextRefresher contextRefresher, Environment environment) &#123; this.contextRefresher = contextRefresher; this.environment = environment; &#125; // 配置定时器每隔5秒刷新一次配置项 @Scheduled(fixedRate = 5 * 1000, initialDelay = 3 * 1000) public void autoRefresh() &#123; Set&lt;String&gt; updatedPropertyNames = contextRefresher.refresh(); updatedPropertyNames.forEach( propertyName -&gt; System.err.printf( \"[Thread :%s] 当前配置已更新，具体 Key：%s , Value : %s \\n\", Thread.currentThread().getName(), propertyName, environment.getProperty(propertyName) ) ); &#125;&#125; 服务端@EnableAutoConfiguration@Configuration@ComponentScan// 激活配置管理服务器@EnableConfigServerpublic class ConfigServerApp &#123; public static void main(String[] args) &#123; SpringApplication.run(ConfigServerApp.class, args); &#125; /** * 自定义配置实现,绕过git实现 * @return */ @Bean public EnvironmentRepository environmentRepository() &#123; return (String application, String profile, String label) -&gt; &#123; Environment environment = new Environment(\"default\", profile); List&lt;PropertySource&gt; propertySources = environment.getPropertySources(); Map&lt;String, Object&gt; source = new HashMap&lt;String, Object&gt;(); source.put(\"name\", \"微服务-&gt;long\"); PropertySource propertySource = new PropertySource(\"map\", source); propertySources.add(propertySource); return environment; &#125;; &#125;&#125; 客户端流程分析/*1. 在客户端，我们可以配置形如: localhost:8080/&#123;name&#125;/&#123;profiles&#125;/&#123;label&#125; 去从服务端获取配置。2. 在服务端是通过 EnvironmentController 类来对外提供服务的。*/@RestController@RequestMapping(method = RequestMethod.GET, path = \"$&#123;spring.cloud.config.server.prefix:&#125;\")public class EnvironmentController &#123; @RequestMapping(\"/&#123;name&#125;/&#123;profiles&#125;/&#123;label:.*&#125;\") public Environment labelled(@PathVariable String name, @PathVariable String profiles, @PathVariable String label) &#123; if (name != null &amp;&amp; name.contains(\"(_)\")) &#123; // \"(_)\" is uncommon in a git repo name, but \"/\" cannot be matched // by Spring MVC name = name.replace(\"(_)\", \"/\"); &#125; if (label != null &amp;&amp; label.contains(\"(_)\")) &#123; // \"(_)\" is uncommon in a git branch name, but \"/\" cannot be matched // by Spring MVC label = label.replace(\"(_)\", \"/\"); &#125; Environment environment = this.repository.findOne(name, profiles, label); if (!this.acceptEmpty &amp;&amp; (environment == null || environment.getPropertySources().isEmpty())) &#123; throw new EnvironmentNotFoundException(\"Profile Not found\"); &#125; return environment; &#125;&#125; 服务端流程分析/*1. 在 @EnableConfigServer 注解中使用了 @Import 注解导入了配置类 ConfigServerConfiguration。2. 在配置类 ConfigServerConfiguration 上面使用 @Configuration 注解表明该类是一个配置类，该配置类会在上下文中创建一个类型为 ConfigServerConfiguration.Marker 的bean。*/@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(ConfigServerConfiguration.class)public @interface EnableConfigServer &#123;&#125;@Configurationpublic class ConfigServerConfiguration &#123; @Bean public Marker enableConfigServerMarker() &#123; return new Marker(); &#125; class Marker &#123;&#125;&#125;/*1. ConfigServerAutoConfiguration 类上面使用了 @ConditionalOnBean 注解，只有当上下文中存在类型为 ConfigServerConfiguration.Marker 的bean时，才会执行该配置类的流程（条件装配）。2. 在该类中导入了一些配置类，EnvironmentRepositoryConfiguration 等这些类会根据条件判断创建相关的bean。*/@Configuration // 配置类@ConditionalOnBean(ConfigServerConfiguration.Marker.class) // 条件装配@EnableConfigurationProperties(ConfigServerProperties.class)@Import(&#123; EnvironmentRepositoryConfiguration.class, CompositeConfiguration.class, ResourceRepositoryConfiguration.class, ConfigServerEncryptionConfiguration.class, ConfigServerMvcConfiguration.class &#125;)public class ConfigServerAutoConfiguration &#123;&#125;/*1. EnvironmentRepositoryConfiguration 通过 @Import 注解导入了一些相关的配置类。JdbcRepositoryConfiguration GitRepositoryConfiguration 分别时基于jdbc和git实现配置的仓储。2. GitRepositoryConfiguration 继承啦 DefaultRepositoryConfiguration 类，属于默认实现。3. 在 DefaultRepositoryConfiguration 类中 通过 @ConditionalOnMissingBean 注解表明当前上下文中若是没有 EnvironmentRepository 类型的bean存在时，会创建一个类型为 MultipleJGitEnvironmentRepository 的bean*/// EnvironmentRepositoryConfiguration 配置@Configuration@EnableConfigurationProperties(&#123; SvnKitEnvironmentProperties.class, CredhubEnvironmentProperties.class, JdbcEnvironmentProperties.class, NativeEnvironmentProperties.class, VaultEnvironmentProperties.class &#125;)@Import(&#123; CompositeRepositoryConfiguration.class, JdbcRepositoryConfiguration.class, VaultConfiguration.class, VaultRepositoryConfiguration.class, CredhubConfiguration.class, CredhubRepositoryConfiguration.class, SvnRepositoryConfiguration.class, NativeRepositoryConfiguration.class, GitRepositoryConfiguration.class, DefaultRepositoryConfiguration.class &#125;)public class EnvironmentRepositoryConfiguration &#123; &#125;// GitRepositoryConfiguration git实现的配置，继承了 DefaultRepositoryConfiguration 默认实现@Configuration@Profile(\"git\")class GitRepositoryConfiguration extends DefaultRepositoryConfiguration &#123;&#125;// JdbcRepositoryConfiguration jdbc实现的配置@Configuration@Profile(\"jdbc\")@ConditionalOnClass(JdbcTemplate.class)class JdbcRepositoryConfiguration &#123; @Bean @ConditionalOnBean(JdbcTemplate.class) public JdbcEnvironmentRepository jdbcEnvironmentRepository( JdbcEnvironmentRepositoryFactory factory, JdbcEnvironmentProperties environmentProperties) &#123; return factory.build(environmentProperties); &#125;&#125;@Configuration@ConditionalOnMissingBean(value = EnvironmentRepository.class, search = SearchStrategy.CURRENT)class DefaultRepositoryConfiguration &#123; @Bean public MultipleJGitEnvironmentRepository defaultEnvironmentRepository( MultipleJGitEnvironmentRepositoryFactory gitEnvironmentRepositoryFactory, MultipleJGitEnvironmentProperties environmentProperties) throws Exception &#123; return gitEnvironmentRepositoryFactory.build(environmentProperties); &#125;&#125;/*到此，还有一个问题，那就是 ConfigServerAutoConfiguration 时如何加载的，通过相关jar包里面的spring.factories 文件可以看到 ConfigServerAutoConfiguration 被 EnableAutoConfiguration通过spring的spi加载。*/# Autoconfigurationorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.cloud.config.server.config.ConfigServerAutoConfiguration,\\org.springframework.cloud.config.server.config.EncryptionAutoConfiguration","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"框架","slug":"java/框架","permalink":"https://zhilongao.github.io/categories/java/框架/"},{"name":"spring-cloud","slug":"java/框架/spring-cloud","permalink":"https://zhilongao.github.io/categories/java/框架/spring-cloud/"}]},{"title":"questions","date":"2019-09-12T02:40:03.000Z","path":"wiki/questions/","text":"说说dubbo服务上下线时你们是如何处理的? dubbo的协议有哪些,哪些使用场景? dubbo使用的系列化框架是什么? dubbo服务容错机制? socket协议的几种状态,socket协议的三次握手,为什么是三次握手? 说说nio和io有什么不同,nio有哪些场景? http请求有哪些方法? jdk1.8有哪些新特性,使用过哪些? 谈谈对GC的理解，对G1有了解吗? Collection.sort底层默认使用哪种排序算法，说说你熟悉的排序算法有哪些? 基本数据类型,占用字节,包装类,为什么会有包装类? 多线程你们在项目中怎么用的? jdk1.8中Stream在并行处理时，适合哪些情景，不适合哪些情景?(第一次遇到这样问的,没回答上来)适合计算密集型,不适合IO密集型。因为Stream被分配到的是核心线程池，IO密集型会造成线程阻塞。 你们reids在使用中，过期时间是怎么设置的，分两步设置不能保证原子性，怎么解决的? 写一下二分查找算法？ 写一个单例?(DCL)？ 说说dubbo和spring cloud有什么区别? 你们数据库是怎么优化的,说说实例? 了解redis吗，说说redis基本数据结构，有哪些常用的指令？ 1、说说 dubbo 的执行流程2、redis 基本数据结构，你们是怎么用的（讲了下 5 分钟发帖 10 次）3、数据库连接池了解吗？4、生产环境项目打印日志出现了时间长的现象，你怎么排查5、接口出现频繁 GC ，怎么排查 1 线程池用过哪些，在项目中是怎么使用的 2 sql优化怎么做的，哪些情况触发不了索引 , sql优化除了索引还要看哪些指标 3 redis有没有遇到数据库满了的情况 4 说说redis cluster 5 springmvc springboot springcloud的区别 6 对restful有了解吗，弹弹restful 7 说说对spring的理解 8 @Autowired和@Resource的区别 9 设计模式有哪些了解，说说设计模式遵循的原则 10 交给你一个项目，怎么推进 11 通过哪些途径学习，看些什么书 12 总结下自己","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"面试题","slug":"java/面试题","permalink":"https://zhilongao.github.io/categories/java/面试题/"}]},{"title":"linux系统","date":"2019-09-09T12:19:57.000Z","path":"wiki/linux-system-problem/","text":"linux三种网络模式在我们安装vmware的时候，vmware会为三种网络模式各自创建一个虚拟机网络, 其中 VMnet0(表示桥接模式) VMnet8(NAT模式) VMnet1(仅主机模式) 桥接模式 和主机一样，也会占用一个局域网中的ip。信息的发送和接受，虚拟网络适配器和主机的物理网络适配器进行交换，虚拟网络适配器可以通过主机的物理网络适配器访问外部网络。在局域网中的其它主机能够识别到发送信息的ip为该虚拟机的ip。 NAT模式 虚拟机发送数据时，NAT虚拟机网络适配器会以主机的名义将数据包裹发送出去，接收时通过特殊的标识识别。在外部网络中并不知道当前虚拟机的存在。 主机模式 仅可以和主机通信，无法访问外部网络。 ​ 一篇介绍的很形象的文章 centos7之动态ip与静态ipcentos7获取ip地址的方法主要有两种 1:动态获取 2:设置静态ip我们一般通过VMWare安装完centos7后，可以使用命令ip addr查看虚拟机的ip地址。但是刚安装完的centos7有些没有设置ip地址，我们可以通过下面两种方式来设置ip地址。1. 动态获取ip(前提是路由器已经开启了DHCP(动态主机设置协议)) a: 需要修改网卡的配置文件 /etc/sysconfig/network-scripts/ifcfg-ens33 其中ifcfg-ens33为网卡名。修改该文件的两处地方既可。 (1) bootproto=dhcp (2) onboot=yes b: 重启下网络服务 [root@mini ~]# systemctl restart network c: 通过 ip addr 命令可以看到ens33的网卡已经有相应的ip地址啦 d: 通过 ping www.baidu.com 查看网络是否通畅 在VMware里，点击'编辑'-'虚拟网络编辑器' 2. 配置静态ip地址(网络模式在nat模式下) a: 也是需要修改网卡配置文件 /etc/sysconfig/network-srcipts/ifcfg-ens33 其中ifcfg-ens33为网卡名。修改该文件的两处地方既可。 (1) bootproto=static (2) onboot=yes b: 还需要在该网卡配置文件的后面加上几行，分别是ip地址，子网掩码，网关，dns服务器 IPADDR=192.168.25.156 #静态ip NETMASK=255.255.255.0 #子网掩码 GATEWAY=192.168.1.1 #网关 DNS1=192.168.25.2 DNS2=8.8.8.8 #谷歌的dns服务器 c: 重启下网络服务 [root@mini ~]# systemctl restart network d: 通过 ip addr 命令可以看到ens33的网卡已经有新的ip地址啦 e: 通过 ping www.baidu.com 查看网络是否通畅3. 在 /etc/resolv.conf文件里面保存了dns地址，可以通过cat命令查看 在设置静态ip时,子网掩码和网关地址可以在vmware的-&gt;编辑-&gt;虚拟网络编辑器-&gt;NAT设置 中查看，如下图所示","tags":[],"categories":[{"name":"系统","slug":"系统","permalink":"https://zhilongao.github.io/categories/系统/"},{"name":"linux","slug":"系统/linux","permalink":"https://zhilongao.github.io/categories/系统/linux/"}]},{"title":"字符串","date":"2019-09-06T02:25:40.000Z","path":"wiki/alg-string-simple1/","text":"题目来自leetcode 字符串反转1(344)/*题目要求：编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组char[]的形式给出。*/public void reverseString(char[] s) &#123; int low = 0; int high = s.length - 1; while (low &lt; high) &#123; char temp = s[low]; s[low++] = s[high]; s[high--] = temp; &#125;&#125; 字符串反转2(541)/*题目要求:给定一个字符串和一个整数 k，你需要对从字符串开头算起的每个 2k 个字符的前k个字符进行反转。如果剩余少于 k 个字符，则将剩余的所有全部反转。如果有小于 2k 但大于或等于 k 个字符，则反转前 k 个字符，并将剩余的字符保持原样。示例：输入: s = \"abcdefg\", k = 2 输出: \"bacdfeg\"*/public String reverseStr(String s, int k) &#123; // 计算长度 整数遍历次数 剩余元素个数 int len = s.length(); int lastNum = len % (2 * k); int num = len / (2 * k); char[] chars = s.toCharArray(); // 先将前2*k*num个元素做反转 for (int i = 1; i &lt; 2 * num; i += 2) &#123; int low = (i - 1) * k; int high = i * k - 1; reverseChar(chars, low, high); &#125; // 将剩余的不到2*k个元素反转 if (lastNum &gt; k) &#123; reverseChar(chars, 2*k*num, 2*k*num+k-1); &#125; else &#123; reverseChar(chars, 2*k*num, len-1); &#125; return new String(chars);&#125;// 字符数组反转函数public void reverseChar(char[] chars, int low, int high) &#123; while (low &lt; high) &#123; char temp = chars[low]; chars[low ++] = chars[high]; chars[high --] = temp; &#125;&#125; 字符串反转3(557)/*题目要求: 给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。示例 1: 输入: \"Let's take LeetCode contest\" 输出: \"s'teL ekat edoCteeL tsetnoc\" */// 解法：将字符串按照空格拆分成为字符串数组，然后将每一个字符串翻转，最后将反转的字符串拼接到一起。// 其中字符串的反转采用的方式为先转换为字符数组，然后反转字符数组。public String reverseWords(String s) &#123; StringBuilder sb = new StringBuilder(); String[] split = s.split(\"\\\\s+\"); for (int i = 0; i &lt; split.length ; i++) &#123; char[] chars = split[i].toCharArray(); int low = 0; int hig = chars.length - 1; while (low &lt; hig) &#123; char temp = chars[low]; chars[low ++] = chars[hig]; chars[hig --] = temp; &#125; sb.append(chars); if (i != split.length - 1) &#123; sb.append(\" \"); &#125; &#125; return sb.toString();&#125; 字符串反转4(917)/*题目要求:给定一个字符串 S，返回 “反转后的” 字符串，其中不是字母的字符都保留在原地，而所有字母的位置发生反转。示例 1：输入：\"ab-cd\" 输出：\"dc-ba\"示例 2：输入：\"a-bC-dEf-ghIj\" 输出：\"j-Ih-gfE-dCba\"*/public String reverseOnlyLetters(String S) &#123; // 双指针 StringBuffer buf = new StringBuffer(); int j = S.length() - 1; for (int i = 0; i &lt; S.length(); i ++) &#123; // 位置i上的字符为字母时，可以做交换 if (Character.isLetter(S.charAt(i))) &#123; while(!Character.isLetter(S.charAt(j))) &#123; j --; &#125; buf.append(S.charAt(j --)); &#125; else &#123; buf.append(S.charAt(i)); &#125; &#125; return buf.toString();&#125; 字符串反转5(345)/*题目要求:编写一个函数，以字符串作为输入，反转该字符串中的元音字母。示例 1: 输入: \"hello\" 输出: \"holle\"示例 2: 输入: \"leetcode\" 输出: \"leotcede\"说明: 元音字母不包含字母\"y\"。*/// 元音字母集合final static Set&lt;Character&gt; sets = new HashSet&lt;&gt;(Arrays.asList('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'));// 使用双指针,当两端同时为元音字母时,交换两个位置的字符。public String reverseVowels(String s) &#123; int left = 0; int right = s.length() - 1; char[] chars = s.toCharArray(); while (left &lt;= right) &#123; while (!judgeVowel(chars[left])) &#123; left ++; if (left &gt; s.length() -1) &#123; break; &#125; &#125; while (!judgeVowel(chars[right])) &#123; right --; if (right &lt; 0) &#123; break; &#125; &#125; if (left &gt; right) &#123; break; &#125; char temp = chars[left]; chars[left++] = chars[right]; chars[right--] = temp; &#125; return new String(chars);&#125; 报数问题(38)/*题目要求：报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：1. 12. 113. 214. 12115. 111221说明：上一项报前一项，报数时是按照各数+数字报的。比如：给1报数的是2，报数时时1个1，即为11。给2报数的是3，报的数是11，2个1，即为21。报21时，1个2，1个1，即为1211*/// 解法：就是按照规律统计前一项的数字，直到第n项统计出n-1为止。public String countAndSay(int n) &#123; String res = \"1\"; for (int i = 2; i &lt;= n; i ++) &#123; StringBuffer buf = new StringBuffer(); char ch = res.charAt(0); int num = 0; for (int j = 0; j &lt; res.length(); j ++) &#123; if (ch == res.charAt(j)) &#123; num ++; &#125; else &#123; buf.append(num).append(ch); ch = res.charAt(j); num = 1; &#125; &#125; buf.append(num).append(ch); res = buf.toString(); &#125; return res;&#125; 二进制求和(67)/*题目要求： 给定两个二进制字符串，返回他们的和（用二进制表示）。 输入为非空字符串且只包含数字 1 和 0。示例: 输入: a = \"11\", b = \"1\" 输出: \"100\" 输入: a = \"1010\", b = \"1011\" 输出: \"10101\"*/// 从后往前遍历计算，将计算结果拼接到字符串后面，最后将字符串反转public String addBinaryA(String a, String b) &#123; StringBuffer buf = new StringBuffer(); int ans = 0; for (int i = a.length() - 1, j = b.length() - 1; i &gt;= 0 || j &gt;= 0; i--, j--) &#123; int sum = ans; // 两个字符串长度可能不同，故先遍历完毕的字符串计算值用0代替 sum += (i &gt;= 0 ? a.charAt(i) - '0' : 0); sum += (j &gt;= 0 ? b.charAt(j) - '0' : 0); // 拼接 buf.append(sum % 2); // 进位 ans = sum / 2; &#125; buf.append(ans == 1 ? ans : \"\"); return buf.reverse().toString();&#125; 验证回文串(125)/*题目要求： 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。说明：本题中，我们将空字符串定义为有效的回文串。示例： 输入: \"A man, a plan, a canal: Panama\" 输出: true 输入: \"race a car\" 输出: false*/public boolean isPalindromeA(String s) &#123; if (s == null || s.trim().length() == 0) &#123; return true; &#125; // 将字符串转小写 String param = s.toLowerCase(); int length = param.length(); int left = 0; int right = length - 1; // 左右两个指针遍历，相遇结束 while (left &lt; right) &#123; // 从左起，定位到第一个字母或是数字 while (left &lt; right &amp;&amp; !isSuitable(param.charAt(left))) &#123; left ++; &#125; // 从右起，定位到第一个字母或是数字 while (left &lt; right &amp;&amp; !isSuitable(param.charAt(right))) &#123; right --; &#125; if (left &gt;= right) &#123; return true; &#125; // 不符合条件，返回false if (param.charAt(left ++) != param.charAt(right --)) &#123; return false; &#125; &#125; return true;&#125;// 判定给定的字符是否为字母或数字public boolean isSuitable(char c) &#123; return Character.isLetter(c) || Character.isDigit(c);&#125; 有效括号(20)/*题目要求：给定一个只包括 '('，')'，'&#123;'，'&#125;'，'['，']' 的字符串，判断字符串是否有效。有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。示例: 输入: \"()\" 输出: true 输入: \"()[]&#123;&#125;\" 输出: true 输入: \"(]\" 输出: false 输入: \"([)]\" 输出: false 输入: \"&#123;[]&#125;\" 输出: true */// 解法：使用栈来操作public boolean isValid(String s) &#123; // 规律：对应的括号只有可能在紧邻的一位或者对称的位置找到 // 空字符串直接返回 true if (s == null || s.trim().length() == 0) &#123; return true; &#125; int length = s.length(); // 非2的偶数倍，直接返回false if (length % 2 != 0) &#123; return false; &#125; // 通过定义stack来实现，遇到左括号放入到stack中，遇到右括号从stack中弹出元素与之对比 // 这种的扩展性较好，但是要引入HashMap,并且要匹配key,所以时间复杂度和空间复杂度都没下面的好 Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); Map&lt;Character, Character&gt; map = new HashMap&lt;Character, Character&gt;(); map.put('(', ')'); map.put('&#123;', '&#125;'); map.put('[', ']'); Set&lt;Character&gt; keys = map.keySet(); for (int j = 0; j &lt; length; j ++) &#123; char c = s.charAt(j); if (keys.contains(c)) &#123; stack.push(c); &#125; else &#123; if (stack.isEmpty() || map.get(stack.pop()) != c) &#123; return false; &#125; &#125; &#125; // 下面这种时间复杂度和空间复杂度都要由于上面的，但是扩展性不好 /* Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); for (int i = 0; i &lt; length; i ++) &#123; char c = s.charAt(i); switch(c) &#123; case '(': case '&#123;': case '[': stack.push(c); break; case ')': if (stack.isEmpty() || stack.pop() != '(') &#123; return false; &#125; continue; case '&#125;': if (stack.isEmpty() || stack.pop() != '&#123;') &#123; return false; &#125; continue; case ']': if (stack.isEmpty() || stack.pop() != '[') &#123; return false; &#125; continue; &#125; &#125; */ return stack.isEmpty();&#125; 无重复字符的最长子串(3)// 滑动窗口解法public int lengthOfLongestSubstring(String s) &#123; int length = s.length(); int ans = 0; int left = 0; int right = 0; Set&lt;Character&gt; set = new HashSet&lt;Character&gt;(); while(left &lt; length &amp;&amp; right &lt; length) &#123; if (!set.contains(s.charAt(right))) &#123; set.add(s.charAt(right ++)); ans = Math.max(ans, right - left); &#125; else &#123; set.remove(s.charAt(left ++)); &#125; &#125; return ans;&#125; 最长回文子串(5)// 题目要求:给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。// 1.要判断一个字符串是否为回文字符串，可以通过下面几种方式来实现// 第一种:通过栈的后进先出原理，将字符串翻转来对比前后两个字符串是否一致public static boolean isHuiWen1(String str) &#123; Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); for (int i = 0; i &lt; str.length(); i++) &#123; stack.push(str.charAt(i)); &#125; StringBuffer buf = new StringBuffer(); while (!stack.isEmpty()) &#123; buf.append(stack.pop()); &#125; if (str.equals(buf.toString())) &#123; return true; &#125; return false;&#125;// 第二种: 取消栈的引入，直接通过逆序输出拼接字符串(减少了额外的空间Stack)public static boolean isHuiWen2(String str) &#123; StringBuffer buf = new StringBuffer(); for (int i = str.length() - 1; i &gt;= 0 ; i--) &#123; buf.append(str.charAt(i)); &#125; if (buf.toString().equals(str)) &#123; return true; &#125; return false;&#125;// 第三中: 基于回文串左右两边两个字符相等的规律，定义两个变量做对比(优势是减少了字符串str的遍历次数，时间复杂度降低)public static boolean isHuiWen3(String str) &#123; int length = str.length(); int left = 0; int right = length - 1; while (left &lt;= right) &#123; if (!(str.charAt(left) == str.charAt(right))) &#123; return false; &#125; left ++; right --; &#125; return true;&#125;// 当前这道题如何实现public String longestPalindrome(String s) &#123; // 给定一个字符串s,找到s中最长的回文子串。你可以假设s的最大长度为1000。 int len = s.length(); if (len == 0) &#123; return \"\"; &#125; int resultLen = 1; String resultStr = s.substring(0, 1); for (int i = 0; i &lt; len; i ++) &#123; // 从中间向两边查找对称的回文串 String oddStr = spread(s, len, i, i); String evenStr = spread(s, len, i, i+1); String myStr = oddStr.length() &gt;= evenStr.length() ? oddStr : evenStr; if (myStr.length() &gt; resultLen) &#123; resultStr = myStr; resultLen = resultStr.length(); &#125; &#125; return resultStr;&#125; public String spread(String s, int len, int left, int right) &#123; int l = left; int r = right; while (l &gt;= 0 &amp;&amp; r &lt; len &amp;&amp; (s.charAt(l) == s.charAt(r))) &#123; l --; r ++; &#125; return s.substring(l+1, r);&#125; 压缩字符串(443)// 题目要求: 给定一组字符串，使用原地算法将其压缩。// 题目解法public int compress(char[] chars) &#123; int anchor = 0; // 描点，定位可以元素 int write = 0; // 写下标，定位写的位置 for (int read = 0; read &lt; chars.length; read ++) &#123; // 若是当前元素为最后一个元素或者是后一个元素与当前元素不相等，执行写入与统计写入操作 if ((read == chars.length - 1) || (chars[read + 1] != chars[read])) &#123; // 将anchor位置处的元素写入到write位置处 chars[write ++] = chars[anchor]; // 判断该元素是否需要压缩 if (read &gt; anchor) &#123; String numStr = read - anchor + 1 + \"\"; char[] numArr = numStr.toCharArray(); for (char num : numArr) &#123; chars[write ++] = num; &#125; &#125; // 将锚点移动到下一个元素 anchor = read + 1; &#125; &#125; // 返回覆盖的个数 return write;&#125; 字符串中的第一个唯一字符(387)/*题目要求: 给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。说明: 你可以假设字符串只含有小写字母。示例: s = \"leetcode\" 返回 0. s = \"loveleetcode\" 返回 2.*/// 第一中解法，遍历两次字符串，哈希表存储每个字符和其出现的个数public int firstUniqCharA(String s) &#123; Map&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); for (int i = 0; i &lt; s.length(); i ++) &#123; if (!map.containsKey(s.charAt(i))) &#123; map.put(s.charAt(i), 1); &#125; else &#123; map.put(s.charAt(i), map.get(s.charAt(i)) + 1); &#125; &#125; for (int j = 0; j &lt; s.length(); j ++) &#123; if (map.get(s.charAt(j)) == 1) &#123; return j; &#125; &#125; return -1;&#125;// 第二种解法: 仅遍历26个字母，唯一的特征：第一个字符和最后一个字符的index相同public int firstUniqCharB(String s) &#123; char[] originalChar = \"abcdefghijklmnopqrstuvwxyz\".toCharArray(); int index = s.length(); // 此处循环26次 for (char c : originalChar) &#123; int left = s.indexOf(c); if (left != -1 &amp;&amp; left == s.lastIndexOf(c)) &#123; index = Math.min(index, left); &#125; &#125; if(index != s.length()) &#123; return index; &#125; return -1;&#125; 赎金信(383)/*题目要求: 给出两个字符串，用第二个字符串中的字符拼接成为第一个字符串，每个字符只能使用一次。可以返回true，否则返回false。说明: 你可以假设两个字符串均只含有小写字母。实例： canConstruct(\"a\", \"b\") -&gt; false canConstruct(\"aa\", \"ab\") -&gt; false canConstruct(\"aa\", \"aab\") -&gt; true*/public boolean canConstruct(String ransomNote, String magazine) &#123; // 第一个字符串里面的字符能不能由第二个字符串里面的字符构成，若可以，返回true。否则返回false。 // 将26 个字母个数映射到一个26大小的数组上 int[] bucket = new int[26]; for (int i = 0; i &lt; magazine.length(); i ++) &#123; bucket[magazine.charAt(i) - 'a'] ++; &#125; for (int j = 0; j &lt; ransomNote.length(); j ++) &#123; if (-- bucket[ransomNote.charAt(j) - 'a'] &lt; 0) &#123; return false; &#125; &#125; return true;&#125;","tags":[],"categories":[{"name":"算法","slug":"算法","permalink":"https://zhilongao.github.io/categories/算法/"},{"name":"字符串","slug":"算法/字符串","permalink":"https://zhilongao.github.io/categories/算法/字符串/"}]},{"title":"array-ask","date":"2019-09-05T01:52:30.000Z","path":"wiki/alg-array-simple1/","text":"寻找递增序列// 给定一个未经过排序的数组，找到最长且连续的递增序列(在美团面试题中出现过-leetcode674题)public static int findLengthOfLCIS(int[] nums) &#123; if (nums.length == 0) &#123; return 0; &#125; int max = 0; int curr = 1; for (int i = 1; i &lt; nums.length; i ++) &#123; if (nums[i] &gt; nums[i - 1]) &#123; curr ++; &#125; else &#123; max = Math.max(max, curr); curr = 1; &#125; &#125; return Math.max(max, curr);&#125;","tags":[],"categories":[{"name":"算法","slug":"算法","permalink":"https://zhilongao.github.io/categories/算法/"},{"name":"数组","slug":"算法/数组","permalink":"https://zhilongao.github.io/categories/算法/数组/"}]},{"title":"mongodb-base","date":"2019-09-03T03:45:03.000Z","path":"wiki/mongodb-base/","text":"安装步骤(centos7)1.下载安装包 wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel62-3.2.10.tgz2.解压安装包 tar -zxvf mongodb-linux-x86_64-rhel62-3.2.10.tgz 3.将解压目录移动到(/usr/local/mongodb) mv mongodb-linux-x86_64-rhel62-3.2.10 /usr/local/mongodb4.在/usr/local/mongodb目录下创建/data/db目录和/logs目录 mkdir -p /usr/local/mongodb/data/db mkdir -p /usr/local/mongodb/logs5.在/usr/local/mongodb/logs目录下创建mongodb.log文件 touch mongodb.log6.在/usr/local/mongodb/bin目录下创建mongodb的配置文件 touch mongodb.conf7.编辑mongodb.conf文件 vi mongodb.conf 编辑内容 dbpath = /usr/local/mongodb/data/db #数据文件存放目录 logpath = /usr/local/mongodb/logs/mongodb.log #日志文件存放目录 port = 27017 #端口 fork = true #以守护程序的方式启用，即在后台运行 nohttpinterface = true auth=true bind_ip=0.0.0.08.修改环境变量 vi /etc/profile 添加的内容 export MONGODB_HOME=/usr/local/mongodb export PATH=$PATH:$MONGODB_HOME/bin9.编辑完成之后重启系统配置 source /etc/profile10.在/usr/local/mongodb/bin目录下启动mongodb ./mongod -f mongodb.conf11.关闭mongodb服务 ./mongod -f ./mongodb.conf --shutdown12.开启27017端口13.使用shell登录到mongodb ./mongodb14.登录到相关数据库 use test15.创建用户 db.createUser( &#123; user: \"test\", pwd: \"test\", roles: [&#123; role: \"readWrite\", db: \"test\" &#125;] &#125; )16.修改配置，开启验证 auth=true17.重启服务 停止服务，然后启动18.登录 ./mongodb19.验证 auth('test', 'test')(返回1代表成功)20.操作 db.user.find() db.user.insert(&#123;\"name\":'jack',\"age\": 12&#125;) 基本操作-&gt;java api的crud1. 引入依赖&lt;dependency&gt; &lt;groupId&gt;org.mongodb&lt;/groupId&gt; &lt;artifactId&gt;mongo-java-driver&lt;/artifactId&gt; &lt;version&gt;3.9.1&lt;/version&gt;&lt;/dependency&gt;2.java代码// 工具类public class MongoUtil &#123; private static String baseUrl = \"192.168.25.147:27017\"; private static String userName = \"test\"; private static String passWord = \"test\"; private static final String url = \"mongodb://\"+ userName +\":\"+ passWord + \"@\"+ baseUrl + \"/\"; // 获取MongoDatabase public static MongoDatabase getConnection(String dataName) &#123; // 获取MongoClient com.mongodb.client.MongoClient mongoClient = MongoClients.create(url + dataName); // 获取MongoDatabase MongoDatabase db = mongoClient.getDatabase(dataName); return db; &#125;&#125;// 基本操作 -&gt; 获取所有public static void findAll(String databaseName, String collectionName) &#123; MongoDatabase database = MongoUtil.getConnection(databaseName); MongoCollection&lt;Document&gt; collection = database.getCollection(collectionName); FindIterable&lt;Document&gt; documents = collection.find(); print(documents);&#125;// 基本操作 -&gt; 插入public static void insert(String databaseName, String collectionName) &#123; // 获取database MongoDatabase database = MongoUtil.getConnection(databaseName); // 获取Clooection MongoCollection&lt;Document&gt; collection = database.getCollection(collectionName); // 创建Document Document document = new Document() .append(\"name\", \"mick11\") .append(\"age\", \"33\") .append(\"address\", \"长沙\") .append(\"sex\", \"男\"); // 插入document collection.insertOne(document);&#125;// 打印所有public static void print(FindIterable&lt;Document&gt; documents) &#123; for (Document document : documents) &#123; System.out.println(document.toJson()); &#125;&#125;","tags":[{"name":"mongo","slug":"mongo","permalink":"https://zhilongao.github.io/tags/mongo/"}],"categories":[{"name":"数据库","slug":"数据库","permalink":"https://zhilongao.github.io/categories/数据库/"},{"name":"mongodb","slug":"数据库/mongodb","permalink":"https://zhilongao.github.io/categories/数据库/mongodb/"}]},{"title":"实际应用","date":"2019-09-02T00:47:25.000Z","path":"wiki/redis-advance/","text":"list实现分布式队列// 需要的依赖jedis fastjson&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.4&lt;/version&gt;&lt;/dependency&gt;// 测试类/** * @Author long * @Date 2019/9/8 15:00 */public class App &#123; private static final String url = \"192.168.25.150\"; private static final int port = 6379; public static void main(String[] args) &#123; // 构建queue String queueKey = \"message_queue\"; Jedis jedis = new Jedis(url, port); // 消息转换器 MessageConvert&lt;TaskItem&gt; convert = new MessageConvert&lt;&gt;(); // 消息队列 RedisQueue queue = new RedisQueue(jedis, queueKey, convert); // 生产者 MessageProducer producer = new MessageProducer(queue); // 消费者 MessageConsumer consumer = new MessageConsumer(queue); producer.start(); consumer.start(); &#125;&#125;// 消息队列/** * @Author long * @Date 2019/9/8 14:34 * 分布式消息队列-list实现 */public class RedisQueue &#123; private Jedis jedis; private String queueKey; public RedisQueue(Jedis jedis, String queueKey, MessageConvert messageConvert) &#123; this.jedis = jedis; this.queueKey = queueKey; &#125; // 发送消息 public void push(String message) &#123; this.jedis.lpush(queueKey, message); &#125; // 消费消息-&gt;可重试 public String poll(boolean isRetry) &#123; String message = jedis.rpop(queueKey); if (message == null &amp;&amp; isRetry) &#123; try &#123; TimeUnit.MILLISECONDS.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; message = jedis.rpop(queueKey); &#125; return message; &#125;&#125;/** * @Author long * @Date 2019/9/8 15:47 * 消息生产者 */public class MessageProducer extends Thread &#123; // 队列 private RedisQueue queue; // 消息转换器 private static final MessageConvert&lt;TaskItem&gt; convert = new MessageConvert&lt;&gt;(); public MessageProducer(RedisQueue queue) &#123; this.queue = queue; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; send(\"message:\" + i); try &#123; TimeUnit.MILLISECONDS.sleep(30); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; // 创建并发送消息 private void send(String message) &#123; // 创建一条消息 TaskItem item = new TaskItem(); item.id = UUID.randomUUID().toString(); item.msg = message; // 转换为字符串发送 String sendMess = convert.messageToString(item); queue.push(sendMess); &#125;&#125;/** * @Author long * @Date 2019/9/8 15:48 * 消息消费者 */public class MessageConsumer extends Thread &#123; private RedisQueue queue; public MessageConsumer(RedisQueue queue) &#123; this.queue = queue; &#125; @Override public void run() &#123; Random random = new Random(); while (true) &#123; try &#123; TimeUnit.MILLISECONDS.sleep(random.nextInt(10)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; receive(); &#125; &#125; private void receive() &#123; Object object = queue.poll(true); if (object != null) &#123; System.out.println(object); &#125; &#125;&#125;/** * @Author long * @Date 2019/9/8 15:45 * 消息转换器 */public class MessageConvert&lt;T&gt; &#123; private Type taskType = new TypeReference&lt;T&gt;() &#123;&#125;.getType(); /** * 将给定的消息转换为string类型 * @param t * @return */ public String messageToString(T t) &#123; return JSON.toJSONString(t); &#125; /** * 将string类型的消息转换为T类型 * @param message * @return */ public T stringToObject(String message) &#123; return JSON.parseObject(message, taskType); &#125;&#125; zset实现延时队列// 测试方法private static void delayQueue() &#123; Jedis jedis = new Jedis(url, port); // 延时队列 RedisDelayingQueue queue = new RedisDelayingQueue(jedis, \"q-demo\"); DelayMessageConsumer consumer = new DelayMessageConsumer(queue); DelayMessageProducer producer = new DelayMessageProducer(queue); producer.start(); consumer.start(); try &#123; // 首先让producer线程执行完成 producer.join(); // 主线程睡眠6秒，等待consumer将消息消费完成 Thread.sleep(6000); consumer.interrupt(); consumer.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125;/** * @Author long * @Date 2019/9/7 16:56 * 延时队列-&gt; 通过zset实现 */public class RedisDelayingQueue &#123; private Jedis jedis; private String queueKey; public RedisDelayingQueue(Jedis jedis, String queueKey) &#123; this.jedis = jedis; this.queueKey = queueKey; &#125; // 执行消息的发送 public void delay(String msg, long score) &#123; jedis.zadd(queueKey, score, msg); &#125; // 执行消息的处理 public void loop(MessageHandle handle) &#123; while (!Thread.interrupted()) &#123; // fixme 此处需要优化，保证操作的原子性 // 获取一条数据(score最小的那条数据) Set values = jedis.zrangeByScore(queueKey, 0, System.currentTimeMillis(), 0, 1); // 若是队列中没有任务，线程睡眠500毫秒 if (values.isEmpty()) &#123; try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; break; &#125; continue; &#125; String value = (String) values.iterator().next(); // 从queueKey中移除该元素 if (jedis.zrem(queueKey, value) &gt; 0) &#123; // 将消息交给回调接口来处理 handle.handle(value); &#125; &#125; &#125;&#125;/** * @Author long * @Date 2019/9/8 17:13 * 延时队列-生产者线程 */public class DelayMessageProducer extends Thread &#123; RedisDelayingQueue queue; public DelayMessageProducer(RedisDelayingQueue queue) &#123; this.queue = queue; &#125; @Override public void run() &#123; Random random = new Random(); for (int i = 0; i &lt; 10 ; i++) &#123; String message = \"message:\"+ i; long score = random.nextInt(10); send(message, score); &#125; &#125; private void send(String msg, long delay) &#123; TaskItem task = new TaskItem(); task.id = UUID.randomUUID().toString(); task.msg = msg; String message = JSON.toJSONString(task); queue.delay(message, delay); &#125;&#125;/** * @Author long * @Date 2019/9/8 17:11 * 延时队列消费者线程 */public class DelayMessageConsumer extends Thread &#123; RedisDelayingQueue queue; private final static MessageHandle handle = new MessageHandle() &#123; @Override public void handle(String item) &#123; System.out.println(item); &#125; &#125;; public DelayMessageConsumer(RedisDelayingQueue queue) &#123; this.queue = queue; &#125; @Override public void run() &#123; this.queue.loop(handle); &#125;&#125;/** * @Author long * @Date 2019/9/8 17:21 * 消息处理回调接口 */public interface MessageHandle &#123; void handle(String item);&#125;","tags":[],"categories":[{"name":"数据库","slug":"数据库","permalink":"https://zhilongao.github.io/categories/数据库/"},{"name":"redis","slug":"数据库/redis","permalink":"https://zhilongao.github.io/categories/数据库/redis/"}]},{"title":"单链表","date":"2019-08-31T03:56:40.000Z","path":"wiki/alg-linkedlist-simple1/","text":"单链表常见操作 1.如何实现一个单链表的逆序输出-&gt;反转单链表 public static ListNode reverse(ListNode head) &#123; ListNode prev = null; ListNode next = null; while (head != null &amp;&amp; (next = head.next) != null) &#123; head.next = prev; prev = head; head = next; &#125; head.next = prev; return head;&#125;","tags":[],"categories":[{"name":"算法","slug":"算法","permalink":"https://zhilongao.github.io/categories/算法/"},{"name":"链表","slug":"算法/链表","permalink":"https://zhilongao.github.io/categories/算法/链表/"}]},{"title":"排序算法","date":"2019-08-31T01:19:15.000Z","path":"wiki/alg-sort-simple/","text":"常见的排序算法 1.插入排序 // 插入排序算法// 时间复杂度：平均情况:o(n^2) 最好情况:o(n) 最坏情况:o(n^2) // 空间复杂度: o(1)// 特点: 稳定public static void insertSort(int[] array) &#123; int i,j; for (i = 1; i &lt; array.length; i ++) &#123; int temp = array[i]; for (j = i - 1; j &gt;=0 &amp;&amp; array[j] &gt; temp; j --) &#123; // 将数组中的元素后移一位 array[j + 1] = array[j]; &#125; array[j + 1] = temp; &#125;&#125; 2.选择排序 原理 // 选择排序算法// 时间复杂度: 平均情况:o(n^2) 最好情况:o(n^2) 最坏情况:o(n^2) // 空间复杂度: o(1)// 特点: 不稳定public static void selectSort(int[] array) &#123; for (int i = 0; i &lt; array.length; i ++) &#123; for (int j = i + 1; j &lt; array.length; j ++) &#123; if (array[i] &gt; array[j]) &#123; int temp = array[i]; array[i] = array[j]; array[j] = temp; &#125; &#125; &#125;&#125; 3.交换排序-&gt;冒泡排序 原理 // 冒泡排序算法// 时间复杂度: 平均情况:o(n^2) 最好情况:o(n) 最坏情况:o(n^2)// 空间复杂度: o(1)// 特点：稳定public static void bubbleSort(int[] array) &#123; for (int i = 0; i &lt; array.length; i ++) &#123; for (int j = 0; j &lt; array.length - i - 1; j ++) &#123; if (array[j] &gt; array[j + 1]) &#123; int temp = array[j]; array[j] = array[j + 1]; array[j + 1] = temp; &#125; &#125; &#125;&#125; 4.交换排序-&gt;快速排序 原理 // 快速排序算法// 时间复杂度: 平均情况:o(nlog2^n) 最好情况:o(nlog2^n) 最坏情况:o(n^2)// 空间复杂度: o(nlog2^n)// 特点：不稳定public static void fastSort(int[] array, int low, int high) &#123; if (low &gt; high) &#123; return; &#125; int i = low; int j = fast; int temp = array[low]; while (i &lt; j) &#123; // 从右向左找到第一个小于temp的元素,保存其下标 while (array[j] &gt; temp &amp;&amp; i &lt; j) &#123; j --; &#125; // 从左向右找到第一个大于temp的元素，保存其下标 while (array[i] &lt;= temp &amp;&amp; i &lt; j) &#123; i ++; &#125; // 交换这两个元素 int swap = array[i]; array[i] = array[j]; array[j] = swap; &#125; // 交换temp array[low] = array[i]; array[i] = temp; // 快排temp左半边 fastSort(array, low, j - 1); // 快排temp右半边 fastSort(array, j + 1, high);&#125; 5.归并排序 // 归并排序算法// 时间复杂度: 平均情况:o(nlog2^n) 最好情况:o(nlog2^n) 最坏情况:o(nlog2^n)// 空间复杂度：o(1)// 特点: 稳定public static void sortMerge(int[] array) &#123; sort(array, 0, array.length - 1);&#125;public static void sort(int array[], int L, int R) &#123; if (L == R) &#123; return; &#125; int mid = (R + L) / 2; // 排序左半部分 sort(array, L, mid); // 排序右半部分 sort(array, mid + 1, R); // 合并 merge(array, L, mid, R);&#125;public static void merge(int[] array, int L, int mid, int R) &#123; int[] temp = new int[R - L + 1]; int i = 0; int p1 = L; int p2 = mid + 1; // 将数组排序后放入到临时数组temp中 while (p1 &lt;= mid &amp;&amp; p2 &lt;= R) &#123; if (array[p1] &lt; array[p2]) &#123; temp[i++] = array[p1++]; &#125; else &#123; temp[i++] = array[p2++]; &#125; &#125; while(p1 &lt;= mid) &#123; temp[i++] = array[p1++]; &#125; while(p2 &lt;= R) &#123; temp[i++] = array[p2++]; &#125; // 将临时数组中的元素移动到array中 for (int k = 0; k &lt; temp.length; k ++) &#123; array[L + k] = temp[k]; &#125;&#125;","tags":[],"categories":[{"name":"算法","slug":"算法","permalink":"https://zhilongao.github.io/categories/算法/"},{"name":"排序","slug":"算法/排序","permalink":"https://zhilongao.github.io/categories/算法/排序/"}]},{"title":"jvm-command","date":"2019-08-29T09:01:23.000Z","path":"wiki/jvm-command/","text":"jvm基本指令 基本指令 指令说明 iconst_1 int型常量值1进栈 bipush 将一个byte型常量值推送至栈顶 iload_1 第二个int型局部变量进栈，从0开始计数 istore_1 将栈顶int型数值存入第二个局部变量，从0开始计数","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"基础","slug":"java/基础","permalink":"https://zhilongao.github.io/categories/java/基础/"},{"name":"jvm","slug":"java/基础/jvm","permalink":"https://zhilongao.github.io/categories/java/基础/jvm/"}]},{"title":"dubbo","date":"2019-08-28T11:57:42.000Z","path":"wiki/dubbo-ask/","text":"协议","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"分布式","slug":"java/分布式","permalink":"https://zhilongao.github.io/categories/java/分布式/"}]},{"title":"博客","date":"2019-08-27T13:38:52.000Z","path":"wiki/share-articles/","text":"友情链接 任亚鹏的博客 技术大牛 小马哥 精彩社区 美团技术团队 v2ex 掘金 java技术驿站 infoq","tags":[],"categories":[]},{"title":"分库分表","date":"2019-08-27T09:08:54.000Z","path":"wiki/mysql-split/","text":"数据库优化之分库分表 针对数据库的优化有两点，第一是从整体层面优化，设计到读写分离和分库分表。第二是从sql层面优化，主要是涉及到索引相关的一些东西。 读写分离 ​ 需求: 读写分离的目的是做数据冗余备份，同时将读写分离，提升数据库的服务性能（IO性能瓶颈）。 ​ 搭建过程: 在基本操作里面-&gt;mysql配置主从同步的步骤 。 ​ 实现原理: 首先是master数据库会先将数据库的变化存储在binlog文件中。在slave数据库上，会有一个IO Thread负责将binlog文件读取到内部的relaylog文件中。同时，slave数据库上的另外一个线程SQL Thread读取relaylog，将数据写入到slave数据库里面。 ​ 细节: mysql的binlog文件存储在 /var/lib/mysql文件夹下；使用命令-&gt; mysqlbinlog –base64-output=decode-rows -v mysql-bin.000001 查看binlog的内容；binlog的格式：statement（默认，基于sql语句模式，针对数据更新的一些函数now()等，数据延迟造成的不一致），row：基于行模式，记录修改后每一条数据变化的值，mixed：混合模式，由mysql自动判断处理。 ​ 问题：同步延迟，master tps较高时出现同步延迟； 网络延迟；磁盘IO 分库分表 ​ 垂直拆分 ​ 概念:垂直拆分主要是通过业务层面，将各个业务模块所使用到的表放到各自不同的数据库里面，做到各个业务模块库相互隔离的目的。 ​ 问题:若是各个业务模块的表之间存在一些关联查询，需要将这些查询改为服务调用的方式。 针对一些全局表，可以改为服务调用的方式，对外提供服务。 ​ 水平拆分 ​ 概念:将一张大的表拆分成n多张小表。实现方式，第一种是通过一致性hash（若是新增表的话，会涉及到数据迁移的问题）。第二种是可以按照id的范围来拆分。第三种是通过日期来拆分。 ​ 问题:唯一主键问题，可以使用zk自增id 可以使用redis的自增id 可以使用代理的id Mycat 1. 从github上面clone项目 https://github.com/MyCATApache/Mycat-Server.git2. 修改项目中schema.xml配置文件中的dataHost数据库配置节点信息，修改为可用的数据库3. MycatStartup类运行main函数启动 idea启动前需要在配置参数VM options: -DMYCAT_HOME=D:\\code\\Mycat-Server\\src\\main4. 通过数据库连接工具可以连接到MyCat,数据库相关配置在server.xml配置文件里面 默认的用户名: root 密码: 123456 port: 80665. mycat里面有三个比较重要的配置文件 server.xml 配置数据库连接相关的一些信息 schema.xml 配置数据库的一些节点信息 rule.xml 配置一些路由规则6. 支持单库分表 支持跨库分表 支持配置读写分离(writeHost和readHost节点)","tags":[],"categories":[{"name":"数据库","slug":"数据库","permalink":"https://zhilongao.github.io/categories/数据库/"},{"name":"mysql","slug":"数据库/mysql","permalink":"https://zhilongao.github.io/categories/数据库/mysql/"}]},{"title":"基本操作","date":"2019-08-27T09:08:25.000Z","path":"wiki/mysql-base/","text":"centos7上mysql的安装步骤 1.下载mysql的repo源 &gt; wget http://repo.mysql.com/mysql57-community-release-el7-8.noarch.rpm2.安装源&gt; rpm -ivh mysql57-community-release-el7-8.noarch.rpm3.安装数据库-&gt;yum install mysql-server4.启动数据库&gt; systemctl start mysqld5.查看mysql为root账号生成的随机密码&gt;grep \"password\" /var/log/mysqld.log 说明root@localhost:此处为随机密码6.运行mysql -uroot -p回车7.粘贴随机密码-&gt;此时已经登录到mysql数据库，需要为root账号设置密码8.由于mysql5.7有对密码设置的验证，简单密码设置不了，需要运行下面两条命令关闭验证 &gt; set global validate_password_length=1; &gt; set global validate_password_policy=0;9.修改root账号的密码 &gt; set password = password('123456');10.修改root账号的权限 &gt; GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'root' WITH GRANT OPTION;11.可以创建一个其它的用户 &gt; create user repl identified by 'repl';12.为该用户授权 &gt; grant replication slave on *.* to 'repl'@'%' identified by 'repl';(数据同步的权限) &gt; GRANT ALL ON *.* TO 'pig'@'%';(为用户pig授予所有权限) mysql配置主从同步的步骤 1.在master服务器上创建一个可以进行数据同步的账户。 &gt; create user repl identified by 'repl';2.在master服务器上为该用户授权。 &gt; grant replication slave on *.* to 'repl'@'%' identified by 'repl';3.在master服务器上修改/etc/my.cnf文件。 [mysqld] log-bin=mysql-bin server-id=1474.在master上面重启mysql &gt; systemctl restart mysqld5.在master上登录数据库，使用下面命令查看二进制文件。 &gt; show master status;6.在slave服务器上修改/etc/my.cnf文件 [mysqld] server-id=149 relay-log=slave-relay-bin relay-log-index=slave-relay-bin.index read-only=17.在slave服务器上重启mysql &gt; systemctl restart mysqld8.在slave上登录数据库, 执行下列命令，设置master相关参数。 &gt; change master to master_host='192.168.25.147',master_port=3306,master_user='repl',master_password='repl',master_log_file='mysql-bin.000003', master_log_pos=154;9.在slave上运行命令，启动服务 &gt; start slave;10.查看状态，查看主从同步设置是否成功 &gt; show slave status\\G;11.搭建完成，现在就可以玩啦，尝试在master上面创建数据库和表，在slave上会看到相应的数据库和表。","tags":[],"categories":[{"name":"数据库","slug":"数据库","permalink":"https://zhilongao.github.io/categories/数据库/"},{"name":"mysql","slug":"数据库/mysql","permalink":"https://zhilongao.github.io/categories/数据库/mysql/"}]},{"title":"索引","date":"2019-08-27T09:08:17.000Z","path":"wiki/mysql-index/","text":"1.数据库四大特性 ​ A( Atomicity 原子性): 数据库最小的工作单元，整个工作单元要么一起提交成功,要么一起失败回滚。​ C( Consistency 一致性): 事物中操作的数据的状态是一致的。即写入数据的结果必须完全符合预设的规则，不会因为出现系统意外等原因导致状态的不一致。​ I( Isolation 隔离性): 一个事务所操作的数据在提交之前，对其他事务的可见性设定（一般设定为不可见）。​ D( Durability 持久性): 数据库的数据一旦提交,无法更改。 2.多个事物并发引起的数据读取问题 ​ 脏读: 是指一个事物读取到了另外一个事物未提交的数据。​ 不可重复读: 是指在一个事物未结束之前, 前后两次读取到的数据不一致现象。原因在于该事物在前后两次读取数据之间，另外一个事物修改了该数据。(不可重复读的重点在于修改)。​ 幻读: 是指当一个事物修改了数据库表中某一个范围内的数据的某一个字段，但是另外一个事物在此期间又在该范围内插入了一条新的数据，造成前一个事物出现幻觉(没有完全修改)。(幻读的重点在于新增或删除) 。 3.数据库事物的隔离级别 Read Uncommited 读未提交: 事物未提交对其它的事物也是可见的。 Read Commited 读已提交: 一个事物只能够读取到已提交的数据。(解决脏读, 未解决不可重复读)。 Repeatable Read 可重复读: 一个事物对数据的前后读取结果是一致的。(解决了不可重复读, 未解决幻读)。 Serializable 串行化: 数据库最高的隔离级别, 强制所有事物串行执行,解决了所有并发问题。 4.聚集索引和非聚集索引的区别 聚集索引: 表中的数据是按照索引的顺序来存储的。索引的叶子节点上存储了真实的数据,不会有另外单独的数据页。 非聚集索引: 表中的数据存储不依赖于索引的顺序。索引的叶子节点上存储了索引的关键字和指向真实数据的指针。 5.sql调优 ​ a. 创建索引 b.使用临时表存储中间结果-&gt;(避免多次扫描主表)。c. 避免在索引上使用计算。4.少使用select *，只返回需要的字段。 6.如何理解MVCC ​ a. 数据库每张表会单独维护两个字段，数据行版本号和删除版本号。 ​ b. 当执行insert操作时，我们开启了一个事物，执行数据插入操作时，会将这个事物的事物id设置到数据行版本号这个字段中（这个事物的事物id属于数据库一个全局属性，自增）。 ​ c. 当执行delete操作时，我们开启了一个事物，执行数据删除操作时，会将这个事物的事物id设置到删除版本号这个字段中。 ​ d. 当执行update操作时，我们开启了一个事物，指定数据更新操作时，会将这行数据copy一份，copy的这份数据数据行版本号为当前事物id，删除版本号为Null，并更新相关字段。原先那行的删除版本号会被设置为当前的事物id。 ​ e. 当我们执行数据库查询时，满足以下两点要求： ​ e1：查找数据的数据行版本号小于或等于当前事物id。(保证该条数据在当前事物开启之前就已经存在或者为该事物添加的数据。 ​ e2：查找数据的删除版本号为Null或者删除版本号大于当前事物id。（该条规则可以确保当前事物在开始之前数据还未被删除。 7.MVCC解决的问题与未解决的问题 若是一个查询先于一行的数据更新，不会出现问题。若是一个查询后于一行的数据更新，会产生脏读的问题。 8.Innodb数据库的四种隔离级别是如何实现的 ​ 读未提交：对select操作不会加锁，并发性能是最好的，但是容易造成脏读。 ​ 读已提交（互联网上默认的隔离级别）：普通的数据读取是会直接读取数据快照，加锁的select，update等操作会使用记录锁。注意：读已提交读取快照时，一个事物读取了数据，但是当第二次读取的时候，另外一个事物已经将该快照刷新了，所以会造成不可重复读的问题。 ​ 可重复读（Innodb默认的事物隔离级别）：对于普通的数据库查询，使用读取快照的方式。对于加锁的select,update等语句，他们加锁的力度取决于查询条件是使用了唯一索引还是使用了范围查询。若是使用了唯一索引，会使用记录锁的方式。若是使用了范围查询，会使用间隙锁，避免发生不可重复读。注意:当一个事物开启读取数据时，前后两次读取的都是同一个快照，这样就可以实现了可重复读。 ​ 串行化：针对所有的操作都会去加锁，普通的select操作会去加共享锁-&gt;select * from table in share mode。对于 update 等操作会加排他锁。若是一个事物查询操作时，正好有一个事物对改行的数据做修改操作。则该查询操作会阻塞，直到更新操作执行完成。 9.如何理解快照读和当前读 ​ 快照读：读取的数据是快照。当前读：读取的数据是数据库的最新的数据。","tags":[],"categories":[{"name":"数据库","slug":"数据库","permalink":"https://zhilongao.github.io/categories/数据库/"},{"name":"mysql","slug":"数据库/mysql","permalink":"https://zhilongao.github.io/categories/数据库/mysql/"}]},{"title":"tcp","date":"2019-08-26T13:33:14.000Z","path":"wiki/tcp/","text":"此时握手 四次挥手 为什么要三次握手 为什么要四次挥手 socket的几种状态 ​ listen:侦听来自远方tcp端口的连接请求 ​ syn-sent:在发送连接请求后，等待匹配的连接请求。 ​ syn-receive:在收到和发送一个连接请求后，等待连接请求的确认 ​ established:代表一个打开的连接，数据可以传送给用户","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"分布式","slug":"java/分布式","permalink":"https://zhilongao.github.io/categories/java/分布式/"},{"name":"协议","slug":"java/分布式/协议","permalink":"https://zhilongao.github.io/categories/java/分布式/协议/"}]},{"title":"project-ask","date":"2019-08-26T13:26:32.000Z","path":"wiki/project-ask/","text":"项目专题 系统1 ​ 系统数据流转 ​ ​ // 大体流程1. 从原始借据表bp_collect_loan_src同步数据到bp_collect_loan，同步批次号为batch_no的数据。(同步数据时，每个线程处理数量默认为10000，若是当前批次数据量超过10000，会采用多线程来执行)2. 针对每一个原始借据，数据库里面只有可能有一条与之对应的借据，所以将bp_collect_loan存入数据库的操作采用的是insertOrUpdate操作(任务执行失败后，不会对数据库中的数据造成影响)。3. 借据同步完成之后，需要执行归案任务，就是将多个借据加工成为一个案件，以人为维度进行催收。4. 归案完成之后，需要跑规则引擎来执行分案，通过规则引擎分案之后，会在数据库表bp_collect_divide表里面生成分案记录。5. 将这些分案记录针对案件进行分案(分案记录里面存储了两类，针对个人的分案，针对组的分案)// 使用到的技术点(分布式锁 redis队列)1. 由于任务是部署在多台机器上的，多个进程执行任务时，需要获取分布式锁。项目中采用redis来实现了分布式锁，上锁命令采用set命令，外加是否存在，过期时间参数来实现。而释放锁的命令采用lua脚本来实现，因为会有两步骤操作，首先式判断上锁客户端和释放锁的客户端是否一致（存储在value中），其次是删除该锁对应的key，lua脚本保证了该操作的原子性。2. 在执行归案的过程中，针对每一个案件，需要将该案件分出去，会过规则引擎。而将分案请求交给规则引擎有两种方式，第一种是先将该案件构建成为请求，然后将该请求放到redis的同步队列里面，规则引擎那边从同步队列里面来进行消费。第二种是若同步队列已满，或者放入到同步队列出错，则会将请求直接交给规则引擎来处理。// 技术难点-如何克服","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"项目","slug":"java/项目","permalink":"https://zhilongao.github.io/categories/java/项目/"}]},{"title":"threadpool","date":"2019-08-26T13:20:13.000Z","path":"wiki/threadpool/","text":"线程池 // 创建线程池的工具类Executorspublic class Executors &#123; // 创建一个只有一个工作线程的线程池 public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); &#125; // 创建一个固定数目线程的线程池(核心线程数和最大线程数相同) public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); &#125; // 创建一个cache线程池，核心线程大小为0 public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); &#125; // 线程工厂，负责为线程池中的Worker创建线程-》可以创建个性化的线程 static class DefaultThreadFactory implements ThreadFactory &#123; private static final AtomicInteger poolNumber = new AtomicInteger(1); private final ThreadGroup group; private final AtomicInteger threadNumber = new AtomicInteger(1); private final String namePrefix; DefaultThreadFactory() &#123; SecurityManager s = System.getSecurityManager(); group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup(); namePrefix = \"pool-\" + poolNumber.getAndIncrement() + \"-thread-\"; &#125; public Thread newThread(Runnable r) &#123; // 返回的线程又将Worker做了一层封装,当该线程执行strart方法时,将会调用Worker的run方法 Thread t = new Thread(group, r, namePrefix + threadNumber.getAndIncrement(), 0); if (t.isDaemon()) t.setDaemon(false); if (t.getPriority() != Thread.NORM_PRIORITY) t.setPriority(Thread.NORM_PRIORITY); return t; &#125; &#125; &#125;// jdk定义的线程池public class ThreadPoolExecutor extends AbstractExecutorService &#123; // 核心线程数 private volatile int corePoolSize; // 最大线程数 private volatile int maximumPoolSize; // 阻塞队列 private final BlockingQueue&lt;Runnable&gt; workQueue; // 非工作线程存活时间 private volatile long keepAliveTime; // 创建线程的工厂 private volatile ThreadFactory threadFactory; // 线程池的拒绝策略 private volatile RejectedExecutionHandler handler; // 存储创建好的Worker线程 private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;(); // 主锁,对workers进行操作时会上锁 private final ReentrantLock mainLock = new ReentrantLock(); // 定义线程池内部的工作线程 private final class Worker extends AbstractQueuedSynchronizer implements Runnable&#123; // 当前Worker持有的线程 final Thread thread; // 当前Worker执行的第一个任务 Runnable firstTask; // 记录当前Worker已经完成的任务数量 volatile long completedTasks; Worker(Runnable firstTask) &#123; // 将aqs中的state值由0设置为-1,禁止中断(上锁了) setState(-1); this.firstTask = firstTask; // 调用工厂为当前的Worker创建一个Thread—&gt;传入的是当前this对象 this.thread = getThreadFactory().newThread(this); &#125; // 当前Worker线程启动需要执行的方法，该方法会由内部属性thread调用start方法时触发。 public void run() &#123; runWorker(this); &#125; // 判断线程是否被独占 protected boolean isHeldExclusively() &#123; return getState() != 0; &#125; // 尝试获取锁 protected boolean tryAcquire(int unused) &#123; if (compareAndSetState(0, 1)) &#123; setExclusiveOwnerThread(Thread.currentThread()); return true; &#125; return false; &#125; protected boolean tryRelease(int unused) &#123; setExclusiveOwnerThread(null); setState(0); return true; &#125; public void lock() &#123; acquire(1); &#125; public boolean tryLock() &#123; return tryAcquire(1); &#125; public void unlock() &#123; release(1); &#125; public boolean isLocked() &#123; return isHeldExclusively(); &#125; void interruptIfStarted() &#123; Thread t; if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) &#123; try &#123; t.interrupt(); &#125; catch (SecurityException ignore) &#123; &#125; &#125; &#125; &#125; // Worker线程执行的真正逻辑 final void runWorker(Worker w) &#123; Thread wt = Thread.currentThread(); Runnable task = w.firstTask; w.firstTask = null; w.unlock();//执行任务之前允许被打断 boolean completedAbruptly = true; try &#123; // 当前worker的task不为null或者是阻塞队列不为null,worker线程会一直运行 while (task != null || (task = getTask()) != null) &#123; // 上锁 w.lock(); if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) wt.interrupt(); try &#123; beforeExecute(wt, task); Throwable thrown = null; try &#123; // 调用worker的run方法 task.run(); &#125; catch (RuntimeException x) &#123; thrown = x; throw x; &#125; catch (Error x) &#123; thrown = x; throw x; &#125; catch (Throwable x) &#123; thrown = x; throw new Error(x); &#125; finally &#123; afterExecute(task, thrown); &#125; &#125; finally &#123; task = null; w.completedTasks++; w.unlock(); &#125; &#125; completedAbruptly = false; &#125; finally &#123; processWorkerExit(w, completedAbruptly); &#125; &#125; // 初始化一个线程池 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; &#125; // 1.若是当前工作线程数小于核心线程数, 会去创建一个核心线程。 // 2.若是当前工作线程数大于等于核心线程数，将任务放入到阻塞队列。 // 3.若是阻塞队列已满，会去创建非核心线程。 // 4.若是创建非核心线程也失败，执行拒绝策略。 public void execute(Runnable command) &#123; int c = ctl.get(); if (workerCountOf(c) &lt; corePoolSize) &#123; if (addWorker(command, true)) return; c = ctl.get(); &#125; if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; else if (!addWorker(command, false)) reject(command); &#125; // 1.尝试着将工作线程数加1，workers的个数。 // 2.创建一个Worker线程，并将其加入到workers数组中。 // 3.若是加入到workers数组成功，调用worker的thread的start方法，启动线程。 // 4.线程启动之后，会调用worker的run方法，而run方法又是调用runWorker(this)方法来执行的。 private boolean addWorker(Runnable firstTask, boolean core) &#123; retry: // 自旋 for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); if (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) return false; for (;;) &#123; int wc = workerCountOf(c); if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; if (compareAndIncrementWorkerCount(c)) break retry; c = ctl.get(); if (runStateOf(c) != rs) continue retry; &#125; &#125; boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try &#123; w = new Worker(firstTask); final Thread t = w.thread; if (t != null) &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; int rs = runStateOf(ctl.get()); if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; if (t.isAlive()) throw new IllegalThreadStateException(); // 将创建好的Worker加入到workers数组中 workers.add(w); int s = workers.size(); if (s &gt; largestPoolSize) largestPoolSize = s; workerAdded = true; &#125; &#125; finally &#123; mainLock.unlock(); &#125; if (workerAdded) &#123; t.start(); workerStarted = true; &#125; &#125; &#125; finally &#123; if (! workerStarted) addWorkerFailed(w); &#125; return workerStarted; &#125; &#125;// spring线程池-&gt;ThreadPoolTaskExecutorpublic class ThreadPoolTaskExecutor &#123; private final Object poolSizeMonitor = new Object(); // 核心线程数 private int corePoolSize = 1; // 最大线程数 private int maxPoolSize = 2147483647; // 非核心线程空闲最大存活时间 private int keepAliveSeconds = 60; // 缓存队列容量 private int queueCapacity = 2147483647; // 是否允许核心线程池超时等待(设置为false,当到达一定时间没有任务,线程池会自动关闭) private boolean allowCoreThreadTimeOut = false; private TaskDecorator taskDecorator; private ThreadPoolExecutor threadPoolExecutor; public ThreadPoolTaskExecutor() &#123; &#125; // 因为spring线程池提供了更加灵活的配置，项目中一般使用的是spring的线程池。","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"并发","slug":"java/并发","permalink":"https://zhilongao.github.io/categories/java/并发/"},{"name":"线程池","slug":"java/并发/线程池","permalink":"https://zhilongao.github.io/categories/java/并发/线程池/"}]},{"title":"lock","date":"2019-08-25T06:28:41.000Z","path":"wiki/lock/","text":"前戏java里面提供了两种锁机制，基于jvm层面实现的关键字synchronized和基于jdk层面实现的Lock锁。 synchronized关键字 基本使用：synchronized关键字可以用来修饰静态方法，普通方法，代码块，获取到的锁对象分别为当前类Class对象，当前实例对象和synchronized括号里面的对象。 加锁原理：synchronized加锁是基于对象监视器Monitor的monitorenter和monitorexit。在java中，每个对象都会有一个对象监视器，当synchronized修饰代码块时，在开始位置会加上monitorenter指令，在方法结束和异常处会插入monitorexit指令。当执行monitorentrt指令时，会去获取锁的Monitor对象，若是获取到，执行，获取不到的话，线程阻塞。 synchronized的锁升级 ​ 偏向锁：当线程执行时，会去修改对象的对象头（Mark Word）中线程id，若是修改成功，执行。若是修改不成功，需要将偏向锁升级为轻量级锁。锁升级的过程是，该获取锁的线程通知Mark Word中标识的线程，使其进入暂停状态。 ​ 轻量级锁：争抢锁的线程会去将对象的对象头（Mark Word）拷贝的线程栈中，并将对象头指向该栈（cas操作），若是执行成功，获取到锁，执行代码。若是执行失败，自旋等待其它线程释放锁。 ​ 重量级锁：当自旋超过了一定的时间之后，若是还不能获取到锁，将会升级为重量级锁，线程阻塞。 Lock接口 特性 描述 尝试非阻塞的获取锁 当前线程尝试获取锁，若这一时刻锁没有被其它线程获取到，则成功获取并持有锁。 能被中断的获取锁 获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放。 超时获取锁 在指定的时间之前获取锁，如果过了指定的时间任然无法获取到锁，则返回。 方法名称 描述 void lock() 线程获取锁，当获取到锁后，线程从该方法返回。 void lockInterruptibly() throws InteruptedExecption 与lock方法不同之处在于可以在获取锁的过程中中断当前的线程。 boolean tryLock() 尝试获取锁，获取到返回true，未获取到返回false。 boolean tryLock(long time, TimeUnit unit) throws InteruptedException; 尝试获取锁，下列三种情况下会返回：1.在指定的时间内获取到锁。2.过了超时时间为获取到锁。3.当前线程被中断。 void unlock() 释放锁 Condition newCondition() 获取等待通知组件，只有成功获取到了锁，才能创建该组件 lock和synchronized的区别 ​ 关于加锁和释放锁方式和原理的不同 synchronized是jvm层面提供的关键字，获取锁和释放锁不需要手工干预。synchronized获取锁时会获取锁定对象(静态方法-&gt;类对象，普通方法-&gt;当前对象，代码块-&gt;提供的对象)的对象监视器Monitor。一旦一个线程获取到这个对象的Monitor,其它线程就无法获取。但是同一个线程对这个Monitor可以多次获取（可重入）。对于锁的释放，当方法正常执行结束或者发生异常时，会释放该锁。 lock锁是jdk层面提供的锁，可以基于api执行上锁和解锁操作，操作更加的灵活。Lock接口实现的可重入锁ReentLock，其底层是依赖于AQS实现，AQS内部维护了一个同步队列，获取锁的线程会被加入到这个同步队列上面，等待前一个获取锁的节点释放锁时唤醒。ReentLock提供了多种获取锁的方式，可以在获取锁的时候立即响应中断。 关于等待队列和同步队列的不同 synchronized基于对象监视器，调用底层的wait方法时，会将线程加入到等待队列中，内部只维护了一个等待队列，而调用notify或者notifyAll时，会将唤醒的线程加入到同步队列。 ReentLock内部可以创建多个等待队列，可以调用await方法将获取到锁的线程加入到等待队列，也可以调用singal,singalAll唤醒线程，将其加入到同步队列中。","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"并发","slug":"java/并发","permalink":"https://zhilongao.github.io/categories/java/并发/"},{"name":"锁","slug":"java/并发/锁","permalink":"https://zhilongao.github.io/categories/java/并发/锁/"}]},{"title":"http","date":"2019-08-24T01:51:41.000Z","path":"wiki/http/","text":"对http协议的理解 ​ http协议是一种基于客户端-&gt;服务器模式的协议，客户端发送请求，服务器返回响应。http协议通过uri定位访问的资源。http协议是一种无状态的协议，服务 器无法识别同一浏览器的前后两次请求（为解决无状态,浏览器端引入了cookie机制）。 http响应状态码 状态码 类别 原因短语 1XX Informational（信息性状态码） 接收的请求正在处理 2XX Success（成功状态码） 请求正常处理完毕 3XX Redirection（重定向状态码） 需要进行附加操作以完成请求 4XX Client Error（客户端错误） 服务器无法处理请求 5XX Server Error （服务端错误） 服务器处理请求出错 http请求首部常用字段 Accept：用户代理可处理的媒体类型。 Accept-Encoding：优先的内容编码。 Accept-Language：优先的语言。 Content-Type：实体类型。 跨域问题","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"分布式","slug":"java/分布式","permalink":"https://zhilongao.github.io/categories/java/分布式/"},{"name":"协议","slug":"java/分布式/协议","permalink":"https://zhilongao.github.io/categories/java/分布式/协议/"}]},{"title":"io","date":"2019-08-23T09:43:24.000Z","path":"wiki/io/","text":"1.在jdk1.4，java引入了nio，nio是一种非阻塞io。 在nio中有三个概念 缓冲区(buffer)：java nio中数据的读取和存放需要通过缓冲区。 通道(channel)：可以理解为io中流的概念 ，与流不同的是，一个通道中既可以进行数据的读取，也可以进行数据的写入，而在io模型中，数据的读取和写入会有专门的输入和输出流来进行操作。 选择器(select)：通道可以在选择器上注册相关的事件，而选择器会有一个专门的线程来负责轮询这些事件，当某个写入事件或是读取事件可写或可读时，会交给相应的线程来处理。 通过java nio模拟一个服务端-客户端通信的实例 /** * NIO Server服务 */class NIOServer&#123; // Selector-&gt;注册channel Selector selector = null; // ServerSocketChannel-&gt;服务端channel,类似ServerSocket ServerSocketChannel serverSocketChannel; // 处理selector轮询事件 private ChannelHandle handle; // NIO服务关闭标识 private volatile boolean stop = false; NIOServer(int port) &#123; try &#123; selector = Selector.open(); serverSocketChannel = ServerSocketChannel.open(); // 设置channel为非阻塞模式 serverSocketChannel.configureBlocking(false); // 为channel绑定端口 serverSocketChannel.bind(new InetSocketAddress(port)); // 将channel注册到selector上，监听连接事件 serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT); handle = new ChannelHandle(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 启动服务 * @throws IOException */ public void start() throws IOException &#123; while (!stop) &#123; // 获取到等待处理的IO事件数量 int readyChannels = selector.select(); // 若是等待处理的IO事件数量为0,不处理 if (readyChannels == 0) &#123; continue; &#125; Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator(); // 处理这些SelectionKey while (iterator.hasNext()) &#123; // 获取到该key SelectionKey key = iterator.next(); // 移除该key iterator.remove(); // 分别处理各自事件 if (key.isAcceptable()) &#123; handle.handleAccept(key); &#125; else if (key.isReadable()) &#123; handle.handleRead(key); &#125; else if (key.isWritable()) &#123; handle.handleWrite(key); &#125; &#125; &#125; &#125; // 停止该服务 public void stop() &#123; this.stop = true; &#125;&#125;/** * 针对selector上不同事件的处理类 */class ChannelHandle &#123; /** * 处理连接事件 * @param key * @throws IOException */ public void handleAccept(SelectionKey key) throws IOException &#123; ServerSocketChannel ssc = (ServerSocketChannel) key.channel(); SocketChannel sc = ssc.accept(); sc.configureBlocking(false); sc.register(key.selector(), SelectionKey.OP_READ); &#125; /** * 处理可读事件 * @param key * @throws IOException */ public void handleRead(SelectionKey key) throws IOException &#123; SocketChannel sc = (SocketChannel) key.channel(); // fixme 对读取到的数据进行处理-&gt;相关协议解析 sc.register(key.selector(), SelectionKey.OP_WRITE); &#125; /** * 处理可写事件 * @param key * @throws IOException */ public void handleWrite(SelectionKey key) throws IOException &#123; System.out.println(\"处理写数据\"); // fixme 对输出结果按照相关协议进行封装 String header = \"HTTP/1.1 200 OK\\r\\n\"; StringBuffer result = new StringBuffer(header); result.append(\"Content-Type:application/json\\n\"); result.append(\"\\r\\n\"); result.append(\"hello,world\"); SocketChannel channel = (SocketChannel)key.channel(); ByteBuffer wrap = ByteBuffer.wrap(result.toString().getBytes()); channel.write(wrap); channel.close(); &#125;&#125;// 调用类public class NIOUtil &#123; public static void main(String[] args) &#123; // 启动一个基于NIO的服务 NIOServer nioServer = new NIOServer(8070); try &#123; nioServer.start(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 下面是通过java io的方式来实现的 public class IOUtil &#123; public static void main(String[] args) &#123; IOServer.createServer(); &#125;&#125;class IOServer &#123; private static volatile boolean stop = false; /** * 开启服务 */ static void createServer() &#123; ExecutorService executorService = Executors.newFixedThreadPool(3); ServerSocket serverSocket = null; try &#123; serverSocket = new ServerSocket(8090); System.out.println(\"服务器在端口8090上启动。。。\"); while (!stop) &#123; try &#123; Socket socket = serverSocket.accept(); // 将任务提交给线程池来处理 executorService.execute(new SocketHandle(socket)); &#125; catch (Exception e) &#123; e.printStackTrace(); break; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (serverSocket != null) &#123; serverSocket.close(); &#125; executorService.shutdown(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 关闭服务 */ static void stopServer() &#123; stop = true; &#125;&#125;/** * socket处理线程类 */class SocketHandle implements Runnable &#123; private Socket socket; SocketHandle(Socket socket) &#123; super(); this.socket = socket; &#125; @Override public void run() &#123; // 处理输入 InputStream is = null; InputStreamReader isr = null; BufferedReader br = null; try &#123; is = socket.getInputStream(); isr = new InputStreamReader(is); br = new BufferedReader(isr); String s = null; while ((s = br.readLine()) != null &amp;&amp; s.length() &gt; 0) &#123; System.out.println(s); s = null; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; &#125; // 处理输出 \\r\\n 回车换行 OutputStream os = null; try &#123; os = socket.getOutputStream(); os.write(\"HTTP/1.1 200 OK\\r\\n\".getBytes()); os.write(\"Content-Type:application/json\\n\".getBytes()); os.write(\"\\r\\n\".getBytes()); os.write(\"hello,world\".getBytes()); os.flush(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (socket != null) &#123; try &#123; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"基础","slug":"java/基础","permalink":"https://zhilongao.github.io/categories/java/基础/"},{"name":"io","slug":"java/基础/io","permalink":"https://zhilongao.github.io/categories/java/基础/io/"}]},{"title":"thread","date":"2019-08-21T05:43:50.000Z","path":"wiki/thread/","text":"为什么使用多线程 ​ 更多的处理器核心 更快的响应时间 更好的编程模型 线程的六种状态 状态 状态说明 NEW 初始状态，线程已经被构建，但是没有调用start()方法。 RUNNABLE 线程处于运行状态或者是可运行状态。 BLOCKED 阻塞状态，表示当前线程等待获取锁。 WAITING 等待状态，需要其他线程唤醒。 TIME_WAITING 超时等待状态，需要其他线程唤醒或者过了超时时间自动唤醒。 TERMINATED 终止状态，表示当前线程已经运行结束。 如何查看线程信息 ​ jps:该命令可以获取进程id。 ​ jstack:使用 jstack 进程id，可以查看线程的一些信息。 线程的初始化 private void init(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc, boolean inheritThreadLocals) &#123; if (name == null) &#123; throw new NullPointerException(\"name cannot be null\"); &#125; this.name = name; // 创建的这个线程的父线程就是当前的这个线程 Thread parent = currentThread(); SecurityManager security = System.getSecurityManager(); if (g == null) &#123; if (security != null) &#123; g = security.getThreadGroup(); &#125; if (g == null) &#123; g = parent.getThreadGroup(); &#125; &#125; g.checkAccess(); if (security != null) &#123; if (isCCLOverridden(getClass())) &#123; security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION); &#125; &#125; g.addUnstarted(); // 设置当前线程的线程组信息 this.group = g; // 将daemon priority设置为父线程的相关属性 this.daemon = parent.isDaemon(); this.priority = parent.getPriority(); if (security == null || isCCLOverridden(parent.getClass())) this.contextClassLoader = parent.getContextClassLoader(); else this.contextClassLoader = parent.contextClassLoader; this.inheritedAccessControlContext = acc != null ? acc : AccessController.getContext(); this.target = target; setPriority(priority); if (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != null) this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); this.stackSize = stackSize; tid = nextThreadID();&#125; 如何优雅的终止线程 ​ 使用volidate修饰的变量 中断线程interrupt()方法 在class所在目录下，使用javap -v HelloWorld.class指令可以查看该class的信息 管道输入输出流–&gt;用于线程之间数据的传输，传输媒介为内存 ​ PipedInputStream ​ PipedOutputStram ​ PipedReader ​ PipedWriter","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"并发","slug":"java/并发","permalink":"https://zhilongao.github.io/categories/java/并发/"},{"name":"基础","slug":"java/并发/基础","permalink":"https://zhilongao.github.io/categories/java/并发/基础/"}]},{"title":"springboot","date":"2019-08-21T01:58:17.000Z","path":"wiki/fra-springboot/","text":"springboot三大特性(2.1.6) 自动装配springboot核心注解 @SpringBootApplication。该注解是由下面三个注解组合而成的。 @ComponentScan 默认会去扫描当前类所在包下面的所有类或者所有包，将这些类创建为spring所管理的bean。可以通过添加basePackages或者是basePackageClasses属性来指定扫描的包路径。 @EnableAutoConfiguration 关于META-INF/spring-autoconfigure-metadata.properties文件与META-INF/spring.factories文件 # spring-autoconfigure-metadata.properties#Tue Jun 18 23:47:55 GMT 2019org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration.AutoConfigureAfter=org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfigurationorg.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration.Configuration=org.springframework.boot.autoconfigure.data.neo4j.Neo4jBookmarkManagementConfiguration.Configuration=org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration=org.springframework.boot.autoconfigure.kafka.KafkaAnnotationDrivenConfiguration.Configuration=org.springframework.boot.autoconfigure.influx.InfluxDbAutoConfiguration.ConditionalOnClass=org.influxdb.InfluxDB # spring.factories，类似于 java 或者是 dubbo 中的 spi# PropertySource Loadersorg.springframework.boot.env.PropertySourceLoader=\\org.springframework.boot.env.PropertiesPropertySourceLoader,\\org.springframework.boot.env.YamlPropertySourceLoader# Run Listenersorg.springframework.boot.SpringApplicationRunListener=\\org.springframework.boot.context.event.EventPublishingRunListener 该注解的实现主要依赖于@Import注解引入的AutoConfigurationImportSelector类的selectImports方法。 // 注解定义-》关键点：AutoConfigurationImportSelector类@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(AutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; String ENABLED_OVERRIDE_PROPERTY = \"spring.boot.enableautoconfiguration\"; Class&lt;?&gt;[] exclude() default &#123;&#125;; String[] excludeName() default &#123;&#125;;&#125;// 导入筛选实现类 AutoConfigurationImportSelectorpublic class AutoConfigurationImportSelector implements DeferredImportSelector, BeanClassLoaderAware, ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered &#123; .... // 若是 getAutoConfiguration 方法判断出用户关闭了自动装配，就返回该对象。 private static final AutoConfigurationEntry EMPTY_ENTRY = new AutoConfigurationEntry(); @Override public String[] selectImports(AnnotationMetadata annotationMetadata) &#123; // 1. 判断是否可以导入，若是不可以导入，直接返回一个空数组 &#123;&#125; if (!isEnabled(annotationMetadata)) &#123; return NO_IMPORTS; &#125; // 2. 使用自动装配元信息加载类(AutoConfigurationMetadataLoader)的 loadMetadata 方法加载自动装配元信息。返回的AutoConfigurationMetadata对象包含了一个Properties类型的属性。(具体分析见 AutoConfigurationMetadataLoader的loadMetadata方法。) AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(this.beanClassLoader); // 3. 根据步骤2返回的自动装配元信息(AutoConfigurationMetadata)和 注解元信息(AnnotationMetadata)做进一步处理。 AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(autoConfigurationMetadata,annotationMetadata); // 4. 转化未String数组返回 return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations()); &#125; // 判断是否可以导入的逻辑，若是用户在配置文件中配置了spring.boot.enableautoconfiguration属性未false，则不执行自动装配。默认执行自动装配。 protected boolean isEnabled(AnnotationMetadata metadata) &#123; if (getClass() == AutoConfigurationImportSelector.class) &#123; return getEnvironment().getProperty(EnableAutoConfiguration.ENABLED_OVERRIDE_PROPERTY, Boolean.class, true); &#125; return true; &#125; // 获取自动装配的元素 protected AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata) &#123; // 1. 若是判断出不能自动装配，注解返回一个 AutoConfigurationEntry 空对象 if (!isEnabled(annotationMetadata)) &#123; return EMPTY_ENTRY; &#125; // 2. 获取到 EnableAutoConfiguration 注解的属性值 AnnotationAttributes attributes = getAttributes(annotationMetadata); // 3. 读取候选装配组件-&gt; EnableAutoConfiguration所对应的配置类 List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes); // 4. 对这些配置类去重 configurations = removeDuplicates(configurations); // 5. 获取用户配置的排除项(不自动装配)-&gt; exclude,excludeName以及 spring.autoconfigure.exclude Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes); // 6. 检查需要排除的项是否合法，非法的将抛出异常 checkExcludedClasses(configurations, exclusions); // 7. 将这些排除向从配置中移除 configurations.removeAll(exclusions); // 8. 执行过滤 configurations = filter(configurations, autoConfigurationMetadata); // 9. 触发相关事件 fireAutoConfigurationImportEvents(configurations, exclusions); // 10. 返回 return new AutoConfigurationEntry(configurations, exclusions); &#125; // 读取给定注解元信息AnnotationMetadata的属性AnnotationAttributes protected AnnotationAttributes getAttributes(AnnotationMetadata metadata) &#123; // 1. 获取到自动装配注解 EnableAutoConfiguration 的包名 // 如：org.springframework.boot.autoconfigure.EnableAutoConfiguration String name = getAnnotationClass().getName(); // 2. 获取注解 @EnableAutoConfiguration 的属性值，该注解包含了两个属性 exclude 和 excludeName AnnotationAttributes attributes = AnnotationAttributes.fromMap(metadata.getAnnotationAttributes(name, true)); // 3. 返回注解属性 AnnotationAttributes return attributes; &#125; // 返回 @EnableAutoConfiguration 注解的 Class protected Class&lt;?&gt; getAnnotationClass() &#123; return EnableAutoConfiguration.class; &#125; // 根据注解元信息 AnnotationMetadata 和注解属性 AnnotationAttributes 获取候选组件 protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123; // 调用 SpringFactoriesLoader 类的 loadFactoryNames 方法加载 // 参数值分别为 EnableAutoConfiguration.class 和 ClassLoader，该方法返回的是 // EnableAutoConfiguration 所对应的所有配置类 List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader()); ... // 返回该配置列表 return configurations; &#125; // 返回EnableAutoConfiguration.class protected Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() &#123; return EnableAutoConfiguration.class; &#125; // 返回ClassLoader protected ClassLoader getBeanClassLoader() &#123; return this.beanClassLoader; &#125; // List列表去重-&gt; list转为LinkedHashSet,然后在转为ArrayList protected final &lt;T&gt; List&lt;T&gt; removeDuplicates(List&lt;T&gt; list) &#123; return new ArrayList&lt;&gt;(new LinkedHashSet&lt;&gt;(list)); &#125; // 获取排除的自动装配项 protected Set&lt;String&gt; getExclusions(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123; Set&lt;String&gt; excluded = new LinkedHashSet&lt;&gt;(); // @EnableAutoConfiguration注解的exclude属性值 excluded.addAll(asList(attributes, \"exclude\")); // @EnableAutoConfiguration注解的excludeName属性值 excluded.addAll(Arrays.asList(attributes.getStringArray(\"excludeName\"))); // 在 application.properties配置文件中配置的排除项 excluded.addAll(getExcludeAutoConfigurationsProperty()); return excluded; &#125; protected final List&lt;String&gt; asList(AnnotationAttributes attributes, String name) &#123; String[] value = attributes.getStringArray(name); return Arrays.asList((value != null) ? value : new String[0]); &#125; // 获取配置文件中配置的 spring.autoconfigure.exclude 属性值 private List&lt;String&gt; getExcludeAutoConfigurationsProperty() &#123; if (getEnvironment() instanceof ConfigurableEnvironment) &#123; Binder binder = Binder.get(getEnvironment()); return binder.bind(PROPERTY_NAME_AUTOCONFIGURE_EXCLUDE, String[].class).map(Arrays::asList) .orElse(Collections.emptyList()); &#125; String[] excludes = getEnvironment().getProperty(PROPERTY_NAME_AUTOCONFIGURE_EXCLUDE, String[].class); return (excludes != null) ? Arrays.asList(excludes) : Collections.emptyList(); &#125; // 检查配置的排除项是否合法，需要参数：自动装配列表，排除项列表 private void checkExcludedClasses(List&lt;String&gt; configurations, Set&lt;String&gt; exclusions) &#123; // 1. 创建一个无效的排除项列表 invalidExcludes List&lt;String&gt; invalidExcludes = new ArrayList&lt;&gt;(exclusions.size()); // 2. 循环遍历这些排除项，将无效的放到 invalidExcludes列表中 for (String exclusion : exclusions) &#123; // 排除项无效的判断依据：是对应类加载器加载并且没有包含在 configurations列表中 if (ClassUtils.isPresent(exclusion, getClass().getClassLoader()) &amp;&amp; !configurations.contains(exclusion)) &#123; invalidExcludes.add(exclusion); &#125; &#125; // 3.若是排除项为非空，处理这些排除项 if (!invalidExcludes.isEmpty()) &#123; handleInvalidExcludes(invalidExcludes); &#125; &#125; // 封装非法的排除项，并抛出运行时异常 protected void handleInvalidExcludes(List&lt;String&gt; invalidExcludes) &#123; StringBuilder message = new StringBuilder(); for (String exclude : invalidExcludes) &#123; message.append(\"\\t- \").append(exclude).append(String.format(\"%n\")); &#125; throw new IllegalStateException(String.format( \"The following classes could not be excluded because they are\" + \" not auto-configuration classes:%n%s\", message)); &#125; /*************************执行fileter过滤*******************/ private List&lt;String&gt; filter(List&lt;String&gt; configurations, AutoConfigurationMetadata autoConfigurationMetadata) &#123; // 1. 获取开始的时间(纳秒) long startTime = System.nanoTime(); // 2. 将候选组件转为数组 String[] candidates = StringUtils.toStringArray(configurations); // 3. 创建一个boolean类型的数组，长度为candidates.length boolean[] skip = new boolean[candidates.length]; boolean skipped = false; // 4. 循环遍历这些过滤器 for (AutoConfigurationImportFilter filter : getAutoConfigurationImportFilters()) &#123; // 设置相关的属性值 invokeAwareMethods(filter); // 调用该过滤器的 match 方法，通过参数 candidates 和 autoConfigurationMetadata 来判断是否匹配该过滤器。 boolean[] match = filter.match(candidates, autoConfigurationMetadata); // 遍历 match 列表 for (int i = 0; i &lt; match.length; i++) &#123; // 若是第 i 项需要被过滤，将该项的 skip 设置为 true，并将该项设置为 null, 并将 skipped标识设置为 true if (!match[i]) &#123; skip[i] = true; candidates[i] = null; skipped = true; &#125; &#125; &#125; // 若是没有出现被过滤的，直接返回原始的 if (!skipped) &#123; return configurations; &#125; // 若是有出现被过滤的，将被过滤的去掉，返回未被过滤的 List&lt;String&gt; result = new ArrayList&lt;&gt;(candidates.length); for (int i = 0; i &lt; candidates.length; i++) &#123; if (!skip[i]) &#123; result.add(candidates[i]); &#125; &#125; ... return new ArrayList&lt;&gt;(result); &#125; // 获取自动装配导入过滤器 protected List&lt;AutoConfigurationImportFilter&gt; getAutoConfigurationImportFilters() &#123; // 1. 通过SpringFactoriesLoader加载这些过滤器 // 该版本存在三个过滤器 OnBeanCondition OnClassCondition OnWebApplicationCondition return SpringFactoriesLoader.loadFactories(AutoConfigurationImportFilter.class, this.beanClassLoader); &#125; private void invokeAwareMethods(Object instance) &#123; if (instance instanceof Aware) &#123; if (instance instanceof BeanClassLoaderAware) &#123; ((BeanClassLoaderAware) instance).setBeanClassLoader(this.beanClassLoader); &#125; if (instance instanceof BeanFactoryAware) &#123; ((BeanFactoryAware) instance).setBeanFactory(this.beanFactory); &#125; if (instance instanceof EnvironmentAware) &#123; ((EnvironmentAware) instance).setEnvironment(this.environment); &#125; if (instance instanceof ResourceLoaderAware) &#123; ((ResourceLoaderAware) instance).setResourceLoader(this.resourceLoader); &#125; &#125; &#125; /*************************触发相关事件*******************/ private void fireAutoConfigurationImportEvents(List&lt;String&gt; configurations, Set&lt;String&gt; exclusions) &#123; // 1. 获取到 AutoConfigurationImportListener 列表 List&lt;AutoConfigurationImportListener&gt; listeners = getAutoConfigurationImportListeners(); // 2. 若是列表非空，循环遍历 AutoConfigurationImportListener, 触发事件 if (!listeners.isEmpty()) &#123; // 创建一个 AutoConfigurationImportEvent 事件 AutoConfigurationImportEvent event = new AutoConfigurationImportEvent(this, configurations, exclusions); for (AutoConfigurationImportListener listener : listeners) &#123; invokeAwareMethods(listener); listener.onAutoConfigurationImportEvent(event); &#125; &#125; &#125; ...&#125;/*********************AutoConfigurationMetadataLoader**********************//*自动装配元信息加载类，该类在自动装配方面的作用就是加载了 PATH 路径下面的资源文件，并将其转换为 Properties 文件，该文件会做为 AutoConfigurationMetadata 对象的一个属性(properties)。在自动装配注解 @EnableAutoConfiguration 的拦截装配类 AutoConfigurationImportSelector的 selectImports 方法的第二步，通过自动装配元信息加载类 AutoConfigurationMetadata 的 loadMetadata 方法来加载自动装配的一些元信息。*/final class AutoConfigurationMetadataLoader &#123; // 自动装配元信息的存储路径 protected static final String PATH = \"META-INF/\" + \"spring-autoconfigure-metadata.properties\"; // 根据给定的 ClassLoader 获取到自动装配元信息 public static AutoConfigurationMetadata loadMetadata(ClassLoader classLoader) &#123; return loadMetadata(classLoader, PATH); &#125; // 根据给定的 ClassLoader 和 path 获取自动装配元信息 static AutoConfigurationMetadata loadMetadata(ClassLoader classLoader, String path) &#123; try &#123; // 1. 读取到 PATH 路径下的资源文件，并将其以 key - value 的形式存储在 Properties文件中 Enumeration&lt;URL&gt; urls = (classLoader != null) ? classLoader.getResources(path): ClassLoader.getSystemResources(path); Properties properties = new Properties(); while (urls.hasMoreElements()) &#123; properties.putAll(PropertiesLoaderUtils.loadProperties(new UrlResource(urls.nextElement()))); &#125; // 2. 返回 AutoConfigurationMetadata 对象，该对象持有 Properties:properties属性 return loadMetadata(properties); &#125; catch (IOException ex) &#123; ... &#125; &#125; // 通过给定的一个Properties对象，获取到一个 AutoConfigurationMetadata对象，该方法返回的是实现类为 PropertiesAutoConfigurationMetadata。 static AutoConfigurationMetadata loadMetadata(Properties properties) &#123; return new PropertiesAutoConfigurationMetadata(properties); &#125; // AutoConfigurationMetadata 实现类 PropertiesAutoConfigurationMetadata 的定义，该类持有一个类型为 Properties 的属性 properties。 private static class PropertiesAutoConfigurationMetadata implements AutoConfigurationMetadata &#123; private final Properties properties; PropertiesAutoConfigurationMetadata(Properties properties) &#123; this.properties = properties; &#125; &#125; &#125;/***************************SpringFactoriesLoader*****************//*SpringFactoriesLoader是Spring Framework工厂机制的加载器，该类的作用是加载 FACTORIES_RESOURCE_LOCATION 路径下的资源*/public final class SpringFactoriesLoader &#123; // 资源加载路径 public static final String FACTORIES_RESOURCE_LOCATION = \"META-INF/spring.factories\"; // 缓存，存储每个ClassLoader下的资源 private static final Map&lt;ClassLoader, MultiValueMap&lt;String, String&gt;&gt; cache = new ConcurrentReferenceHashMap&lt;&gt;(); // 通过给定的 Class 和 ClassLoader加载在配置文件中配置的类 // 参数分别为EnableAutoConfiguration和ClassLoader public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) &#123; // 1. 首先获取给定参数 Class&lt;?&gt; factoryClass 的类完全限定名 // 如：org.springframework.boot.autoconfigure.EnableAutoConfiguration String factoryClassName = factoryClass.getName(); // 2. 返回参数 ClassLoader 对应 MultiValueMap 中键为 factoryClassName 的列表 return loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList()); &#125; // 根据给定的ClassLoader，返回一个 MultiValueMap 类型的资源 private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) &#123; // 1. 首先从缓存中获取 MultiValueMap&lt;String, String&gt; result = cache.get(classLoader); if (result != null) &#123; return result; &#125; // 2.若是缓存中加载不到，就去 FACTORIES_RESOURCE_LOCATION 路径加载 try &#123; // 2.1 通过 ClassLoader和路径获取到 URL集合 Enumeration&lt;URL&gt; urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION)); result = new LinkedMultiValueMap&lt;&gt;(); // 2.2 遍历这些URL集合 while (urls.hasMoreElements()) &#123; URL url = urls.nextElement(); UrlResource resource = new UrlResource(url); // 2.3 将其转化为properties文件 Properties properties = PropertiesLoaderUtils.loadProperties(resource); for (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123; String factoryClassName = ((String) entry.getKey()).trim(); for (String factoryName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123; result.add(factoryClassName, factoryName.trim()); &#125; &#125; &#125; // 2.4 将结果放入到缓存中去 cache.put(classLoader, result); return result; &#125; catch (IOException ex) &#123;&#125; &#125; public static &lt;T&gt; List&lt;T&gt; loadFactories(Class&lt;T&gt; factoryClass, @Nullable ClassLoader classLoader) &#123; // 确定使用的ClassLoader ClassLoader classLoaderToUse = classLoader; if (classLoaderToUse == null) &#123; classLoaderToUse = SpringFactoriesLoader.class.getClassLoader(); &#125; // 调用 loadFactoryNames 返回 factoryClass 所对应的配置 List&lt;String&gt; factoryNames = loadFactoryNames(factoryClass, classLoaderToUse); /// 创建一个集合，存放这些 class 的对象 List&lt;T&gt; result = new ArrayList&lt;&gt;(factoryNames.size()); for (String factoryName : factoryNames) &#123; result.add(instantiateFactory(factoryName, factoryClass, classLoaderToUse)); &#125; // 排序后返回结果 AnnotationAwareOrderComparator.sort(result); return result; &#125; // 通过反射实例化 private static &lt;T&gt; T instantiateFactory(String instanceClassName, Class&lt;T&gt; factoryClass, ClassLoader classLoader) &#123; try &#123; Class&lt;?&gt; instanceClass = ClassUtils.forName(instanceClassName, classLoader); if (!factoryClass.isAssignableFrom(instanceClass)) &#123; ... &#125; return (T) ReflectionUtils.accessibleConstructor(instanceClass).newInstance(); &#125; catch (Throwable ex) &#123; ... &#125; &#125;&#125; 关于 AutoConfigurationImportFilter @Order(Ordered.LOWEST_PRECEDENCE)class OnBeanCondition extends FilteringSpringBootCondition implements ConfigurationCondition &#123; ...&#125;@Order(Ordered.HIGHEST_PRECEDENCE)class OnClassCondition extends FilteringSpringBootCondition &#123; ...&#125;@Order(Ordered.HIGHEST_PRECEDENCE + 20)class OnWebApplicationCondition extends FilteringSpringBootCondition &#123; ...&#125;abstract class FilteringSpringBootCondition extends SpringBootCondition implements AutoConfigurationImportFilter, BeanFactoryAware, BeanClassLoaderAware &#123; // match方法，自动装配时会被自动调用 @Override public boolean[] match(String[] autoConfigurationClasses, AutoConfigurationMetadata autoConfigurationMetadata) &#123; ConditionEvaluationReport report = ConditionEvaluationReport.find(this.beanFactory); ConditionOutcome[] outcomes = getOutcomes(autoConfigurationClasses, autoConfigurationMetadata); boolean[] match = new boolean[outcomes.length]; for (int i = 0; i &lt; outcomes.length; i++) &#123; match[i] = (outcomes[i] == null || outcomes[i].isMatch()); if (!match[i] &amp;&amp; outcomes[i] != null) &#123; logOutcome(autoConfigurationClasses[i], outcomes[i]); if (report != null) &#123; report.recordConditionEvaluation(autoConfigurationClasses[i], this, outcomes[i]); &#125; &#125; &#125; return match; &#125;&#125; 关于 @AutoConfigurationPackage 注解 // 关于该注解定义@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@Import(AutoConfigurationPackages.Registrar.class)public @interface AutoConfigurationPackage &#123;&#125;public abstract class AutoConfigurationPackages &#123; private static final String BEAN = AutoConfigurationPackages.class.getName(); static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports &#123; @Override public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &#123; register(registry, new PackageImport(metadata).getPackageName()); &#125; @Override public Set&lt;Object&gt; determineImports(AnnotationMetadata metadata) &#123; return Collections.singleton(new PackageImport(metadata)); &#125; &#125; public static void register(BeanDefinitionRegistry registry, String... packageNames) &#123; if (registry.containsBeanDefinition(BEAN)) &#123; BeanDefinition beanDefinition = registry.getBeanDefinition(BEAN); ConstructorArgumentValues constructorArguments = beanDefinition.getConstructorArgumentValues(); constructorArguments.addIndexedArgumentValue(0, addBasePackages(constructorArguments, packageNames)); &#125; else &#123; GenericBeanDefinition beanDefinition = new GenericBeanDefinition(); beanDefinition.setBeanClass(BasePackages.class); beanDefinition.getConstructorArgumentValues().addIndexedArgumentValue(0, packageNames); beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE); registry.registerBeanDefinition(BEAN, beanDefinition); &#125; &#125; private static String[] addBasePackages(ConstructorArgumentValues constructorArguments, String[] packageNames) &#123; String[] existing = (String[]) constructorArguments.getIndexedArgumentValue(0, String[].class).getValue(); Set&lt;String&gt; merged = new LinkedHashSet&lt;&gt;(); merged.addAll(Arrays.asList(existing)); merged.addAll(Arrays.asList(packageNames)); return StringUtils.toStringArray(merged); &#125;&#125; @SpringBootConfiguration 核心事件 ApplicationEnvironmentPreparedEventApplicationPreparedEventApplicationStartingEventApplicationReadyEventApplicationFailedEvent 系统属性 System:getProperties 环境变量System:getEnv 嵌入式容器 为生产做准备 springboot踩坑记录1. 当我们在springboot的配置文件中将启动端口配置为随机端口时 server.port=0，我们使用下面的方式无法获取到启动的真正端口，该port的值任然为0。@Value(\"$&#123;server.port&#125;\")private int port;可以通过使用下面这种方式来获取真正的启动端口private final Environment environment;public OtherController(Environment environment) &#123; this.environment = environment;&#125;private String getPort() &#123; return environment.getProperty(\"local.server.port\");&#125;","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"框架","slug":"java/框架","permalink":"https://zhilongao.github.io/categories/java/框架/"},{"name":"springboot","slug":"java/框架/springboot","permalink":"https://zhilongao.github.io/categories/java/框架/springboot/"}]},{"title":"bean的创建","date":"2019-08-19T09:04:07.000Z","path":"wiki/fra-spring-xml/","text":"spring在xml驱动的BeanFactory中创建bean的方式有很多种方式。 普通的bean创建普通的bean创建方式一般是在xml文件中直接配置 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd\"&gt; &lt;!-- 配置一个简单的bean --&gt; &lt;bean id=\"mycar\" class=\"com.study.pack.xml.factorybean.Car\"&gt;&lt;/bean&gt; &lt;!-- 配置一个简单的bean,并为其加入name和price属性 --&gt; &lt;bean id=\"mycarB\" class=\"com.study.pack.xml.factorybean.Car\"&gt; &lt;property name=\"name\" value=\"宝马\"/&gt; &lt;property name=\"price\" value=\"2000\"/&gt; &lt;/bean&gt;&lt;/beans&gt; public class Test &#123; public static void main(String[] args) &#123; XmlBeanFactory factory = new XmlBeanFactory(new ClassPathResource(\"factory-bean.xml\")); Car carA = (Car)factory.getBean(\"mycarA\"); Car carB = (Car)factory.getBean(\"mycarB\"); System.out.println(carA); System.out.println(carB); &#125; // 输出结果 // null--0.0 // 宝马--2000.0&#125; @Datapublic class Car &#123; private String name; private double price; @Override public String toString() &#123; return this.name + \"--\" + this.price; &#125;&#125; FactoryBean创建BeanFactoryBean创建bean的不同之处在于增加了一个FactoryBean实现类，该类负责相关bean的创建细节，而在xml中配置的也是该FactoryBean的信息。 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd\"&gt; &lt;!-- 通过指定的FactoryBean创建Bean --&gt; &lt;bean id=\"car\" class=\"com.study.pack.xml.factorybean.CarFactoryBean\"&gt; &lt;property name=\"message\" value=\"比亚迪,20000\"/&gt; &lt;/bean&gt;&lt;/beans&gt; public class FactoryBeanTest &#123; public static void main(String[] args) &#123; XmlBeanFactory factory = new XmlBeanFactory(new ClassPathResource(\"factory-bean.xml\")); Car car = (Car) factory.getBean(\"car\"); // 加上&amp;是只返回该FactoryBean实例 CarFactoryBean carFactoryBean = (CarFactoryBean) factory.getBean(\"&amp;car\"); System.out.println(car); System.out.println(carFactoryBean); &#125; // 输出信息 // 比亚迪--20000.0 // 比亚迪,20000&#125;public class CarFactoryBean implements FactoryBean&lt;Car&gt; &#123; private String message; @Override public Car getObject() throws Exception &#123; Car car = new Car(); String[] messageArray = message.split(\",\"); car.setName(messageArray[0]); car.setPrice(Double.parseDouble(messageArray[1])); return car; &#125; @Override public Class&lt;?&gt; getObjectType() &#123; return Car.class; &#125; @Override public boolean isSingleton() &#123; return true; &#125; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125; @Override public String toString() &#123; return this.message; &#125;&#125; 其它方式创建Bean除了以上两种创建方式之外，spring还可以通过工厂方法来创建实例，工厂方法创建bean实例分两种情况，一种是通过静态方法创建，另一种是通过非静态方法创建。 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd\"&gt; &lt;!-- 静态方法 --&gt; &lt;bean id=\"secondCar\" class=\"com.study.pack.xml.factorybean.SimpleCarFactory\" factory-method=\"getCar\"/&gt; &lt;!-- 非静态方法 --&gt; &lt;bean id=\"firstCar\" factory-bean=\"simpleCarFactory\" factory-method=\"createCar\"/&gt; &lt;bean id=\"simpleCarFactory\" class=\"com.study.pack.xml.factorybean.SimpleCarFactory\"/&gt; &lt;/beans&gt; public class Test &#123; public static void main(String[] args) &#123; XmlBeanFactory factory = new XmlBeanFactory(new ClassPathResource(\"factory-bean.xml\")); Car firstCar = (Car)factory.getBean(\"firstCar\"); Car secondCar = (Car)factory.getBean(\"secondCar\"); System.out.println(firstCar); System.out.println(secondCar); &#125; // 输出 //吉利--200.0 //保时捷--150000.0&#125;public class SimpleCarFactory &#123; // 静态方法 public static Car getCar() &#123; Car car = new Car(); car.setName(\"保时捷\"); car.setPrice(150000); return car; &#125; // 非静态方法 public Car createCar() &#123; Car car = new Car(); car.setName(\"吉利\"); car.setPrice(200); return car; &#125;&#125;","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"框架","slug":"java/框架","permalink":"https://zhilongao.github.io/categories/java/框架/"},{"name":"spring","slug":"java/框架/spring","permalink":"https://zhilongao.github.io/categories/java/框架/spring/"}]},{"title":"基本操作","date":"2019-08-18T02:58:52.000Z","path":"wiki/redis-base/","text":"安装步骤1.安装相关库gcc # yum install gcc2.下载安装包 # wget http://download.redis.io/releases/redis-3.0.0.tar.gz3.解压安装包 # tar zxvf redis-3.0.0.tar.gz4.执行make命令 # cd redis-3.0.0/src # make5.将src目录下的相关文件拷贝到/usr/redis文件夹下 # mkdir /usr/redis # cp redis-server /usr/redis # cp redis-benchmark /usr/redis # cp redis-cli /usr/redis # cp redis.conf /usr/redis6.为redis-server和redis-cli创建软链接 # ln -s /usr/redis/redis-server /usr/bin/redis-server # ln -s /usr/redis/redis-cli /usr/bin/redis-cli 服务启动与关闭# 服务启动1.启动redis # redis-server /usr/redis/redis.conf2.若是需要在后台启动，可以修改redis.conf文件中的daemonize为yes # 服务关闭1. 强制结束程序。使用kill -9 进程的pid，强行终止Redis进程可能会导致redis持久化丢失。2. 正确停止redis的方式是向redis发送shutdown命令(关闭默认端口)。 # redis-cli shutdown cluster集群搭建开启集群 修改配置文件redis.conf中的cluster-enabled yes加入到集群 127.0.0.1:6379&gt; cluster meet 192.168.25.150 6379分配hash槽 [root@localhost redis]# redis-cli -h 192.168.25.147 -p 6379 cluster addslots &#123;0..5000&#125; string基本操作#单个操作 set name value(设置某个key-value) get name(获取某个key) exists name(判断某个key是否存在) del name(删除某个key) expire name seconds(给某个key设置expire) setex name seconds value(设置key的时候同时设置expire) setnx name value(不存在存储,存在不存储)#批量操作 mset name1 value1 name2 value2(批量插入) mget name1 name2(批量获取)#特殊操作 incr key(针对值为整数的情况,value加1) incrby key 5(针对值为整数的情况,value加5)# 使用场景 保存一些JSON序列化的用户对象信息，使用时通过JSON反序列化，一次性的获取一整个用户对象，消耗网络流量。优点是存储消耗低于hash。 list基本操作#基本操作(普通操作) rpush key value1 value2 value3(存储元素) llen key(获取列表元素个数) lpop key(从左边弹出，非阻塞) rpop key(从右边弹出，非阻塞) blpop key timeout(从左边弹出，阻塞，timeout单位为秒) brpop key timeout(从右边弹出，阻塞，timeout单位为秒)# 基本操作(慢操作) lindex key index(获取某个位置上的value) ltrim key start_index end_index(保留start_index到end_index区间内的值,index可为负数,-1表示最后一个) lrange key start_index end_index(返回start_index到end_index区间内的值) # 使用场景 异步队列(rpush lpop) 栈(rpush rpop) hash基本操作#基本操作 hset key filed value(给某个key的字典中存储一个key-value) hgetall key(查看key-value,key和value间隔出现) hlen books(查看key中存储的key-value个数) hget key filed(获取某个key下filed的value值) hmset key filed1 value1 filed2 value2(批量设置key-value) hincrby key filed 1(给某个key的field字段的value加1) #使用场景 存储用户信息-&gt;针对用户信息中的每个字段单独存储，获取用户信息时可以对部分字段单独获取,节省网络流量。但是缺点是存储消耗要高于字符串。 set基本操作#基本操作 sadd key value(集合中添加一个元素) sadd key value1 value2(集合中添加多个元素) smembers key(列出key下面的value列表) sismember key value(查询key下面是否存在value) scard key(获取key的长度) spop key(弹出一个元素) #使用场景 可以用来存储中将用户的id,因为有去重功能，所以可以保证同一个用户不会中将两次。 zset基本操作#基本操作 zadd key score value(添加一个value) zrange key 0 -1(获取key元素列表，按照score排序列出) zrevrange key 0 -1(获取key元素列表，按照score逆序列出) zcard key(返回key中元素个数) zscore key value(返回某个key的score) zrangebyscore key score1 score2(根据分值区间遍历zset) zrangebyscore key -inf score withscore (根据分值区间 (-∞, score] 遍历 zset，同时返回分值。inf 代表 infinite，无穷大的意思。)#使用场景 可以用来存储粉丝列表，value值是粉丝的用户id，score是关注时间。可以对粉丝列表按照关注时间进行排序。 可以用来存储学生的成绩，value值是学生的id, score是考试成绩。可以对成绩按照分数进行排序，就可以获取到它的名次。 sort命令# redis的sort命令可以对列表键 集合键或者有序集合键的值进行排序############## 最简单的排序 sort ########## 插入元素redis&gt; rpush numbers 5 3 1 4 2(integer) 5# 按照插入顺序排列的列表元素redis&gt;lrange numbers 0 -1# 元素的输出顺序为 \"5\" \"3\" \"1\" \"4\" \"2\"# 按值从小到大有序排列的列表元素(默认升序排列asc)redis&gt; sort numbers# 元素的输出顺序为 \"1\" \"2\" \"3\" \"4\" \"5\"# 按值从大到小有序排列的列表元素redis&gt; sort numbers desc# 元素的输出顺序为 \"5\" \"4\" \"3\" \"2\" \"1\"############ 使用 sort和alpha选项对字符串进行排序######### 插入元素reids&gt; sadd alphabet a b c d e f g# 乱序排列的集合元素redis&gt; smembers alphabet# 输出顺序为 \"d\" \"a\" \"c\" \"b\" \"g\" \"e\" \"f\"# 集合元素排序，使用alpha，asc升序排列redis&gt; sort alphabet alpha# 输出顺序为 \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\"# 集合元素排序，使用alpha，desc降序排列redis&gt; sort alphabet alpha desc# 输出顺序为 \"g\" \"f\" \"e\" \"d\" \"c\" \"b\" \"a\"############ 使用sort和by选项对元素排序 ############# 插入元素redis&gt; zadd test-result 3.0 jack 3.5 peter 4.0 tom(integer) 3# 普通输出，按照元素的分值排序redis&gt; zrange test-result 0 -1# 输出顺序为 \"jack\" \"peter\" \"tom\"# 为各个元素设置序号redis&gt; mset peter_number 1 tom_number 2 jack_number 3ok# 以序号为权重，对集合中的元素进行排序redis&gt; sort test-result by *_number# 输出顺序为 \"peter\" \"tom\" \"jack\" scan命令// scan命令的使用// scan命令提供了三个参数,第一个参数是cursor整数值，第二个是key的正则模式，第三个是遍历的limit hint。第一次遍历时，cursor值为0，然后将返回结果中第一个整数值作为下一次遍历的cursor。一直遍历到返回的cursor值为0时结束。// 可以同过java的jedis客户端插入一些keyint count = 10000;Jedis jedis = new Jedis(\"192.168.25.150\", 6379);for (int i = 0; i &lt; count; i++) &#123; jedis.set(\"key\" + i, i + \"\");&#125;// 下面是redis-cli操作127.0.0.1:6379&gt; scan 0 match key99* count 10001) \"10904\"2) 1) \"key9987\" 2) \"key9924\" 3) \"key9992\" 4) \"key9941\" 5) \"key9901\" 6) \"key9945\" 7) \"key9984\" 8) \"key9903\" 127.0.0.1:6379&gt; scan 10904 match key99* count 10001) \"14028\"2) 1) \"key9989\" 2) \"key992\" 3) \"key9997\" 4) \"key9968\" 5) \"key996\" 6) \"key9958\" //下面是java客户端操作代码段String cursor = \"0\";ScanParams scanParams = new ScanParams();scanParams.match(\"key99*\");scanParams.count(1000);while (true) &#123; ScanResult&lt;String&gt; result = jedis.scan(cursor, scanParams); List&lt;String&gt; resultList = result.getResult(); for (String resultStr : resultList) &#123; System.out.print(resultStr + \"\\t\"); &#125; System.out.println(\"\\n--------------\"); String stringCursor = result.getStringCursor(); // 当游标为再次为0时,表示已经遍历完毕,直接跳出循环 if (stringCursor.equals(\"0\")) &#123; break; &#125; else &#123; cursor = stringCursor; &#125;&#125;","tags":[],"categories":[{"name":"数据库","slug":"数据库","permalink":"https://zhilongao.github.io/categories/数据库/"},{"name":"redis","slug":"数据库/redis","permalink":"https://zhilongao.github.io/categories/数据库/redis/"}]},{"title":"HashMap","date":"2019-08-16T14:01:46.000Z","path":"wiki/ans-hashmap-source/","text":"1.HashMap的数据结构 在jdk1.7中基于数组+链表,在jdk1.8中基于数组+链表+红黑树 2.HashMap的put方法的过程 a.首先判断当前的数组是否被初始化,若是没有被初始化,调用resize方法初始化 b.通过key的hash值和数组长度计算出该元素在数组中的位置 c1.若是数组上没有元素,构建Node节点,存储该元素 c21.若是该数组上有元素,且第一个节点的key与要存储的key相等,用变量保存该节点。 c22.若是该数组上有元素,且第一个节点的key与要存储的key不相等,需要判断该节点类型。 若是该节点属于红黑树,将元素插入到红黑树。 若是该节点属于链表,循环遍历链表,若是没有遇到key相同的,将key-value创建称为节点,插入到链表的尾部。判断是否需要转成红黑树，若是需要，将链表转成红黑树。 d.前面的操作中，若是找到与key相同的节点,根据条件判断是否需要覆盖,若是需要覆盖,直接修改原有节点的value。 f.将元素的个数size加1并判断是否需要扩容,若是需要扩容,调用resize方法扩容。 3.HashMap的resize方法 resize方法涉及到两个大的步骤,首先是确定新数组的大小已经下次的扩容时机，新数组大小为原有数组大小的两倍，扩容变量也扩大为原有的两倍。其次是将原有数组的元素迁移至新的数组中,其中数组元素只会在两个地方，一个在[原下标]的地方，另一个在[原下标+原容量]的位置。","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"源码","slug":"java/源码","permalink":"https://zhilongao.github.io/categories/java/源码/"}]},{"title":"jvm","date":"2019-08-16T04:51:03.000Z","path":"wiki/jvm/","text":"jvm的运行时数据区 堆:java垃圾回收的主要区域，唯一存在的价值就是存放对象实例，几乎所有的对象实例都会在这里分配内存。从垃圾回收的角度分为新生代和老年代。在细分一点可以划分为Eden空间,From Survivor空间,To Survivor空间。若是在堆中没有完成实例分配，并且堆也无法再扩展时，就会抛出OutOfMemoryError异常。 方法区:用于存储已经被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。当方法区无法满足内存分配的需求时，将会抛出OutOfMemoryError异常。 虚拟机栈:描述的是java方法执行的内存模型，每个方法执行时都会创建一个栈帧，栈帧中用于存储局部变量表，操作数栈，动态链接，方法出口等信息。当线程申请的栈深度大于虚拟机所允许的栈深度，将抛出StackOverflowError异常。若是虚拟机动态扩展时无法申请到足够的内存，将会抛出OutOfMemoryError异常。 程序计数器:记录当前线程执行的字节码指令的行号，不会发生OutOfMemoryError。 本地方法栈:用于执行非java方法的内存模型，也会发生StackOverflowError和OutOfMemoryError异常。 jvm垃圾回收考虑的三个问题 回收哪些对象 什么时候回收这些对象 怎么回收这些对象 jvm垃圾回收算法 标记清除：会有内存碎片 标记整理：没有内存碎片，适合新生代对象的回收 复制算法：需要留出一部分的内存空间，利用率不高 分代收集算法：新生代死亡对象多，采用复制算法。老年代死亡对象少，采用标记整理或标记清除。 jvm垃圾收集器 ​ 新生代垃圾收集器 ​ 老年代垃圾收集器","tags":[],"categories":[{"name":"java","slug":"java","permalink":"https://zhilongao.github.io/categories/java/"},{"name":"基础","slug":"java/基础","permalink":"https://zhilongao.github.io/categories/java/基础/"},{"name":"jvm","slug":"java/基础/jvm","permalink":"https://zhilongao.github.io/categories/java/基础/jvm/"}]},{"title":"面试题","date":"2019-08-15T12:56:11.000Z","path":"wiki/mysql/","text":"1.char(32)和varchar(32)的区别 (1):char和varchar都是数据库定义字符串类型的数据格式,char是一种定长度的类型,varchar是一种可变长度的类型。 (2):char(32)表示定义了当前字段所占用的存储空间为32个字符,不管字段长度是否达到32,占用的空间是不变的。而varchar(32)表示定义了当前字段所能够占用的最大存储空间是32个字符,实际占用空间是字段的大小。 (3):就存储效率而言,定长的char类型由于一开始就定义好了字段占用空间,不需要根据字段的长度在去申请空间,故效率相对较高,但是在占用空间上就没有varchar有优势。而varchar由于根据字段长度调整空间占用,故空间消耗较小,但是存储效率不高。 2.sql注入,如何避免sql注入概念: 所谓sql注入, 就是攻击者将sql命令插入到web表单的输入域或者是页面请求的查询字符串，欺骗服务器执行恶意的sql命令。(某些表单中的输入命令被直接用来构造(或影响)sql命令，或者是构成存储过程的输入参数, 这类表单特别容易受到sql注入式攻击)。 如何避免: (1): mybatis中多使用[#{param}],尽量避免使用[${param}],原因在于[${param}]会直接参与sql编译,容易造成sql攻击。 3.数据库的三大范式 第一范式: 每一列都是一个不可再分割的属性值,确保每一列的原子性(规范列)。 第二范式: 在满足第一范式的要求下，每一行数据只做一件事(规范行)。 第三范式: 在满足第二范式的要求下，确保数据表中的每一列数据都和主键直接相关,而不能够间接相关。","tags":[],"categories":[{"name":"数据库","slug":"数据库","permalink":"https://zhilongao.github.io/categories/数据库/"},{"name":"mysql","slug":"数据库/mysql","permalink":"https://zhilongao.github.io/categories/数据库/mysql/"}]}]}