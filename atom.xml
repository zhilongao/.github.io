<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zl&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhilongao.github.io/"/>
  <updated>2019-09-19T12:46:39.986Z</updated>
  <id>https://zhilongao.github.io/</id>
  
  <author>
    <name>gaozhilong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ReentrantLock</title>
    <link href="https://zhilongao.github.io/wiki/reentlock-source-analysis/"/>
    <id>https://zhilongao.github.io/wiki/reentlock-source-analysis/</id>
    <published>2019-09-18T12:31:57.000Z</published>
    <updated>2019-09-19T12:46:39.986Z</updated>
    
    <content type="html"><![CDATA[<hr><ol><li>在<code>ReentrantLock</code>类内部有一个属性，<code>Sync:sync</code>，该属性对应的类是定义在<code>ReentrantLock</code>内部的一个抽象静态内部类。<code>ReentrantLock</code>内部又为其定义了两个子类<code>NonfairSync</code>和<code>FairSync</code>。根据类的名字便可以猜测到非公平与公平之分。我们通过api使用<code>ReentrantLock</code>类时，会调用其构造函数创建一个该类型的对象，构造函数可传参数<code>true|false</code>，确定创建公平或非公平锁。若没传递参数，会默认创建非公平锁。</li><li>当我们调用<code>ReentrantLock:lock</code>方法或是<code>ReentrantLock:unlock</code>方法时，<code>ReentrantLock</code>会委托<code>Sync</code>的实现类<code>NonfairSync</code>或者<code>FairSync</code>来执行具体上锁和释放锁的逻辑。</li></ol><hr><ol start="3"><li><p><code>NonfairSync</code>与<code>FairSync</code>的区别在于上锁逻辑的不同。</p><p>3.1 <code>NonfairSync:lock</code>方法在执行时，首先会通过CAS操作直接修改锁状态<code>state</code>的值，若是执行成功，则成功获取到锁，若是执行失败，调用<code>AbstractQueuedSynchronizer:acquire(1)</code>方法来执行普通的上锁逻辑。<code>FairSync:lock</code>方法在执行时，直接调用 <code>AbstractQueuedSynchronizer:acquire(1)</code>方法来执行普通的上锁逻辑。</p><p>3.2   <code>NonfairSync:tryAcquire</code>与<code>FairSync:tryAcquire</code>方法也能体现出非公平与公平的区别。 首先是<code>NonfairSync:tryAcquire</code>方法内部会调用其父类的<code>Sync:nonfairTryAcquire</code>方法，该方法语义为非公平尝试获取。具体逻辑是，首先判断锁的状态，若是没有线程获取到锁，则执行通过CAS操作修改锁状态，若是成功返回<code>true</code>。若是未成功，则会继续判断当前获取锁的线程是否为当前线程，若是当前线程，将锁状态值加上方法传入的值，并将锁状态值更新，返回<code>true</code>，否则返回<code>false</code>。 而<code>FairSync:tryAcquire</code>方法的执行逻辑是，判断是否已经有线程等待获取锁，若是有线程等待获取锁，则直接返回<code>false</code>。若是没有线程等待获取锁，通过<code>CAS</code>操作尝试获取锁，成功返回<code>true</code>。若是没有成功，继续判断当前获取锁的线程是否为当前线程，是则执行可重入锁的逻辑，否则返回<code>false</code>。</p></li></ol><hr><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="comment">// 负责执行lock或者是unlock方法的委托对象，定义了两个实现类 NonfairSync 和 FairSync</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"><span class="comment">// 构造方法，默认初始化非公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 通过传入true或者false,初始化公平锁或是非公平锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// lock逻辑会交给Sync的实现类的lock方法来执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.lock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// unlock逻辑会交给Sync的实现类的release方法来执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 对于普通的 tryLock方法，会直接调用非公平尝试获取锁的方法 nonfairTryAcquire</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.nonfairTryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 静态抽象类，负责执行 ReentrantLock 的 lock方法与unlock方法的具体逻辑</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取锁，抽象方法，由具体的子类来实现</span></span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 非公平尝试获取锁 </span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 尝试释放锁</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                free = <span class="keyword">true</span>;</span><br><span class="line">                setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 非公平锁实现类 NonfairSync，实现了 lock 方法和 tryAcquire 方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 公平锁实现类 FairSync，实现了 lock 方法和 tryAcquire 方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>上面分析了<code>ReentrantLock</code>以及它的内部类<code>NonfairSync</code>和<code>FairSync</code>实现获取锁和释放锁的逻辑，他们在<code>lock</code>方法中都调用了<code>acquire(1)</code>方法，这个方法是由<code>AbstractQueuedSynchronizer</code>这个父类来实现的。在<code>acquire</code>方法内部其实是调用了三个方法，并且是依次调用的。</p><hr><p>首先是调用<code>tryAcquire</code>方法，这个方法在该类中是一个未实现的方法，具体逻辑可以由其子类来实现，<code>NonfairSync</code>和<code>FairSync</code>都实现了这个方法。<code>NonfairSync:tryAcquire</code>实现逻辑，首先会去判断当前<code>state</code>的状态，若是该属性的状态值为<code>0</code>，则通过<code>CAS</code>操作修改该状态的值，修改成功返回<code>true</code>，否则执行进一步的判断。判断当前获取锁的线程是否为当前线程，若是当前线程，执行可重入锁的逻辑（给state设置一个新的值），并返回<code>true</code>，否则返回<code>false</code>。<code>FairSync:tryAcquire</code>实现逻辑首先是会去判断有没有线程在等待获取锁，若是没有线程在等待获取锁，通过<code>CAS</code>操作修改<code>state</code>值获取锁，成功返回<code>true</code>。否则会进一步判断当前获取到锁的线程是否为当前线程，若是当前线程，执行可重入锁的枷锁逻辑，否则返回<code>false</code>。</p><hr><p>若是上述步骤方法执行的结果返回<code>true</code>，表示上锁成功，直接结束。若是上述方法执行结果返回<code>false</code>，表示上锁失败，执行下一个方法<code>addWaiter</code>，该方法的逻辑是将当前线程构建成为一个节点，并尝试将该节点加入到同步队列的尾部，最后返回该节点。节点返回后，会作为<code>acquireQueued</code>方法的参数，并执行该方法。</p><hr><p><code>acquireQueued</code>方法的执行逻辑，在自旋逻辑中，获取传入节点的前一个节点<code>prev</code>，若是<code>prev==head</code>，尝试获取锁，若是获取锁成功，直接返回中断标识，结束方法的执行。若是<code>prev!=head</code>，<code>shouldParkAfterFailedAcquire</code>方法会被调用，判断当前线程是否需要休眠，若是需要休眠，调用<code>parkAndCheckInterrupt</code>方法休眠线程并检查中断标识，返回<code>true</code>时，会将中断标识设置为<code>true</code>。该方法会一直停留在自旋中，直到满足跳出条件跳出循环。</p><hr><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 同步队列头节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line">    <span class="comment">// 同步队列尾节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line">    <span class="comment">// 锁状态标识</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 该方法首先会去调用未实现的 tryAcquire 方法（该方法具体逻辑由子类实现）。若是该方法的返回值为false，执行 addWaiter 方法，并将该方法的返回值作为 acquireQueued 方法的参数来执行此方法。若是该方法返回 true。执行 selfInterrupt 方法中断当前线程。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将当前线程创建成为一个节点，并将该节点添加到同步队列的尾部。若是不成功，执行自旋操作，执行成功为止。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        Node pred = tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;在&lt;code&gt;ReentrantLock&lt;/code&gt;类内部有一个属性，&lt;code&gt;Sync:sync&lt;/code&gt;，该属性对应的类是定义在&lt;code&gt;ReentrantLock&lt;/code&gt;内部的一个抽象静态内部类。&lt;code&gt;ReentrantLo
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="源码" scheme="https://zhilongao.github.io/categories/java/%E6%BA%90%E7%A0%81/"/>
    
    
  </entry>
  
  <entry>
    <title>监听器模式</title>
    <link href="https://zhilongao.github.io/wiki/design-pattern-listener/"/>
    <id>https://zhilongao.github.io/wiki/design-pattern-listener/</id>
    <published>2019-09-13T02:58:12.000Z</published>
    <updated>2019-09-13T06:23:28.871Z</updated>
    
    <content type="html"><![CDATA[<h6 id="监听器模式"><a href="#监听器模式" class="headerlink" title="监听器模式"></a><code>监听器模式</code></h6><p>针对监听器模式，jdk提供了<code>EventListener</code>接口和<code>EventObject</code>类，分别定义事件监听器和事件对象。下面是通过扩展这两个接口实现一个简单的事件监听器模式。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/13 11:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 事件源</span></span><br><span class="line">        MyEventSource eventSource = <span class="keyword">new</span> MyEventSource();</span><br><span class="line">        <span class="comment">// 创建事件监听器-&gt;处理EventObject</span></span><br><span class="line">        StartEventListener startEventListener = <span class="keyword">new</span> StartEventListener();</span><br><span class="line">        ClosedEventListener closedEventListener = <span class="keyword">new</span> ClosedEventListener();</span><br><span class="line">        <span class="comment">// 添加事件监听器</span></span><br><span class="line">        eventSource.addEventListener(startEventListener);</span><br><span class="line">        eventSource.addEventListener(closedEventListener);</span><br><span class="line">        <span class="comment">// 创建事件对象</span></span><br><span class="line">        EventObject startEventObject = <span class="keyword">new</span> EventObject(<span class="string">"start"</span>);</span><br><span class="line">        EventObject closedEventObject = <span class="keyword">new</span> EventObject(<span class="string">"closed"</span>);</span><br><span class="line">        <span class="comment">// 事件源-&gt;通知事件监听者来处理</span></span><br><span class="line">        eventSource.notifyListenerEvents(startEventObject);</span><br><span class="line">        eventSource.notifyListenerEvents(closedEventObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/13 11:00</span></span><br><span class="line"><span class="comment"> * 扩展的监听器接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyEventListener</span> <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理EventObject</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleEvent</span><span class="params">(EventObject event)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/13 11:21</span></span><br><span class="line"><span class="comment"> * 启动事件监听器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartEventListener</span> <span class="keyword">implements</span> <span class="title">MyEventListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleEvent</span><span class="params">(EventObject event)</span> </span>&#123;</span><br><span class="line">        Object source = event.getSource();</span><br><span class="line">        <span class="keyword">if</span> (source.equals(<span class="string">"start"</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"context has start!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/13 11:24</span></span><br><span class="line"><span class="comment"> * 关闭事件监听器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClosedEventListener</span> <span class="keyword">implements</span> <span class="title">MyEventListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleEvent</span><span class="params">(EventObject event)</span> </span>&#123;</span><br><span class="line">        Object source = event.getSource();</span><br><span class="line">        <span class="keyword">if</span> (source.equals(<span class="string">"closed"</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"context has closed!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/13 11:03</span></span><br><span class="line"><span class="comment"> * 事件源-&gt;添加 删除 通知</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEventSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听器列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Vector&lt;EventListener&gt; listeners = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册监听器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> eventListener</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEventListener</span><span class="params">(EventListener eventListener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!listeners.contains(eventListener)) &#123;</span><br><span class="line">            listeners.add(eventListener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除监听器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> eventListener</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeEventListener</span><span class="params">(EventListener eventListener)</span> </span>&#123;</span><br><span class="line">        listeners.remove(eventListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收外部的事件-&gt;将事件交给事件监听者来处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyListenerEvents</span><span class="params">(EventObject event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (EventListener eventListener : listeners) &#123;</span><br><span class="line">            ((MyEventListener)eventListener).handleEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="jdk中监听器模式的实现"><a href="#jdk中监听器模式的实现" class="headerlink" title="jdk中监听器模式的实现"></a><code>jdk中监听器模式的实现</code></h6><p>jdk针对监听器模式并未定义太多的实现，只是定义了一个<code>EventListener</code>接口和一个<code>EventObject</code>类，我们可以扩展<code>EventListener</code>接口来定义处理<code>EventObject</code>的方法。在<code>EventObject</code>中有一个属性<code>Object:source</code>，该属性可以在定义<code>EventObject</code>的时候，传入一些参数值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventObject</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">transient</span> Object  source;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EventObject</span><span class="params">(Object source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (source == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"null source"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.source = source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> source;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">"[source="</span> + source + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="spring中监听器模式的实现"><a href="#spring中监听器模式的实现" class="headerlink" title="spring中监听器模式的实现"></a><code>spring中监听器模式的实现</code></h6><p>在spring中定义了<code>ApplicationListener</code>接口和<code>ApplicationEvent</code>类，其中<code>ApplicationListener</code>接口实现了jdk中定义的<code>EventListener</code>接口，并定义了<code>onApplicationEvent</code>方法来处理事件，并且每个<code>ApplicationListener</code>只会处理特定的事件。<code>ApplicationEvent</code>类继承了jdk中定义的<code>EventObject</code>类，用以定义事件对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 扩展的事件监听器接口-&gt;采用泛型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationListener</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span>&gt; <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(E event)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展的EventObject</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationEvent</span> <span class="keyword">extends</span> <span class="title">EventObject</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7099057708183571937L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timestamp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ApplicationEvent</span><span class="params">(Object source)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(source);</span><br><span class="line"><span class="keyword">this</span>.timestamp = System.currentTimeMillis();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getTimestamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.timestamp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="spring中监听器模式的使用"><a href="#spring中监听器模式的使用" class="headerlink" title="spring中监听器模式的使用"></a><code>spring中监听器模式的使用</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/13 11:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        <span class="comment">// 注册监听器</span></span><br><span class="line">        context.addApplicationListener(<span class="keyword">new</span> ApplicationListener&lt;MyApplicationEvent&gt;() &#123;</span><br><span class="line">            <span class="comment">// 接收到事件</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(MyApplicationEvent event)</span> </span>&#123;</span><br><span class="line">                System.out.println(event.getSource());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        context.refresh();</span><br><span class="line">        <span class="comment">// 发布事件</span></span><br><span class="line">        context.publishEvent(<span class="keyword">new</span> MyApplicationEvent(<span class="string">"study spring！"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApplicationEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span></span>&#123;</span><br><span class="line">    MyApplicationEvent(Object source) &#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;监听器模式&quot;&gt;&lt;a href=&quot;#监听器模式&quot; class=&quot;headerlink&quot; title=&quot;监听器模式&quot;&gt;&lt;/a&gt;&lt;code&gt;监听器模式&lt;/code&gt;&lt;/h6&gt;&lt;p&gt;针对监听器模式，jdk提供了&lt;code&gt;EventListener&lt;/code&gt;接口和&lt;c
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="设计模式" scheme="https://zhilongao.github.io/categories/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>观察者模式</title>
    <link href="https://zhilongao.github.io/wiki/design-pattern-observer/"/>
    <id>https://zhilongao.github.io/wiki/design-pattern-observer/</id>
    <published>2019-09-13T01:54:53.000Z</published>
    <updated>2019-09-13T02:30:50.039Z</updated>
    
    <content type="html"><![CDATA[<h6 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a><code>观察者模式</code></h6><p>可以通过jdk中提供的<code>Observable</code>类和<code>Observer</code>接口来实现观察者模式。下面通过简单的会员订阅频道，然后频道定期的去给订阅的会员推送消息，展示jdk中观察者模式的使用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/13 9:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 科技频道</span></span><br><span class="line">        TechnologyChannel technologyChannel = <span class="keyword">new</span> TechnologyChannel();</span><br><span class="line">        technologyChannel.setTitle(<span class="string">"科技频道"</span>);</span><br><span class="line">        <span class="comment">// 用户</span></span><br><span class="line">        Members member1 = <span class="keyword">new</span> Members();</span><br><span class="line">        Members member2 = <span class="keyword">new</span> Members();</span><br><span class="line">        <span class="comment">// 用户订阅该科技频道</span></span><br><span class="line">        technologyChannel.addObserver(member1);</span><br><span class="line">        technologyChannel.addObserver(member2);</span><br><span class="line">        <span class="comment">// 给会员定时推送消息</span></span><br><span class="line">        String[] messages = &#123;<span class="string">"华为"</span>, <span class="string">"小米"</span>, <span class="string">"苹果"</span>&#125;;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) &#123;</span><br><span class="line">            <span class="comment">// 创建消息</span></span><br><span class="line">            NotifyMessage message = <span class="keyword">new</span> NotifyMessage();</span><br><span class="line">            String id = UUID.randomUUID().toString();</span><br><span class="line">            message.setId(id);</span><br><span class="line">            message.setCreateTime(System.currentTimeMillis());</span><br><span class="line">            message.setTitle(<span class="string">"手机"</span>);</span><br><span class="line">            message.setContent(messages[random.nextInt(<span class="number">3</span>)] + <span class="string">"又出新机，赶快来订购吧!"</span>);</span><br><span class="line">            <span class="comment">// 评到发送消息给订阅的会员</span></span><br><span class="line">            technologyChannel.setChanged();</span><br><span class="line">            technologyChannel.notifyObservers(message);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/13 9:14</span></span><br><span class="line"><span class="comment"> * 频道</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TechnologyChannel</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setChanged();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/13 9:13</span></span><br><span class="line"><span class="comment"> * 会员</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Members</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> TechnologyChannel) &#123;</span><br><span class="line">            TechnologyChannel channel = (TechnologyChannel)o;</span><br><span class="line">            String title = channel.getTitle();</span><br><span class="line">            NotifyMessage message = (NotifyMessage)arg;</span><br><span class="line">            System.out.println(<span class="string">"channel:"</span> + title);</span><br><span class="line">            System.out.println(<span class="string">"message:"</span> + message);</span><br><span class="line">            System.out.println(<span class="string">"======================="</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/13 9:28</span></span><br><span class="line"><span class="comment"> * 消息通知</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotifyMessage</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> Long createTime;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="jdk中观察者模式的实现"><a href="#jdk中观察者模式的实现" class="headerlink" title="jdk中观察者模式的实现"></a><code>jdk中观察者模式的实现</code></h6><ol><li>观察者（类似订阅模式中的订阅者）。jdk中定义了一个公共的接口<code>Observer</code>，里面定义了一个<code>update</code>方法，该方法可以接收被观察者对象和一个参数对象。我们可以通过实现该接口，重写<code>update</code>方法来实现观察者的逻辑。</li><li>被观察者（类似订阅模式中的被订阅者）。jdk中定义了一个类<code>Observable</code>，可以实现添加，移除，通知观察者。该类里面有两个属性<code>boolean:changed</code>和<code>Vector:obs</code>。当我们执行<code>addObserver</code>方法来添加观察者时，若是该观察者还未被加入到<code>Vector:obs</code>中，会将观察者加入到该集合。当我们执行<code>notifyObservers</code>方法来通知观察者时，只有<code>changed</code>属性为<code>true</code>时，才会依次调用观察者的<code>update</code>方法。若是该值为<code>true</code>，在调用观察者的<code>update</code>方法之前，又会将该值设置为<code>false</code>。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> Vector&lt;Observer&gt; obs;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Observable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obs = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!obs.contains(o)) &#123;</span><br><span class="line">            obs.addElement(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知所有的观察者，可以传递一个参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">        Object[] arrLocal;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 若是状态未变化，不做任何事情</span></span><br><span class="line">            <span class="keyword">if</span> (!changed) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将Vector转化为一个数组</span></span><br><span class="line">            arrLocal = obs.toArray();</span><br><span class="line">            <span class="comment">// 将changed设置为false</span></span><br><span class="line">            clearChanged();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 循环遍历Observer数组，调用其update方法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arrLocal.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">            ((Observer)arrLocal[i]).update(<span class="keyword">this</span>, arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;观察者模式&quot;&gt;&lt;a href=&quot;#观察者模式&quot; class=&quot;headerlink&quot; title=&quot;观察者模式&quot;&gt;&lt;/a&gt;&lt;code&gt;观察者模式&lt;/code&gt;&lt;/h6&gt;&lt;p&gt;可以通过jdk中提供的&lt;code&gt;Observable&lt;/code&gt;类和&lt;code&gt;Obs
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="设计模式" scheme="https://zhilongao.github.io/categories/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>分布式配置</title>
    <link href="https://zhilongao.github.io/wiki/spring-cloud-config/"/>
    <id>https://zhilongao.github.io/wiki/spring-cloud-config/</id>
    <published>2019-09-12T03:55:17.000Z</published>
    <updated>2019-09-15T07:48:44.405Z</updated>
    
    <content type="html"><![CDATA[<h6 id="分布式配置"><a href="#分布式配置" class="headerlink" title="分布式配置"></a><code>分布式配置</code></h6><hr><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">相关产品</span><br><span class="line">国内：Disconf(百度)Apollo(携程)Nacos(阿里)</span><br><span class="line">国外: Spring-Cloud-Config  Netfix Archaius</span><br></pre></td></tr></table></figure><hr><h6 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a><code>客户端</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关于配置项的刷新-&gt;主动刷新(拉的模式)</span></span><br><span class="line"><span class="number">1</span>. 客户端可以通过接口 http:<span class="comment">//127.0.0.1:8082/actuator/refresh 来主动刷新配置(post方法) ，但是该接口的调用需要修改配置文件里面的值。</span></span><br><span class="line">management.endpoint.refresh.enabled=<span class="keyword">true</span></span><br><span class="line"><span class="number">2</span>. 当配置项发生变化时，bean里面引用的配置项并未发生变化。需要使用 <span class="meta">@RefreshScope</span> 注解来标记，只有使用该注解标记的类，当配置项发生变化时，引用的配置项才会发生变化。</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span><span class="comment">// (开关 阈值  文案等配置，其它配置可以重启服务器)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;my.name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String myName = <span class="string">"jack-1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/myName"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMyName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">3</span>. 可以配置定时器来每隔指定的时间去主动刷新配置</span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableScheduling</span> <span class="comment">// 开启定时任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigClientApp.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定时刷新配置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ContextRefresher contextRefresher;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Environment environment;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConfigClientApp</span><span class="params">(ContextRefresher contextRefresher, Environment environment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.contextRefresher = contextRefresher;</span><br><span class="line">        <span class="keyword">this</span>.environment = environment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置定时器每隔5秒刷新一次配置项</span></span><br><span class="line">    <span class="meta">@Scheduled</span>(fixedRate = <span class="number">5</span> * <span class="number">1000</span>, initialDelay = <span class="number">3</span> * <span class="number">1000</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">autoRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; updatedPropertyNames = contextRefresher.refresh();</span><br><span class="line">        updatedPropertyNames.forEach( propertyName -&gt;</span><br><span class="line">            System.err.printf(</span><br><span class="line">                    <span class="string">"[Thread :%s] 当前配置已更新，具体 Key：%s , Value : %s \n"</span>,</span><br><span class="line">                    Thread.currentThread().getName(),</span><br><span class="line">                    propertyName,</span><br><span class="line">                    environment.getProperty(propertyName)</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a><code>服务端</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="comment">// 激活配置管理服务器</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServerApp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigServerApp.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义配置实现,绕过git实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EnvironmentRepository <span class="title">environmentRepository</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (String application, String profile, String label) -&gt; &#123;</span><br><span class="line">            Environment environment = <span class="keyword">new</span> Environment(<span class="string">"default"</span>, profile);</span><br><span class="line">            List&lt;PropertySource&gt; propertySources = environment.getPropertySources();</span><br><span class="line">            Map&lt;String, Object&gt; source = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">            source.put(<span class="string">"name"</span>, <span class="string">"微服务-&gt;long"</span>);</span><br><span class="line">            PropertySource propertySource = <span class="keyword">new</span> PropertySource(<span class="string">"map"</span>, source);</span><br><span class="line">            propertySources.add(propertySource);</span><br><span class="line">            <span class="keyword">return</span> environment;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="客户端流程分析"><a href="#客户端流程分析" class="headerlink" title="客户端流程分析"></a><code>客户端流程分析</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 在客户端，我们可以配置形如: localhost:8080/&#123;name&#125;/&#123;profiles&#125;/&#123;label&#125; 去从服务端获取配置。</span></span><br><span class="line"><span class="comment">2. 在服务端是通过 EnvironmentController 类来对外提供服务的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(method = RequestMethod.GET, path = <span class="string">"$&#123;spring.cloud.config.server.prefix:&#125;"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnvironmentController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/&#123;name&#125;/&#123;profiles&#125;/&#123;label:.*&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Environment <span class="title">labelled</span><span class="params">(@PathVariable String name, @PathVariable String profiles,</span></span></span><br><span class="line"><span class="function"><span class="params">@PathVariable String label)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (name != <span class="keyword">null</span> &amp;&amp; name.contains(<span class="string">"(_)"</span>)) &#123;</span><br><span class="line"><span class="comment">// "(_)" is uncommon in a git repo name, but "/" cannot be matched</span></span><br><span class="line"><span class="comment">// by Spring MVC</span></span><br><span class="line">name = name.replace(<span class="string">"(_)"</span>, <span class="string">"/"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (label != <span class="keyword">null</span> &amp;&amp; label.contains(<span class="string">"(_)"</span>)) &#123;</span><br><span class="line"><span class="comment">// "(_)" is uncommon in a git branch name, but "/" cannot be matched</span></span><br><span class="line"><span class="comment">// by Spring MVC</span></span><br><span class="line">label = label.replace(<span class="string">"(_)"</span>, <span class="string">"/"</span>);</span><br><span class="line">&#125;</span><br><span class="line">Environment environment = <span class="keyword">this</span>.repository.findOne(name, profiles, label);</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.acceptEmpty</span><br><span class="line">&amp;&amp; (environment == <span class="keyword">null</span> || environment.getPropertySources().isEmpty())) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> EnvironmentNotFoundException(<span class="string">"Profile Not found"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> environment;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="服务端流程分析"><a href="#服务端流程分析" class="headerlink" title="服务端流程分析"></a><code>服务端流程分析</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 在 @EnableConfigServer 注解中使用了 @Import 注解导入了配置类 ConfigServerConfiguration。</span></span><br><span class="line"><span class="comment">2. 在配置类 ConfigServerConfiguration 上面使用 @Configuration 注解表明该类是一个配置类，该配置类</span></span><br><span class="line"><span class="comment">会在上下文中创建一个类型为 ConfigServerConfiguration.Marker 的bean。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(ConfigServerConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableConfigServer &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServerConfiguration</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Marker <span class="title">enableConfigServerMarker</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Marker();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Marker</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. ConfigServerAutoConfiguration 类上面使用了 @ConditionalOnBean 注解，只有当上下文中存在类型</span></span><br><span class="line"><span class="comment">为 ConfigServerConfiguration.Marker 的bean时，才会执行该配置类的流程（条件装配）。</span></span><br><span class="line"><span class="comment">2. 在该类中导入了一些配置类，EnvironmentRepositoryConfiguration 等这些类会根据条件判断创建相关的</span></span><br><span class="line"><span class="comment">bean。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 配置类</span></span><br><span class="line"><span class="meta">@ConditionalOnBean</span>(ConfigServerConfiguration.Marker.class) <span class="comment">// 条件装配</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(ConfigServerProperties.class)</span><br><span class="line"><span class="meta">@Import</span>(&#123; EnvironmentRepositoryConfiguration.class, CompositeConfiguration.class,</span><br><span class="line">ResourceRepositoryConfiguration.class, ConfigServerEncryptionConfiguration.class,</span><br><span class="line">ConfigServerMvcConfiguration.class &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServerAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. EnvironmentRepositoryConfiguration 通过 @Import 注解导入了一些相关的配置类。</span></span><br><span class="line"><span class="comment">JdbcRepositoryConfiguration GitRepositoryConfiguration 分别时基于jdbc和git实现配置</span></span><br><span class="line"><span class="comment">的仓储。</span></span><br><span class="line"><span class="comment">2. GitRepositoryConfiguration 继承啦 DefaultRepositoryConfiguration 类，属于默认实现。</span></span><br><span class="line"><span class="comment">3. 在 DefaultRepositoryConfiguration 类中 通过 @ConditionalOnMissingBean 注解表明当前</span></span><br><span class="line"><span class="comment">上下文中若是没有 EnvironmentRepository 类型的bean存在时，会创建一个类型为 </span></span><br><span class="line"><span class="comment">MultipleJGitEnvironmentRepository 的bean</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// EnvironmentRepositoryConfiguration 配置</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(&#123; SvnKitEnvironmentProperties.class,</span><br><span class="line">CredhubEnvironmentProperties.class, JdbcEnvironmentProperties.class,</span><br><span class="line">NativeEnvironmentProperties.class, VaultEnvironmentProperties.class &#125;)</span><br><span class="line"><span class="meta">@Import</span>(&#123; CompositeRepositoryConfiguration.class, JdbcRepositoryConfiguration.class,</span><br><span class="line">VaultConfiguration.class, VaultRepositoryConfiguration.class,</span><br><span class="line">CredhubConfiguration.class, CredhubRepositoryConfiguration.class,</span><br><span class="line">SvnRepositoryConfiguration.class, NativeRepositoryConfiguration.class,</span><br><span class="line">GitRepositoryConfiguration.class, DefaultRepositoryConfiguration.class &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnvironmentRepositoryConfiguration</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GitRepositoryConfiguration git实现的配置，继承了 DefaultRepositoryConfiguration 默认实现</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Profile</span>(<span class="string">"git"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GitRepositoryConfiguration</span> <span class="keyword">extends</span> <span class="title">DefaultRepositoryConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// JdbcRepositoryConfiguration jdbc实现的配置</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Profile</span>(<span class="string">"jdbc"</span>)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(JdbcTemplate.class)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JdbcRepositoryConfiguration</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnBean</span>(JdbcTemplate.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> JdbcEnvironmentRepository <span class="title">jdbcEnvironmentRepository</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">JdbcEnvironmentRepositoryFactory factory,</span></span></span><br><span class="line"><span class="function"><span class="params">JdbcEnvironmentProperties environmentProperties)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> factory.build(environmentProperties);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(value = EnvironmentRepository.class, search = SearchStrategy.CURRENT)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultRepositoryConfiguration</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MultipleJGitEnvironmentRepository <span class="title">defaultEnvironmentRepository</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">MultipleJGitEnvironmentRepositoryFactory gitEnvironmentRepositoryFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">MultipleJGitEnvironmentProperties environmentProperties)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">return</span> gitEnvironmentRepositoryFactory.build(environmentProperties);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">到此，还有一个问题，那就是 ConfigServerAutoConfiguration 时如何加载的，通过相关jar包里面的</span></span><br><span class="line"><span class="comment">spring.factories 文件可以看到 ConfigServerAutoConfiguration 被 EnableAutoConfiguration</span></span><br><span class="line"><span class="comment">通过spring的spi加载。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"># Autoconfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.cloud.config.server.config.ConfigServerAutoConfiguration,\</span><br><span class="line">org.springframework.cloud.config.server.config.EncryptionAutoConfiguration</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;分布式配置&quot;&gt;&lt;a href=&quot;#分布式配置&quot; class=&quot;headerlink&quot; title=&quot;分布式配置&quot;&gt;&lt;/a&gt;&lt;code&gt;分布式配置&lt;/code&gt;&lt;/h6&gt;&lt;hr&gt;
&lt;figure class=&quot;highlight tex&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="框架" scheme="https://zhilongao.github.io/categories/java/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="spring-cloud" scheme="https://zhilongao.github.io/categories/java/%E6%A1%86%E6%9E%B6/spring-cloud/"/>
    
    
  </entry>
  
  <entry>
    <title>questions</title>
    <link href="https://zhilongao.github.io/wiki/questions/"/>
    <id>https://zhilongao.github.io/wiki/questions/</id>
    <published>2019-09-12T02:40:03.000Z</published>
    <updated>2019-09-12T02:46:20.517Z</updated>
    
    <content type="html"><![CDATA[<ol><li>说说dubbo服务上下线时你们是如何处理的?</li><li>dubbo的协议有哪些,哪些使用场景?</li><li>dubbo使用的系列化框架是什么?</li><li>dubbo服务容错机制?</li><li>socket协议的几种状态,socket协议的三次握手,为什么是三次握手?</li><li>说说nio和io有什么不同,nio有哪些场景?</li><li>http请求有哪些方法?</li><li>jdk1.8有哪些新特性,使用过哪些?</li><li>谈谈对GC的理解，对G1有了解吗?</li><li>Collection.sort底层默认使用哪种排序算法，说说你熟悉的排序算法有哪些?</li><li>基本数据类型,占用字节,包装类,为什么会有包装类?</li><li>多线程你们在项目中怎么用的?</li><li>jdk1.8中Stream在并行处理时，适合哪些情景，不适合哪些情景?(第一次遇到这样问的,没回答上来)<br>适合计算密集型,不适合IO密集型。因为Stream被分配到的是核心线程池，IO密集型会造成线程阻塞。</li><li>你们reids在使用中，过期时间是怎么设置的，分两步设置不能保证原子性，怎么解决的?</li><li>写一下二分查找算法？</li><li>写一个单例?(DCL)？</li><li>说说dubbo和spring cloud有什么区别?</li><li>你们数据库是怎么优化的,说说实例?</li><li>了解redis吗，说说redis基本数据结构，有哪些常用的指令？</li></ol><hr><p>1、说说 dubbo 的执行流程<br>2、redis 基本数据结构，你们是怎么用的（讲了下 5 分钟发帖 10 次）<br>3、数据库连接池了解吗？<br>4、生产环境项目打印日志出现了时间长的现象，你怎么排查<br>5、接口出现频繁 GC ，怎么排查</p><hr><p>1 线程池用过哪些，在项目中是怎么使用的</p><p>2 sql优化怎么做的，哪些情况触发不了索引 , sql优化除了索引还要看哪些指标</p><p>3 redis有没有遇到数据库满了的情况</p><p>4  说说redis cluster</p><p>5 springmvc  springboot springcloud的区别</p><p>6 对restful有了解吗，弹弹restful</p><p>7 说说对spring的理解</p><p>8 @Autowired和@Resource的区别</p><p>9 设计模式有哪些了解，说说设计模式遵循的原则</p><p>10 交给你一个项目，怎么推进</p><p>11 通过哪些途径学习，看些什么书</p><p>12 总结下自己</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;说说dubbo服务上下线时你们是如何处理的?&lt;/li&gt;
&lt;li&gt;dubbo的协议有哪些,哪些使用场景?&lt;/li&gt;
&lt;li&gt;dubbo使用的系列化框架是什么?&lt;/li&gt;
&lt;li&gt;dubbo服务容错机制?&lt;/li&gt;
&lt;li&gt;socket协议的几种状态,socket协
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="面试题" scheme="https://zhilongao.github.io/categories/java/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>linux系统</title>
    <link href="https://zhilongao.github.io/wiki/linux-system-problem/"/>
    <id>https://zhilongao.github.io/wiki/linux-system-problem/</id>
    <published>2019-09-09T12:19:57.000Z</published>
    <updated>2019-09-10T06:35:55.531Z</updated>
    
    <content type="html"><![CDATA[<h6 id="linux三种网络模式"><a href="#linux三种网络模式" class="headerlink" title="linux三种网络模式"></a><code>linux三种网络模式</code></h6><p>在我们安装vmware的时候，vmware会为三种网络模式各自创建一个虚拟机网络, 其中 VMnet0(表示桥接模式) VMnet8(NAT模式) VMnet1(仅主机模式) </p><hr><p>桥接模式<br>    和主机一样，也会占用一个局域网中的ip。信息的发送和接受，虚拟网络适配器和主机的物理网络适配器进行交换，虚拟网络适配器可以通过主机的物理网络适配器访问外部网络。在局域网中的其它主机能够识别到发送信息的ip为该虚拟机的ip。 </p><p>NAT模式<br>    虚拟机发送数据时，NAT虚拟机网络适配器会以主机的名义将数据包裹发送出去，接收时通过特殊的标识识别。在外部网络中并不知道当前虚拟机的存在。</p><p>主机模式<br>    仅可以和主机通信，无法访问外部网络。</p><hr><p>​    <a href="https://www.cnblogs.com/xuan52rock/p/5295069.html" target="_blank" rel="noopener">一篇介绍的很形象的文章</a></p><hr><h6 id="centos7之动态ip与静态ip"><a href="#centos7之动态ip与静态ip" class="headerlink" title="centos7之动态ip与静态ip"></a><code>centos7之动态ip与静态ip</code></h6><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">centos7获取ip地址的方法主要有两种 1:动态获取  2:设置静态ip</span><br><span class="line"></span><br><span class="line">我们一般通过VMWare安装完centos7后，可以使用命令ip addr查看虚拟机的ip地址。但是刚安装完的centos7有些没有设置ip地址，我们可以通过下面两种方式来设置ip地址。</span><br><span class="line"></span><br><span class="line">1. 动态获取ip(前提是路由器已经开启了DHCP(动态主机设置协议))</span><br><span class="line">  a: 需要修改网卡的配置文件 /etc/sysconfig/network-scripts/ifcfg-ens33 其中ifcfg-ens33为网卡名。修改该文件的两处地方既可。</span><br><span class="line">   (1) bootproto=dhcp</span><br><span class="line">   (2) onboot=yes</span><br><span class="line">  b: 重启下网络服务</span><br><span class="line">   [root@mini ~]# systemctl restart network</span><br><span class="line">  c: 通过 ip addr 命令可以看到ens33的网卡已经有相应的ip地址啦</span><br><span class="line">  d: 通过 ping www.baidu.com 查看网络是否通畅</span><br><span class="line">  </span><br><span class="line">在VMware里，点击'编辑'-'虚拟网络编辑器'  </span><br><span class="line">2. 配置静态ip地址(网络模式在nat模式下)</span><br><span class="line">  a: 也是需要修改网卡配置文件 /etc/sysconfig/network-srcipts/ifcfg-ens33 其中ifcfg-ens33为网卡名。修改该文件的两处地方既可。</span><br><span class="line">   (1) bootproto=static</span><br><span class="line">   (2) onboot=yes </span><br><span class="line">  b: 还需要在该网卡配置文件的后面加上几行，分别是ip地址，子网掩码，网关，dns服务器</span><br><span class="line">    IPADDR=192.168.25.156 #静态ip</span><br><span class="line">    NETMASK=255.255.255.0 #子网掩码</span><br><span class="line">    GATEWAY=192.168.1.1 #网关</span><br><span class="line">    DNS1=192.168.25.2</span><br><span class="line">    DNS2=8.8.8.8 #谷歌的dns服务器</span><br><span class="line">  c: 重启下网络服务</span><br><span class="line">  [root@mini ~]# systemctl restart network</span><br><span class="line">  d: 通过 ip addr 命令可以看到ens33的网卡已经有新的ip地址啦</span><br><span class="line">  e: 通过 ping www.baidu.com 查看网络是否通畅</span><br><span class="line"></span><br><span class="line">3. 在 /etc/resolv.conf文件里面保存了dns地址，可以通过cat命令查看</span><br></pre></td></tr></table></figure><p><code>在设置静态ip时,子网掩码和网关地址可以在vmware的-&gt;编辑-&gt;虚拟网络编辑器-&gt;NAT设置 中查看，如下图所示</code></p><p><img src="https://raw.githubusercontent.com/zhilongao/images-repository/master/46f916fdc305a268fe584b8ba809ed3.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;linux三种网络模式&quot;&gt;&lt;a href=&quot;#linux三种网络模式&quot; class=&quot;headerlink&quot; title=&quot;linux三种网络模式&quot;&gt;&lt;/a&gt;&lt;code&gt;linux三种网络模式&lt;/code&gt;&lt;/h6&gt;&lt;p&gt;在我们安装vmware的时候，vmware
      
    
    </summary>
    
      <category term="系统" scheme="https://zhilongao.github.io/categories/%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="linux" scheme="https://zhilongao.github.io/categories/%E7%B3%BB%E7%BB%9F/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>字符串</title>
    <link href="https://zhilongao.github.io/wiki/string-ask/"/>
    <id>https://zhilongao.github.io/wiki/string-ask/</id>
    <published>2019-09-06T02:25:40.000Z</published>
    <updated>2019-09-14T06:37:35.357Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problemset/algorithms/" target="_blank" rel="noopener">题目来自leetcode</a></p><h6 id="字符串反转1-344"><a href="#字符串反转1-344" class="headerlink" title="字符串反转1(344)"></a><code>字符串反转1(344)</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目要求：编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组char[]的形式给出。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = s.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">char</span> temp = s[low];</span><br><span class="line">        s[low++] = s[high];</span><br><span class="line">        s[high--] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="字符串反转2-541"><a href="#字符串反转2-541" class="headerlink" title="字符串反转2(541)"></a><code>字符串反转2(541)</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目要求:给定一个字符串和一个整数 k，你需要对从字符串开头算起的每个 2k 个字符的前k个字符进行反转。如果剩余少于 k 个字符，则将剩余的所有全部反转。如果有小于 2k 但大于或等于 k 个字符，则反转前 k 个字符，并将剩余的字符保持原样。</span></span><br><span class="line"><span class="comment">示例：输入: s = "abcdefg", k = 2 输出: "bacdfeg"</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseStr</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算长度 整数遍历次数 剩余元素个数</span></span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">int</span> lastNum = len % (<span class="number">2</span> * k);</span><br><span class="line">    <span class="keyword">int</span> num = len / (<span class="number">2</span> * k);</span><br><span class="line">    <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">    <span class="comment">// 先将前2*k*num个元素做反转</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">2</span> * num; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> low = (i - <span class="number">1</span>) * k;</span><br><span class="line">        <span class="keyword">int</span> high = i * k - <span class="number">1</span>;</span><br><span class="line">        reverseChar(chars, low, high);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将剩余的不到2*k个元素反转</span></span><br><span class="line">    <span class="keyword">if</span> (lastNum &gt; k) &#123;</span><br><span class="line">        reverseChar(chars, <span class="number">2</span>*k*num, <span class="number">2</span>*k*num+k-<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reverseChar(chars, <span class="number">2</span>*k*num, len-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符数组反转函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseChar</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">char</span> temp = chars[low];</span><br><span class="line">        chars[low ++] = chars[high];</span><br><span class="line">        chars[high --] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="字符串反转3-557"><a href="#字符串反转3-557" class="headerlink" title="字符串反转3(557)"></a><code>字符串反转3(557)</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目要求: 给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</span></span><br><span class="line"><span class="comment">注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。</span></span><br><span class="line"><span class="comment">示例 1:</span></span><br><span class="line"><span class="comment">输入: "Let's take LeetCode contest"</span></span><br><span class="line"><span class="comment">输出: "s'teL ekat edoCteeL tsetnoc" </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 解法：将字符串按照空格拆分成为字符串数组，然后将每一个字符串翻转，最后将反转的字符串拼接到一起。</span></span><br><span class="line"><span class="comment">// 其中字符串的反转采用的方式为先转换为字符数组，然后反转字符数组。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    String[] split = s.split(<span class="string">"\\s+"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; split.length ; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars = split[i].toCharArray();</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> hig = chars.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; hig) &#123;</span><br><span class="line">            <span class="keyword">char</span> temp = chars[low];</span><br><span class="line">            chars[low ++] = chars[hig];</span><br><span class="line">            chars[hig --] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(chars);</span><br><span class="line">        <span class="keyword">if</span> (i != split.length - <span class="number">1</span>) &#123;</span><br><span class="line">            sb.append(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="字符串反转4-917"><a href="#字符串反转4-917" class="headerlink" title="字符串反转4(917)"></a><code>字符串反转4(917)</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目要求:给定一个字符串 S，返回 “反转后的” 字符串，其中不是字母的字符都保留在原地，而所有字母的位置发生反转。</span></span><br><span class="line"><span class="comment">示例 1：输入："ab-cd"  输出："dc-ba"</span></span><br><span class="line"><span class="comment">示例 2：输入："a-bC-dEf-ghIj" 输出："j-Ih-gfE-dCba"</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseOnlyLetters</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 双指针</span></span><br><span class="line">    StringBuffer buf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">int</span> j = S.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); i ++) &#123;</span><br><span class="line">        <span class="comment">// 位置i上的字符为字母时，可以做交换</span></span><br><span class="line">        <span class="keyword">if</span> (Character.isLetter(S.charAt(i))) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!Character.isLetter(S.charAt(j))) &#123;</span><br><span class="line">                j --;</span><br><span class="line">            &#125;</span><br><span class="line">            buf.append(S.charAt(j --));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            buf.append(S.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buf.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="字符串反转5-345"><a href="#字符串反转5-345" class="headerlink" title="字符串反转5(345)"></a><code>字符串反转5(345)</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目要求:编写一个函数，以字符串作为输入，反转该字符串中的元音字母。</span></span><br><span class="line"><span class="comment">示例 1: 输入: "hello" 输出: "holle"</span></span><br><span class="line"><span class="comment">示例 2: 输入: "leetcode" 输出: "leotcede"</span></span><br><span class="line"><span class="comment">说明: 元音字母不包含字母"y"。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 元音字母集合</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> Set&lt;Character&gt; sets = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="string">'a'</span>, <span class="string">'e'</span>, <span class="string">'i'</span>, <span class="string">'o'</span>, <span class="string">'u'</span>, <span class="string">'A'</span>, <span class="string">'E'</span>, <span class="string">'I'</span>, <span class="string">'O'</span>, <span class="string">'U'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用双指针,当两端同时为元音字母时,交换两个位置的字符。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseVowels</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = s.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!judgeVowel(chars[left])) &#123;</span><br><span class="line">            left ++;</span><br><span class="line">            <span class="keyword">if</span> (left &gt; s.length() -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!judgeVowel(chars[right])) &#123;</span><br><span class="line">            right --;</span><br><span class="line">            <span class="keyword">if</span> (right &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> temp = chars[left];</span><br><span class="line">        chars[left++] = chars[right];</span><br><span class="line">        chars[right--] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="无重复字符的最长子串-3"><a href="#无重复字符的最长子串-3" class="headerlink" title="无重复字符的最长子串(3)"></a><code>无重复字符的最长子串(3)</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 滑动窗口解法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = s.length();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">    Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">    <span class="keyword">while</span>(left &lt; length &amp;&amp; right &lt; length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!set.contains(s.charAt(right))) &#123;</span><br><span class="line">            set.add(s.charAt(right ++));</span><br><span class="line">            ans = Math.max(ans, right - left);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            set.remove(s.charAt(left ++));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="最长回文子串-5"><a href="#最长回文子串-5" class="headerlink" title="最长回文子串(5)"></a><code>最长回文子串(5)</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 题目要求:给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</span></span><br><span class="line"><span class="comment">// 1.要判断一个字符串是否为回文字符串，可以通过下面几种方式来实现</span></span><br><span class="line"><span class="comment">// 第一种:通过栈的后进先出原理，将字符串翻转来对比前后两个字符串是否一致</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isHuiWen1</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        stack.push(str.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuffer buf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        buf.append(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (str.equals(buf.toString())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二种: 取消栈的引入，直接通过逆序输出拼接字符串(减少了额外的空间Stack)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isHuiWen2</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    StringBuffer buf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = str.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">        buf.append(str.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (buf.toString().equals(str)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第三中: 基于回文串左右两边两个字符相等的规律，定义两个变量做对比(优势是减少了字符串str的遍历次数，时间复杂度降低)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isHuiWen3</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = str.length();</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(str.charAt(left) == str.charAt(right))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        left ++;</span><br><span class="line">        right --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前这道题如何实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 给定一个字符串s,找到s中最长的回文子串。你可以假设s的最大长度为1000。</span></span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> resultLen = <span class="number">1</span>;</span><br><span class="line">    String resultStr = s.substring(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">        <span class="comment">// 从中间向两边查找对称的回文串</span></span><br><span class="line">        String oddStr = spread(s, len, i, i);</span><br><span class="line">        String evenStr = spread(s, len, i, i+<span class="number">1</span>);</span><br><span class="line">        String myStr = oddStr.length() &gt;= evenStr.length() ? oddStr : evenStr;</span><br><span class="line">        <span class="keyword">if</span> (myStr.length() &gt; resultLen) &#123;</span><br><span class="line">            resultStr = myStr;</span><br><span class="line">            resultLen = resultStr.length();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultStr;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">spread</span><span class="params">(String s, <span class="keyword">int</span> len, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = left;</span><br><span class="line">    <span class="keyword">int</span> r = right;</span><br><span class="line">    <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; len &amp;&amp; (s.charAt(l) == s.charAt(r))) &#123;</span><br><span class="line">        l --;</span><br><span class="line">        r ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(l+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="压缩字符串-443"><a href="#压缩字符串-443" class="headerlink" title="压缩字符串(443)"></a><code>压缩字符串(443)</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 题目要求: 给定一组字符串，使用原地算法将其压缩。</span></span><br><span class="line"><span class="comment">// 题目解法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compress</span><span class="params">(<span class="keyword">char</span>[] chars)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> anchor = <span class="number">0</span>; <span class="comment">// 描点，定位可以元素</span></span><br><span class="line">    <span class="keyword">int</span> write = <span class="number">0</span>; <span class="comment">// 写下标，定位写的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> read = <span class="number">0</span>; read &lt; chars.length; read ++) &#123;</span><br><span class="line">        <span class="comment">// 若是当前元素为最后一个元素或者是后一个元素与当前元素不相等，执行写入与统计写入操作</span></span><br><span class="line">        <span class="keyword">if</span> ((read == chars.length - <span class="number">1</span>) || (chars[read + <span class="number">1</span>] != chars[read])) &#123;</span><br><span class="line">            <span class="comment">// 将anchor位置处的元素写入到write位置处</span></span><br><span class="line">            chars[write ++] = chars[anchor];</span><br><span class="line">            <span class="comment">// 判断该元素是否需要压缩</span></span><br><span class="line">            <span class="keyword">if</span> (read &gt; anchor) &#123;</span><br><span class="line">                String numStr = read - anchor + <span class="number">1</span> + <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">char</span>[] numArr = numStr.toCharArray();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> num : numArr) &#123;</span><br><span class="line">                    chars[write ++] = num;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将锚点移动到下一个元素</span></span><br><span class="line">            anchor = read + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回覆盖的个数</span></span><br><span class="line">    <span class="keyword">return</span> write;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problemset/algorithms/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目来自leetcode&lt;/a&gt;&lt;/p&gt;
&lt;h6 id=&quot;字符串反转1-344&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="算法" scheme="https://zhilongao.github.io/categories/java/%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串" scheme="https://zhilongao.github.io/categories/java/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
  </entry>
  
  <entry>
    <title>array-ask</title>
    <link href="https://zhilongao.github.io/wiki/array-ask/"/>
    <id>https://zhilongao.github.io/wiki/array-ask/</id>
    <published>2019-09-05T01:52:30.000Z</published>
    <updated>2019-09-05T12:23:51.735Z</updated>
    
    <content type="html"><![CDATA[<h6 id="寻找递增序列"><a href="#寻找递增序列" class="headerlink" title="寻找递增序列"></a><code>寻找递增序列</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给定一个未经过排序的数组，找到最长且连续的递增序列(在美团面试题中出现过-leetcode674题)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> curr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            curr ++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            max = Math.max(max, curr);</span><br><span class="line">        curr = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(max, curr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;寻找递增序列&quot;&gt;&lt;a href=&quot;#寻找递增序列&quot; class=&quot;headerlink&quot; title=&quot;寻找递增序列&quot;&gt;&lt;/a&gt;&lt;code&gt;寻找递增序列&lt;/code&gt;&lt;/h6&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="算法" scheme="https://zhilongao.github.io/categories/java/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数组" scheme="https://zhilongao.github.io/categories/java/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/"/>
    
    
  </entry>
  
  <entry>
    <title>mongodb-base</title>
    <link href="https://zhilongao.github.io/wiki/mongodb-base/"/>
    <id>https://zhilongao.github.io/wiki/mongodb-base/</id>
    <published>2019-09-03T03:45:03.000Z</published>
    <updated>2019-09-05T11:05:41.293Z</updated>
    
    <content type="html"><![CDATA[<h6 id="安装步骤-centos7"><a href="#安装步骤-centos7" class="headerlink" title="安装步骤(centos7)"></a><code>安装步骤(centos7)</code></h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1.下载安装包</span><br><span class="line">wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel62-3.2.10.tgz</span><br><span class="line">2.解压安装包</span><br><span class="line">tar -zxvf mongodb-linux-x86_64-rhel62-3.2.10.tgz </span><br><span class="line">3.将解压目录移动到(/usr/local/mongodb)</span><br><span class="line">mv mongodb-linux-x86_64-rhel62-3.2.10 /usr/local/mongodb</span><br><span class="line">4.在/usr/local/mongodb目录下创建/data/db目录和/logs目录</span><br><span class="line">mkdir -p /usr/local/mongodb/data/db </span><br><span class="line">mkdir -p /usr/local/mongodb/logs</span><br><span class="line">5.在/usr/local/mongodb/logs目录下创建mongodb.log文件</span><br><span class="line">touch mongodb.log</span><br><span class="line">6.在/usr/local/mongodb/bin目录下创建mongodb的配置文件</span><br><span class="line">touch mongodb.conf</span><br><span class="line">7.编辑mongodb.conf文件</span><br><span class="line">vi mongodb.conf</span><br><span class="line">编辑内容</span><br><span class="line">dbpath = /usr/local/mongodb/data/db #数据文件存放目录</span><br><span class="line">logpath = /usr/local/mongodb/logs/mongodb.log #日志文件存放目录</span><br><span class="line">port = 27017  #端口</span><br><span class="line">fork = true  #以守护程序的方式启用，即在后台运行</span><br><span class="line">nohttpinterface = true</span><br><span class="line">auth=true</span><br><span class="line">bind_ip=0.0.0.0</span><br><span class="line">8.修改环境变量</span><br><span class="line">vi /etc/profile</span><br><span class="line">添加的内容</span><br><span class="line">export MONGODB_HOME=/usr/local/mongodb</span><br><span class="line">export PATH=$PATH:$MONGODB_HOME/bin</span><br><span class="line">9.编辑完成之后重启系统配置</span><br><span class="line">source /etc/profile</span><br><span class="line">10.在/usr/local/mongodb/bin目录下启动mongodb</span><br><span class="line">./mongod -f mongodb.conf</span><br><span class="line">11.关闭mongodb服务</span><br><span class="line">./mongod -f ./mongodb.conf --shutdown</span><br><span class="line">12.开启27017端口</span><br><span class="line"></span><br><span class="line">13.使用shell登录到mongodb</span><br><span class="line">./mongodb</span><br><span class="line"></span><br><span class="line">14.登录到相关数据库</span><br><span class="line">use test</span><br><span class="line"></span><br><span class="line">15.创建用户</span><br><span class="line">db.createUser(</span><br><span class="line">&#123;</span><br><span class="line">user: "test", </span><br><span class="line">pwd: "test", </span><br><span class="line">roles: [&#123; role: "readWrite", db: "test" &#125;]</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line">16.修改配置，开启验证</span><br><span class="line">auth=true</span><br><span class="line">17.重启服务</span><br><span class="line">停止服务，然后启动</span><br><span class="line">18.登录</span><br><span class="line">./mongodb</span><br><span class="line">19.验证</span><br><span class="line">auth('test', 'test')(返回1代表成功)</span><br><span class="line">20.操作</span><br><span class="line">db.user.find()</span><br><span class="line">db.user.insert(&#123;"name":'jack',"age": 12&#125;)</span><br></pre></td></tr></table></figure><h6 id="基本操作-gt-java-api的crud"><a href="#基本操作-gt-java-api的crud" class="headerlink" title="基本操作-&gt;java api的crud"></a><code>基本操作-&gt;java api的crud</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 引入依赖</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.mongodb&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mongo-java-driver&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.9.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.java代码</span><br><span class="line"><span class="comment">// 工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MongoUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String baseUrl = <span class="string">"192.168.25.147:27017"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String userName = <span class="string">"test"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String passWord = <span class="string">"test"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String url = <span class="string">"mongodb://"</span>+ userName +<span class="string">":"</span>+ passWord + <span class="string">"@"</span>+ baseUrl + <span class="string">"/"</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 获取MongoDatabase</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MongoDatabase <span class="title">getConnection</span><span class="params">(String dataName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取MongoClient</span></span><br><span class="line">        com.mongodb.client.MongoClient mongoClient = MongoClients.create(url + dataName);</span><br><span class="line">        <span class="comment">// 获取MongoDatabase</span></span><br><span class="line">        MongoDatabase db = mongoClient.getDatabase(dataName);</span><br><span class="line">        <span class="keyword">return</span> db;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本操作 -&gt; 获取所有</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findAll</span><span class="params">(String databaseName, String collectionName)</span> </span>&#123;</span><br><span class="line">MongoDatabase database = MongoUtil.getConnection(databaseName);</span><br><span class="line">    MongoCollection&lt;Document&gt; collection = database.getCollection(collectionName);</span><br><span class="line">    FindIterable&lt;Document&gt; documents = collection.find();</span><br><span class="line">    print(documents);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本操作 -&gt; 插入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String databaseName, String collectionName)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取database</span></span><br><span class="line">MongoDatabase database = MongoUtil.getConnection(databaseName);</span><br><span class="line"><span class="comment">// 获取Clooection</span></span><br><span class="line">MongoCollection&lt;Document&gt; collection = database.getCollection(collectionName);</span><br><span class="line"><span class="comment">// 创建Document</span></span><br><span class="line">Document document = <span class="keyword">new</span> Document()</span><br><span class="line">                    .append(<span class="string">"name"</span>, <span class="string">"mick11"</span>)</span><br><span class="line">                    .append(<span class="string">"age"</span>, <span class="string">"33"</span>)</span><br><span class="line">                    .append(<span class="string">"address"</span>, <span class="string">"长沙"</span>)</span><br><span class="line">                    .append(<span class="string">"sex"</span>, <span class="string">"男"</span>);</span><br><span class="line">    <span class="comment">// 插入document                </span></span><br><span class="line">collection.insertOne(document);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印所有</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(FindIterable&lt;Document&gt; documents)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (Document document : documents) &#123;</span><br><span class="line">System.out.println(document.toJson());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;安装步骤-centos7&quot;&gt;&lt;a href=&quot;#安装步骤-centos7&quot; class=&quot;headerlink&quot; title=&quot;安装步骤(centos7)&quot;&gt;&lt;/a&gt;&lt;code&gt;安装步骤(centos7)&lt;/code&gt;&lt;/h6&gt;&lt;figure class=&quot;hig
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="数据库" scheme="https://zhilongao.github.io/categories/java/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mongodb" scheme="https://zhilongao.github.io/categories/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb/"/>
    
    
      <category term="mongo" scheme="https://zhilongao.github.io/tags/mongo/"/>
    
  </entry>
  
  <entry>
    <title>实际应用</title>
    <link href="https://zhilongao.github.io/wiki/redis-advance/"/>
    <id>https://zhilongao.github.io/wiki/redis-advance/</id>
    <published>2019-09-02T00:47:25.000Z</published>
    <updated>2019-09-08T09:33:52.783Z</updated>
    
    <content type="html"><![CDATA[<h6 id="list实现分布式队列"><a href="#list实现分布式队列" class="headerlink" title="list实现分布式队列"></a><code>list实现分布式队列</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需要的依赖jedis fastjson</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.9.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line"> &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.2.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/8 15:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String url = <span class="string">"192.168.25.150"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> port = <span class="number">6379</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构建queue</span></span><br><span class="line">        String queueKey = <span class="string">"message_queue"</span>;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(url, port);</span><br><span class="line">        <span class="comment">// 消息转换器</span></span><br><span class="line">        MessageConvert&lt;TaskItem&gt; convert = <span class="keyword">new</span> MessageConvert&lt;&gt;();</span><br><span class="line">        <span class="comment">// 消息队列</span></span><br><span class="line">        RedisQueue queue = <span class="keyword">new</span> RedisQueue(jedis, queueKey, convert);</span><br><span class="line">        <span class="comment">// 生产者</span></span><br><span class="line">        MessageProducer producer = <span class="keyword">new</span> MessageProducer(queue);</span><br><span class="line">        <span class="comment">// 消费者</span></span><br><span class="line">        MessageConsumer consumer = <span class="keyword">new</span> MessageConsumer(queue);</span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息队列</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/8 14:34</span></span><br><span class="line"><span class="comment"> * 分布式消息队列-list实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line">    <span class="keyword">private</span> String queueKey;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisQueue</span><span class="params">(Jedis jedis, String queueKey, MessageConvert messageConvert)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jedis = jedis;</span><br><span class="line">        <span class="keyword">this</span>.queueKey = queueKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.jedis.lpush(queueKey, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费消息-&gt;可重试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">poll</span><span class="params">(<span class="keyword">boolean</span> isRetry)</span> </span>&#123;</span><br><span class="line">        String message = jedis.rpop(queueKey);</span><br><span class="line">        <span class="keyword">if</span> (message == <span class="keyword">null</span> &amp;&amp; isRetry) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            message = jedis.rpop(queueKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/8 15:47</span></span><br><span class="line"><span class="comment"> * 消息生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageProducer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 队列</span></span><br><span class="line">    <span class="keyword">private</span> RedisQueue queue;</span><br><span class="line">    <span class="comment">// 消息转换器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MessageConvert&lt;TaskItem&gt; convert = <span class="keyword">new</span> MessageConvert&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageProducer</span><span class="params">(RedisQueue queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            send(<span class="string">"message:"</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">30</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并发送消息</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一条消息</span></span><br><span class="line">        TaskItem item = <span class="keyword">new</span> TaskItem();</span><br><span class="line">        item.id = UUID.randomUUID().toString();</span><br><span class="line">        item.msg = message;</span><br><span class="line">        <span class="comment">// 转换为字符串发送</span></span><br><span class="line">        String sendMess = convert.messageToString(item);</span><br><span class="line">        queue.push(sendMess);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/8 15:48</span></span><br><span class="line"><span class="comment"> * 消息消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageConsumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RedisQueue queue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageConsumer</span><span class="params">(RedisQueue queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(random.nextInt(<span class="number">10</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            receive();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object object = queue.poll(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (object != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/8 15:45</span></span><br><span class="line"><span class="comment"> * 消息转换器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageConvert</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Type taskType = <span class="keyword">new</span> TypeReference&lt;T&gt;() &#123;&#125;.getType();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将给定的消息转换为string类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">messageToString</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JSON.toJSONString(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将string类型的消息转换为T类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">stringToObject</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JSON.parseObject(message, taskType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="zset实现延时队列"><a href="#zset实现延时队列" class="headerlink" title="zset实现延时队列"></a><code>zset实现延时队列</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delayQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(url, port);</span><br><span class="line">    <span class="comment">// 延时队列</span></span><br><span class="line">    RedisDelayingQueue queue = <span class="keyword">new</span> RedisDelayingQueue(jedis, <span class="string">"q-demo"</span>);</span><br><span class="line">    DelayMessageConsumer consumer = <span class="keyword">new</span> DelayMessageConsumer(queue);</span><br><span class="line">    DelayMessageProducer producer = <span class="keyword">new</span> DelayMessageProducer(queue);</span><br><span class="line">    producer.start();</span><br><span class="line">    consumer.start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 首先让producer线程执行完成</span></span><br><span class="line">        producer.join();</span><br><span class="line">        <span class="comment">// 主线程睡眠6秒，等待consumer将消息消费完成</span></span><br><span class="line">        Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">        consumer.interrupt();</span><br><span class="line">        consumer.join();</span><br><span class="line">    &#125;  <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/7 16:56</span></span><br><span class="line"><span class="comment"> * 延时队列-&gt; 通过zset实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisDelayingQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line">    <span class="keyword">private</span> String queueKey;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisDelayingQueue</span><span class="params">(Jedis jedis, String queueKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jedis = jedis;</span><br><span class="line">        <span class="keyword">this</span>.queueKey = queueKey;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 执行消息的发送</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delay</span><span class="params">(String msg, <span class="keyword">long</span> score)</span> </span>&#123;</span><br><span class="line">        jedis.zadd(queueKey, score, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行消息的处理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">(MessageHandle handle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">            <span class="comment">// fixme 此处需要优化，保证操作的原子性</span></span><br><span class="line">            <span class="comment">// 获取一条数据(score最小的那条数据)</span></span><br><span class="line">            Set values = jedis.zrangeByScore(queueKey, <span class="number">0</span>, System.currentTimeMillis(), <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 若是队列中没有任务，线程睡眠500毫秒</span></span><br><span class="line">            <span class="keyword">if</span> (values.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String value = (String) values.iterator().next();</span><br><span class="line">            <span class="comment">// 从queueKey中移除该元素</span></span><br><span class="line">            <span class="keyword">if</span> (jedis.zrem(queueKey, value) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 将消息交给回调接口来处理</span></span><br><span class="line">                handle.handle(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/8 17:13</span></span><br><span class="line"><span class="comment"> * 延时队列-生产者线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayMessageProducer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    RedisDelayingQueue queue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelayMessageProducer</span><span class="params">(RedisDelayingQueue queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) &#123;</span><br><span class="line">            String message = <span class="string">"message:"</span>+ i;</span><br><span class="line">            <span class="keyword">long</span> score = random.nextInt(<span class="number">10</span>);</span><br><span class="line">            send(message, score);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String msg, <span class="keyword">long</span> delay)</span> </span>&#123;</span><br><span class="line">        TaskItem task = <span class="keyword">new</span> TaskItem();</span><br><span class="line">        task.id = UUID.randomUUID().toString();</span><br><span class="line">        task.msg = msg;</span><br><span class="line">        String message = JSON.toJSONString(task);</span><br><span class="line">        queue.delay(message, delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/8 17:11</span></span><br><span class="line"><span class="comment"> * 延时队列消费者线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayMessageConsumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    RedisDelayingQueue queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> MessageHandle handle = <span class="keyword">new</span> MessageHandle() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">            System.out.println(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelayMessageConsumer</span><span class="params">(RedisDelayingQueue queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue.loop(handle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/8 17:21</span></span><br><span class="line"><span class="comment"> * 消息处理回调接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageHandle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(String item)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;list实现分布式队列&quot;&gt;&lt;a href=&quot;#list实现分布式队列&quot; class=&quot;headerlink&quot; title=&quot;list实现分布式队列&quot;&gt;&lt;/a&gt;&lt;code&gt;list实现分布式队列&lt;/code&gt;&lt;/h6&gt;&lt;figure class=&quot;highlight
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="数据库" scheme="https://zhilongao.github.io/categories/java/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="redis" scheme="https://zhilongao.github.io/categories/java/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/"/>
    
    
  </entry>
  
  <entry>
    <title>单链表</title>
    <link href="https://zhilongao.github.io/wiki/linked-list-ask/"/>
    <id>https://zhilongao.github.io/wiki/linked-list-ask/</id>
    <published>2019-08-31T03:56:40.000Z</published>
    <updated>2019-09-03T07:38:54.888Z</updated>
    
    <content type="html"><![CDATA[<p><code>单链表常见操作</code></p><p><code>1.如何实现一个单链表的逆序输出-&gt;反转单链表</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">    ListNode next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span> &amp;&amp; (next = head.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    head.next = prev;</span><br><span class="line">        prev = head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    head.next = prev;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;单链表常见操作&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1.如何实现一个单链表的逆序输出-&amp;gt;反转单链表&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="算法" scheme="https://zhilongao.github.io/categories/java/%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="https://zhilongao.github.io/categories/java/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="https://zhilongao.github.io/wiki/arithmetic-sort/"/>
    <id>https://zhilongao.github.io/wiki/arithmetic-sort/</id>
    <published>2019-08-31T01:19:15.000Z</published>
    <updated>2019-09-06T06:27:43.174Z</updated>
    
    <content type="html"><![CDATA[<p><code>常见的排序算法</code></p><p><code>1.插入排序</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入排序算法</span></span><br><span class="line"><span class="comment">// 时间复杂度：平均情况:o(n^2)  最好情况:o(n) 最坏情况:o(n^2) </span></span><br><span class="line"><span class="comment">// 空间复杂度: o(1)</span></span><br><span class="line"><span class="comment">// 特点: 稳定</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; array.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = array[i];</span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;=<span class="number">0</span> &amp;&amp; array[j] &gt; temp; j --) &#123;</span><br><span class="line">            <span class="comment">// 将数组中的元素后移一位</span></span><br><span class="line">            array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">        &#125;</span><br><span class="line">        array[j + <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>2.选择排序</code></p><p><code>原理</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 选择排序算法</span></span><br><span class="line"><span class="comment">// 时间复杂度: 平均情况:o(n^2)  最好情况:o(n^2) 最坏情况:o(n^2)  </span></span><br><span class="line"><span class="comment">// 空间复杂度: o(1)</span></span><br><span class="line"><span class="comment">// 特点: 不稳定</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; array.length; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &gt; array[j]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = array[i];</span><br><span class="line">                array[i] = array[j];</span><br><span class="line">                array[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>3.交换排序-&gt;冒泡排序</code></p><p><code>原理</code></p><p><img src="https://raw.githubusercontent.com/zhilongao/images-repository/master/006y8mN6ly1g6mbx8snqyg30my075wqv.gif" alt="冒泡排序"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序算法</span></span><br><span class="line"><span class="comment">// 时间复杂度: 平均情况:o(n^2)  最好情况:o(n) 最坏情况:o(n^2)</span></span><br><span class="line"><span class="comment">// 空间复杂度: o(1)</span></span><br><span class="line"><span class="comment">// 特点：稳定</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - i - <span class="number">1</span>; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = array[j];</span><br><span class="line">                array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">                array[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>4.交换排序-&gt;快速排序</code></p><p><code>原理</code></p><p><img src="https://raw.githubusercontent.com/zhilongao/images-repository/master/7789414-007520d3d4a7610c.gif" alt="快速排序"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快速排序算法</span></span><br><span class="line"><span class="comment">// 时间复杂度: 平均情况:o(nlog2^n) 最好情况:o(nlog2^n) 最坏情况:o(n^2)</span></span><br><span class="line"><span class="comment">// 空间复杂度: o(nlog2^n)</span></span><br><span class="line"><span class="comment">// 特点：不稳定</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fastSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &gt; high) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = low;</span><br><span class="line">    <span class="keyword">int</span> j = fast;</span><br><span class="line">    <span class="keyword">int</span> temp = array[low];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="comment">// 从右向左找到第一个小于temp的元素,保存其下标</span></span><br><span class="line">        <span class="keyword">while</span> (array[j] &gt; temp &amp;&amp; i &lt; j) &#123;</span><br><span class="line">            j --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从左向右找到第一个大于temp的元素，保存其下标</span></span><br><span class="line">        <span class="keyword">while</span> (array[i] &lt;= temp &amp;&amp; i &lt; j) &#123;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换这两个元素</span></span><br><span class="line">        <span class="keyword">int</span> swap = array[i];</span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        array[j] = swap;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 交换temp</span></span><br><span class="line">    array[low] = array[i];</span><br><span class="line">    array[i] = temp;</span><br><span class="line">    <span class="comment">// 快排temp左半边</span></span><br><span class="line">    fastSort(array, low, j - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 快排temp右半边</span></span><br><span class="line">    fastSort(array, j + <span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>5.归并排序</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 归并排序算法</span></span><br><span class="line"><span class="comment">// 时间复杂度: 平均情况:o(nlog2^n) 最好情况:o(nlog2^n) 最坏情况:o(nlog2^n)</span></span><br><span class="line"><span class="comment">// 空间复杂度：o(1)</span></span><br><span class="line"><span class="comment">// 特点: 稳定</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">sortMerge</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    sort(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> array[], <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (R + L) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 排序左半部分</span></span><br><span class="line">    sort(array, L, mid);</span><br><span class="line">    <span class="comment">// 排序右半部分</span></span><br><span class="line">    sort(array, mid + <span class="number">1</span>, R);</span><br><span class="line">    <span class="comment">// 合并 </span></span><br><span class="line">    merge(array, L, mid, R);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> L, <span class="keyword">int</span> mid, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[R - L + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = L;</span><br><span class="line">    <span class="keyword">int</span> p2 = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 将数组排序后放入到临时数组temp中</span></span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= R) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[p1] &lt; array[p2]) &#123;</span><br><span class="line">            temp[i++] = array[p1++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[i++] = array[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p1 &lt;= mid) &#123;</span><br><span class="line">        temp[i++] = array[p1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p2 &lt;= R) &#123;</span><br><span class="line">        temp[i++] = array[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将临时数组中的元素移动到array中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; temp.length; k ++) &#123;</span><br><span class="line">        array[L + k] = temp[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;常见的排序算法&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1.插入排序&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;s
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="算法" scheme="https://zhilongao.github.io/categories/java/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="https://zhilongao.github.io/categories/java/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>jvm-command</title>
    <link href="https://zhilongao.github.io/wiki/jvm-command/"/>
    <id>https://zhilongao.github.io/wiki/jvm-command/</id>
    <published>2019-08-29T09:01:23.000Z</published>
    <updated>2019-08-31T04:00:56.547Z</updated>
    
    <content type="html"><![CDATA[<hr><p><code>jvm基本指令</code></p><table><thead><tr><th>基本指令</th><th>指令说明</th></tr></thead><tbody><tr><td>iconst_1</td><td>int型常量值1进栈</td></tr><tr><td>bipush</td><td>将一个byte型常量值推送至栈顶</td></tr><tr><td>iload_1</td><td>第二个int型局部变量进栈，从0开始计数</td></tr><tr><td>istore_1</td><td><em>将栈顶int型数值存入第二个局部变量，从<strong>0</strong>开始计数</em></td></tr><tr><td></td><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;&lt;code&gt;jvm基本指令&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;基本指令&lt;/th&gt;
&lt;th&gt;指令说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;iconst_1&lt;/td&gt;
&lt;td&gt;int型常量值1进
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="基础" scheme="https://zhilongao.github.io/categories/java/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="jvm" scheme="https://zhilongao.github.io/categories/java/%E5%9F%BA%E7%A1%80/jvm/"/>
    
    
  </entry>
  
  <entry>
    <title>dubbo</title>
    <link href="https://zhilongao.github.io/wiki/dubbo-ask/"/>
    <id>https://zhilongao.github.io/wiki/dubbo-ask/</id>
    <published>2019-08-28T11:57:42.000Z</published>
    <updated>2019-08-28T12:21:39.474Z</updated>
    
    <content type="html"><![CDATA[<p><code>协议</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;协议&lt;/code&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="分布式" scheme="https://zhilongao.github.io/categories/java/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>博客</title>
    <link href="https://zhilongao.github.io/wiki/share-articles/"/>
    <id>https://zhilongao.github.io/wiki/share-articles/</id>
    <published>2019-08-27T13:38:52.000Z</published>
    <updated>2019-09-10T06:31:34.768Z</updated>
    
    <content type="html"><![CDATA[<p><code>友情链接</code></p><p><a href="https://yapengren.github.io/" target="_blank" rel="noopener">任亚鹏的博客</a></p><p><code>技术大牛</code></p><p><a href="https://mercyblitz.github.io" target="_blank" rel="noopener">小马哥</a></p><p><code>精彩社区</code></p><p><a href="https://tech.meituan.com/" target="_blank" rel="noopener">美团技术团队</a></p><hr><p><a href="https://www.v2ex.com/" target="_blank" rel="noopener">v2ex</a></p><hr><p><a href="https://juejin.im/timeline" target="_blank" rel="noopener">掘金</a></p><hr><p><a href="http://cmsblogs.com/" target="_blank" rel="noopener">java技术驿站</a></p><hr><p><a href="https://www.infoq.cn/" target="_blank" rel="noopener">infoq</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;友情链接&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://yapengren.github.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;任亚鹏的博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;技术大牛&lt;/code&gt;&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>分库分表</title>
    <link href="https://zhilongao.github.io/wiki/mysql-split/"/>
    <id>https://zhilongao.github.io/wiki/mysql-split/</id>
    <published>2019-08-27T09:08:54.000Z</published>
    <updated>2019-08-28T03:14:43.225Z</updated>
    
    <content type="html"><![CDATA[<hr><p><code>数据库优化之分库分表</code></p><hr><p>针对数据库的优化有两点，第一是从整体层面优化，设计到读写分离和分库分表。第二是从sql层面优化，主要是涉及到索引相关的一些东西。</p><hr><p><code>读写分离</code></p><p>​    <code>需求</code>: 读写分离的目的是做数据冗余备份，同时将读写分离，提升数据库的服务性能（IO性能瓶颈）。</p><p>​    <code>搭建过程</code>: 在基本操作里面-&gt;mysql配置主从同步的步骤 。</p><p>​    <code>实现原理</code>:  首先是master数据库会先将数据库的变化存储在binlog文件中。在slave数据库上，会有一个IO Thread负责将binlog文件读取到内部的relaylog文件中。同时，slave数据库上的另外一个线程SQL Thread读取relaylog，将数据写入到slave数据库里面。</p><p>​    <code>细节</code>: mysql的binlog文件存储在 /var/lib/mysql文件夹下；使用命令-&gt; mysqlbinlog –base64-output=decode-rows -v  mysql-bin.000001 查看binlog的内容；binlog的格式：statement（默认，基于sql语句模式，针对数据更新的一些函数now()等，数据延迟造成的不一致），row：基于行模式，记录修改后每一条数据变化的值，mixed：混合模式，由mysql自动判断处理。</p><p>​    <code>问题</code>：同步延迟，master tps较高时出现同步延迟； 网络延迟；磁盘IO</p><hr><p><code>分库分表</code></p><p>​    <code>垂直拆分</code></p><p>​        <code>概念</code>:垂直拆分主要是通过业务层面，将各个业务模块所使用到的表放到各自不同的数据库里面，做到各个业务模块库相互隔离的目的。</p><p>​        <code>问题</code>:若是各个业务模块的表之间存在一些关联查询，需要将这些查询改为服务调用的方式。  针对一些全局表，可以改为服务调用的方式，对外提供服务。</p><p>​    <code>水平拆分</code></p><p>​        <code>概念</code>:将一张大的表拆分成n多张小表。实现方式，第一种是通过一致性hash（若是新增表的话，会涉及到数据迁移的问题）。第二种是可以按照id的范围来拆分。第三种是通过日期来拆分。</p><p>​        <code>问题</code>:唯一主键问题，可以使用zk自增id  可以使用redis的自增id  可以使用代理的id</p><hr><p><code>Mycat</code></p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1. 从github上面clone项目 https://github.com/MyCATApache/Mycat-Server.git</span><br><span class="line">2. 修改项目中schema.xml配置文件中的dataHost数据库配置节点信息，修改为可用的数据库</span><br><span class="line">3. MycatStartup类运行main函数启动</span><br><span class="line">idea启动前需要在配置参数VM options: -DMYCAT_HOME=D:<span class="tag">\<span class="name">code</span></span><span class="tag">\<span class="name">Mycat</span></span>-Server<span class="tag">\<span class="name">src</span></span><span class="tag">\<span class="name">main</span></span></span><br><span class="line">4. 通过数据库连接工具可以连接到MyCat,数据库相关配置在server.xml配置文件里面</span><br><span class="line">默认的用户名: root 密码: 123456 port: 8066</span><br><span class="line">5. mycat里面有三个比较重要的配置文件 </span><br><span class="line">server.xml配置数据库连接相关的一些信息</span><br><span class="line">schema.xml  配置数据库的一些节点信息</span><br><span class="line">rule.xml    配置一些路由规则</span><br><span class="line">6. 支持单库分表   支持跨库分表    支持配置读写分离(writeHost和readHost节点)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;&lt;code&gt;数据库优化之分库分表&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;针对数据库的优化有两点，第一是从整体层面优化，设计到读写分离和分库分表。第二是从sql层面优化，主要是涉及到索引相关的一些东西。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;code&gt;读写分离&lt;/code&gt;&lt;/
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="数据库" scheme="https://zhilongao.github.io/categories/java/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mysql" scheme="https://zhilongao.github.io/categories/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>基本操作</title>
    <link href="https://zhilongao.github.io/wiki/mysql-base/"/>
    <id>https://zhilongao.github.io/wiki/mysql-base/</id>
    <published>2019-08-27T09:08:25.000Z</published>
    <updated>2019-08-27T12:58:54.756Z</updated>
    
    <content type="html"><![CDATA[<hr><p><code>centos7上mysql的安装步骤</code></p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.下载mysql的repo源  &gt; wget http://repo.mysql.com/mysql57-community-release-el7-8.noarch.rpm</span><br><span class="line">2.安装源&gt; rpm -ivh mysql57-community-release-el7-8.noarch.rpm</span><br><span class="line">3.安装数据库-&gt;yum install mysql-server</span><br><span class="line">4.启动数据库&gt; systemctl start mysqld</span><br><span class="line">5.查看mysql为root账号生成的随机密码&gt;grep "password" /var/log/mysqld.log</span><br><span class="line">  说明root@localhost:此处为随机密码</span><br><span class="line">6.运行mysql -uroot -p回车</span><br><span class="line">7.粘贴随机密码-&gt;此时已经登录到mysql数据库，需要为root账号设置密码</span><br><span class="line">8.由于mysql5.7有对密码设置的验证，简单密码设置不了，需要运行下面两条命令关闭验证</span><br><span class="line">&gt; set global validate_password_length=1;</span><br><span class="line">&gt; set global validate_password_policy=0;</span><br><span class="line">9.修改root账号的密码</span><br><span class="line">&gt; set password = password('123456');</span><br><span class="line">10.修改root账号的权限</span><br><span class="line">    &gt; GRANT ALL PRIVILEGES ON *.* TO 'root'@'<span class="comment">%' IDENTIFIED BY 'root' WITH GRANT OPTION;</span></span><br><span class="line">11.可以创建一个其它的用户</span><br><span class="line">&gt; create user repl identified by 'repl';</span><br><span class="line">12.为该用户授权</span><br><span class="line">    &gt; grant replication slave on *.* to 'repl'@'<span class="comment">%' identified by 'repl';(数据同步的权限)</span></span><br><span class="line">    &gt; GRANT ALL ON *.* TO 'pig'@'<span class="comment">%';(为用户pig授予所有权限)</span></span><br></pre></td></tr></table></figure><p><code>mysql配置主从同步的步骤</code></p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.在master服务器上创建一个可以进行数据同步的账户。</span><br><span class="line">&gt; create user repl identified by 'repl';</span><br><span class="line">2.在master服务器上为该用户授权。</span><br><span class="line">&gt; grant replication slave on *.* to 'repl'@'<span class="comment">%' identified by 'repl';</span></span><br><span class="line">3.在master服务器上修改/etc/my.cnf文件。</span><br><span class="line">[mysqld]</span><br><span class="line">log-bin=mysql-bin</span><br><span class="line">server-id=147</span><br><span class="line">4.在master上面重启mysql</span><br><span class="line">&gt; systemctl restart mysqld</span><br><span class="line">5.在master上登录数据库，使用下面命令查看二进制文件。</span><br><span class="line">&gt; show master status;</span><br><span class="line">6.在slave服务器上修改/etc/my.cnf文件</span><br><span class="line">[mysqld]</span><br><span class="line">server-id=149</span><br><span class="line">relay-log=slave-relay-bin</span><br><span class="line">relay-log-index=slave-relay-bin.index</span><br><span class="line">read-only=1</span><br><span class="line">7.在slave服务器上重启mysql</span><br><span class="line">&gt; systemctl restart mysqld</span><br><span class="line">8.在slave上登录数据库,执行下列命令，设置master相关参数。</span><br><span class="line">&gt; change master to master_host='192.168.25.147',master_port=3306,master_user='repl',master_password='repl',master_log_file='mysql-bin.000003', master_log_pos=154;</span><br><span class="line">9.在slave上运行命令，启动服务</span><br><span class="line">&gt; start slave;</span><br><span class="line">10.查看状态，查看主从同步设置是否成功</span><br><span class="line">&gt; show slave status<span class="tag">\<span class="name">G</span></span>;</span><br><span class="line">11.搭建完成，现在就可以玩啦，尝试在master上面创建数据库和表，在slave上会看到相应的数据库和表。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;&lt;code&gt;centos7上mysql的安装步骤&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight tex&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1.下载mysql的repo
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="数据库" scheme="https://zhilongao.github.io/categories/java/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mysql" scheme="https://zhilongao.github.io/categories/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>索引</title>
    <link href="https://zhilongao.github.io/wiki/mysql-index/"/>
    <id>https://zhilongao.github.io/wiki/mysql-index/</id>
    <published>2019-08-27T09:08:17.000Z</published>
    <updated>2019-08-27T09:51:54.005Z</updated>
    
    <content type="html"><![CDATA[<p><code>1.数据库四大特性</code></p><p>​    A( Atomicity 原子性):  数据库最小的工作单元，整个工作单元要么一起提交成功,要么一起失败回滚。<br>​    C( Consistency 一致性):  事物中操作的数据的状态是一致的。即写入数据的结果必须完全符合预设的规则，不会因为出现系统意外等原因导致状态的不一致。<br>​    I( Isolation 隔离性):  一个事务所操作的数据在提交之前，对其他事务的可见性设定（一般设定为不可见）。<br>​    D( Durability 持久性):  数据库的数据一旦提交,无法更改。</p><p><code>2.多个事物并发引起的数据读取问题</code></p><p>​    脏读:  是指一个事物读取到了另外一个事物未提交的数据。<br>​    不可重复读:  是指在一个事物未结束之前, 前后两次读取到的数据不一致现象。原因在于该事物在前后两次读取数据之间，另外一个事物修改了该数据。(不可重复读的重点在于修改)。<br>​    幻读:  是指当一个事物修改了数据库表中某一个范围内的数据的某一个字段，但是另外一个事物在此期间又在该范围内插入了一条新的数据，造成前一个事物出现幻觉(没有完全修改)。(幻读的重点在于新增或删除) 。</p><p><code>3.数据库事物的隔离级别</code></p><p>  Read Uncommited 读未提交:  事物未提交对其它的事物也是可见的。<br>  Read Commited 读已提交:  一个事物只能够读取到已提交的数据。(解决脏读, 未解决不可重复读)。<br>  Repeatable Read 可重复读:  一个事物对数据的前后读取结果是一致的。(解决了不可重复读, 未解决幻读)。<br>  Serializable 串行化:  数据库最高的隔离级别,  强制所有事物串行执行,解决了所有并发问题。</p><p><code>4.聚集索引和非聚集索引的区别</code><br>    聚集索引:  表中的数据是按照索引的顺序来存储的。索引的叶子节点上存储了真实的数据,不会有另外单独的数据页。<br>    非聚集索引:  表中的数据存储不依赖于索引的顺序。索引的叶子节点上存储了索引的关键字和指向真实数据的指针。   </p><p><code>5.sql调优</code></p><p>​    a. 创建索引  b.使用临时表存储中间结果-&gt;(避免多次扫描主表)。c. 避免在索引上使用计算。4.少使用select *，只返回需要的字段。</p><p><code>6.如何理解MVCC</code>   </p><p>​    a. 数据库每张表会单独维护两个字段，数据行版本号和删除版本号。   </p><p>​    b. 当执行insert操作时，我们开启了一个事物，执行数据插入操作时，会将这个事物的事物id设置到数据行版本号这个字段中（这个事物的事物id属于数据库一个全局属性，自增）。</p><p>​    c. 当执行delete操作时，我们开启了一个事物，执行数据删除操作时，会将这个事物的事物id设置到删除版本号这个字段中。</p><p>​    d. 当执行update操作时，我们开启了一个事物，指定数据更新操作时，会将这行数据copy一份，copy的这份数据数据行版本号为当前事物id，删除版本号为Null，并更新相关字段。原先那行的删除版本号会被设置为当前的事物id。</p><p>​    e.  当我们执行数据库查询时，满足以下两点要求：</p><p>​        e1：查找数据的数据行版本号小于或等于当前事物id。(保证该条数据在当前事物开启之前就已经存在或者为该事物添加的数据。</p><p>​        e2：查找数据的删除版本号为Null或者删除版本号大于当前事物id。（该条规则可以确保当前事物在开始之前数据还未被删除。</p><p><code>7.MVCC解决的问题与未解决的问题</code></p><p>   若是一个查询先于一行的数据更新，不会出现问题。若是一个查询后于一行的数据更新，会产生脏读的问题。</p><p><code>8.Innodb数据库的四种隔离级别是如何实现的</code></p><p>​    读未提交：对select操作不会加锁，并发性能是最好的，但是容易造成脏读。</p><p>​    读已提交（互联网上默认的隔离级别）：普通的数据读取是会直接读取数据快照，加锁的select，update等操作会使用记录锁。注意：读已提交读取快照时，一个事物读取了数据，但是当第二次读取的时候，另外一个事物已经将该快照刷新了，所以会造成不可重复读的问题。</p><p>​    可重复读（Innodb默认的事物隔离级别）：对于普通的数据库查询，使用读取快照的方式。对于加锁的select,update等语句，他们加锁的力度取决于查询条件是使用了唯一索引还是使用了范围查询。若是使用了唯一索引，会使用记录锁的方式。若是使用了范围查询，会使用间隙锁，避免发生不可重复读。注意:当一个事物开启读取数据时，前后两次读取的都是同一个快照，这样就可以实现了可重复读。</p><p>​    串行化：针对所有的操作都会去加锁，普通的select操作会去加共享锁-&gt;select * from table in share mode。对于 update 等操作会加排他锁。若是一个事物查询操作时，正好有一个事物对改行的数据做修改操作。则该查询操作会阻塞，直到更新操作执行完成。</p><p><code>9.如何理解快照读和当前读</code></p><p>​    快照读：读取的数据是快照。当前读：读取的数据是数据库的最新的数据。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;1.数据库四大特性&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;​    A( Atomicity 原子性):  数据库最小的工作单元，整个工作单元要么一起提交成功,要么一起失败回滚。&lt;br&gt;​    C( Consistency 一致性):  事物中操作的数据的状态是一致的。
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="数据库" scheme="https://zhilongao.github.io/categories/java/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mysql" scheme="https://zhilongao.github.io/categories/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>tcp</title>
    <link href="https://zhilongao.github.io/wiki/tcp/"/>
    <id>https://zhilongao.github.io/wiki/tcp/</id>
    <published>2019-08-26T13:33:14.000Z</published>
    <updated>2019-08-28T12:55:39.134Z</updated>
    
    <content type="html"><![CDATA[<hr><p><code>此时握手</code></p><p><code>四次挥手</code></p><p><code>为什么要三次握手</code></p><p><code>为什么要四次挥手</code></p><p><code>socket的几种状态</code></p><p>​        <code>listen:侦听来自远方tcp端口的连接请求</code></p><p>​        <code>syn-sent:在发送连接请求后，等待匹配的连接请求。</code></p><p>​        <code>syn-receive:在收到和发送一个连接请求后，等待连接请求的确认</code></p><p>​        <code>established:代表一个打开的连接，数据可以传送给用户</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;&lt;code&gt;此时握手&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;四次挥手&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;为什么要三次握手&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;为什么要四次挥手&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;socket的几种状态&lt;/code&gt;
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="分布式" scheme="https://zhilongao.github.io/categories/java/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="协议" scheme="https://zhilongao.github.io/categories/java/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%8D%8F%E8%AE%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>project-ask</title>
    <link href="https://zhilongao.github.io/wiki/project-ask/"/>
    <id>https://zhilongao.github.io/wiki/project-ask/</id>
    <published>2019-08-26T13:26:32.000Z</published>
    <updated>2019-09-05T03:01:01.061Z</updated>
    
    <content type="html"><![CDATA[<p><code>项目专题</code></p><p><code>系统1</code></p><p>​    <code>系统数据流转</code></p><p>​    <img src="https://raw.githubusercontent.com/zhilongao/images-repository/master/3153f3dae0ac8b3014874267ad70cc1.png" alt="任务执行流程"></p><p>​    </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 大体流程</span></span><br><span class="line"><span class="number">1</span>. 从原始借据表bp_collect_loan_src同步数据到bp_collect_loan，同步批次号为batch_no的数据。(同步数据时，每个线程处理数量默认为<span class="number">10000</span>，若是当前批次数据量超过<span class="number">10000</span>，会采用多线程来执行)</span><br><span class="line"><span class="number">2</span>. 针对每一个原始借据，数据库里面只有可能有一条与之对应的借据，所以将bp_collect_loan存入数据库的操作采用的是insertOrUpdate操作(任务执行失败后，不会对数据库中的数据造成影响)。</span><br><span class="line"><span class="number">3</span>. 借据同步完成之后，需要执行归案任务，就是将多个借据加工成为一个案件，以人为维度进行催收。</span><br><span class="line"><span class="number">4</span>. 归案完成之后，需要跑规则引擎来执行分案，通过规则引擎分案之后，会在数据库表bp_collect_divide表里面生成分案记录。</span><br><span class="line"><span class="number">5</span>. 将这些分案记录针对案件进行分案(分案记录里面存储了两类，针对个人的分案，针对组的分案)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用到的技术点(分布式锁 redis队列)</span></span><br><span class="line"><span class="number">1</span>. 由于任务是部署在多台机器上的，多个进程执行任务时，需要获取分布式锁。项目中采用redis来实现了分布式锁，上锁命令采用set命令，外加是否存在，过期时间参数来实现。而释放锁的命令采用lua脚本来实现，因为会有两步骤操作，首先式判断上锁客户端和释放锁的客户端是否一致（存储在value中），其次是删除该锁对应的key，lua脚本保证了该操作的原子性。</span><br><span class="line"><span class="number">2</span>. 在执行归案的过程中，针对每一个案件，需要将该案件分出去，会过规则引擎。而将分案请求交给规则引擎有两种方式，第一种是先将该案件构建成为请求，然后将该请求放到redis的同步队列里面，规则引擎那边从同步队列里面来进行消费。第二种是若同步队列已满，或者放入到同步队列出错，则会将请求直接交给规则引擎来处理。</span><br><span class="line"></span><br><span class="line"><span class="comment">// 技术难点-如何克服</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;项目专题&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;系统1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;​    &lt;code&gt;系统数据流转&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;​    &lt;img src=&quot;https://raw.githubusercontent.com/zhilong
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="项目" scheme="https://zhilongao.github.io/categories/java/%E9%A1%B9%E7%9B%AE/"/>
    
    
  </entry>
  
</feed>
