<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zl&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhilongao.github.io/"/>
  <updated>2019-11-03T08:04:04.265Z</updated>
  <id>https://zhilongao.github.io/</id>
  
  <author>
    <name>gaozhilong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>spring-base-environment</title>
    <link href="https://zhilongao.github.io/wiki/spring-base-environment/"/>
    <id>https://zhilongao.github.io/wiki/spring-base-environment/</id>
    <published>2019-10-29T13:46:46.000Z</published>
    <updated>2019-11-03T08:04:04.265Z</updated>
    
    <content type="html"><![CDATA[<p>在spring框架中对于配置文件的配置属性，java的系统属性，以及系统的环境变量，都抽象在了<code>Environment</code>接口中，通过该接口可以获取我们之前配置好的一些属性。下面是关于<code>Environment</code>接口的简单使用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建 Environment 对象</span></span><br><span class="line">    StandardEnvironment environment = <span class="keyword">new</span> StandardEnvironment();</span><br><span class="line">    <span class="comment">// 2. 在environment中存储了类型为 PropertySources类型的属性，该属性中存储 PropertySource列表</span></span><br><span class="line">    MutablePropertySources propertySources = environment.getPropertySources();</span><br><span class="line"><span class="comment">// 3. 创建第一个 PropertySource</span></span><br><span class="line">    Map&lt;String, Object&gt; mapA = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">    mapA.put(<span class="string">"java"</span>, <span class="string">"version7"</span>);</span><br><span class="line">    PropertySource propertySourceA = <span class="keyword">new</span> MapPropertySource(<span class="string">"mapA"</span>, mapA);</span><br><span class="line"><span class="comment">// 4. 创建第二个 PropertySource</span></span><br><span class="line">    Map&lt;String, Object&gt; mapB = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">    mapB.put(<span class="string">"java"</span>, <span class="string">"version8"</span>);</span><br><span class="line">    PropertySource propertySourceB = <span class="keyword">new</span> MapPropertySource(<span class="string">"mapB"</span>, mapB);</span><br><span class="line"><span class="comment">// 5.将 PropertySource添加到 propertySources中</span></span><br><span class="line">    propertySources.addLast(propertySourceA);</span><br><span class="line">    propertySources.addLast(propertySourceB);</span><br><span class="line">    System.out.println(environment.getProperty(<span class="string">"java"</span>));</span><br><span class="line">    <span class="comment">// 输出 version7</span></span><br><span class="line">    </span><br><span class="line">    propertySources.addLast(propertySourceA);</span><br><span class="line">    propertySources.addFirst(propertySourceB);</span><br><span class="line">    System.out.println(environment.getProperty(<span class="string">"java"</span>));</span><br><span class="line">    <span class="comment">// 输出 version8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在spring框架中对于配置文件的配置属性，java的系统属性，以及系统的环境变量，都抽象在了&lt;code&gt;Environment&lt;/code&gt;接口中，通过该接口可以获取我们之前配置好的一些属性。下面是关于&lt;code&gt;Environment&lt;/code&gt;接口的简单使用。&lt;/p
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="框架" scheme="https://zhilongao.github.io/categories/java/%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>ClassLoader</title>
    <link href="https://zhilongao.github.io/wiki/java-base-classloader/"/>
    <id>https://zhilongao.github.io/wiki/java-base-classloader/</id>
    <published>2019-10-13T03:19:08.000Z</published>
    <updated>2019-11-03T08:00:06.887Z</updated>
    
    <content type="html"><![CDATA[<h6 id="类加载器的区别"><a href="#类加载器的区别" class="headerlink" title="类加载器的区别"></a><code>类加载器的区别</code></h6><p>java中提供了三种类加载器，分别是启动类加载器，扩展类加载器，系统类加载器。三种类加载器通过双亲委派机制来实现类的加载。</p><table><thead><tr><th>类加载器</th><th>名称</th><th>加载路径</th><th>实现</th></tr></thead><tbody><tr><td>启动类加载器</td><td>BootStrap ClassLoader</td><td>核心库：java.lang.*，系统属性：sun.boot.class.path所指路径</td><td>c++</td></tr><tr><td>扩展类加载器</td><td>Extension ClassLoader</td><td>扩展库：jre\lib\ext 目录下的包，系统属性：java.ext.dirs所指路径</td><td>纯java</td></tr><tr><td>系统类加载器</td><td>System ClassLoader</td><td>环境变量 classpath 或系统属性 java.class.path 指定目录中加载类</td><td>纯java</td></tr></tbody></table><hr><h6 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a><code>双亲委派机制</code></h6><p>类的双亲委派机制是指子类加载器加载类时，首先会检查该类是否已经被加载。若是该类未被加载，会将加载任务委托给父类加载器，父类加载器又会委托给更上一层类加载器，直到启动类加载器。启动类加载器会检查其加载路径，有则加载，无则加载任务给扩展类加载器，扩展类有会检查路径并执行加载。</p><hr><h6 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a><code>自定义类加载器</code></h6><p>在测试之前，需要将<code>Test.java</code>编译成<code>Test.class</code>文件，将该文件放如到路径<code>D:\jar\com\study\zl\classloader</code>下，并将项目中的<code>Test.java</code>和<code>Test.class</code>文件删除，以免该类被系统类加载器加载到。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study.zl.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/10/13 10:24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException </span>&#123;</span><br><span class="line">        SelfClassLoader selfClassLoader = <span class="keyword">new</span> SelfClassLoader(<span class="string">"D:\\jar"</span>);</span><br><span class="line">        Class&lt;?&gt; cls = selfClassLoader.loadClass(<span class="string">"com.study.zl.classloader.Test"</span>);</span><br><span class="line">        <span class="keyword">if</span> (cls != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 创建一个cls类型的对象</span></span><br><span class="line">            Object o = cls.newInstance();</span><br><span class="line">            <span class="comment">// 获取该对象的say方法</span></span><br><span class="line">            Method say = cls.getMethod(<span class="string">"say"</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">// 调用该类型的say方法</span></span><br><span class="line">            say.invoke(o, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">// 查看 cls 的类加载器</span></span><br><span class="line">            System.out.println(cls.getClassLoader().toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="comment">// hello,world</span></span><br><span class="line">    <span class="comment">// com.study.zl.classloader.SelfClassLoader@7f31245a</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.study.zl.classloader;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello,world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义一个类加载器，该类加载器继承自<code>ClassLoader</code>，重写 <code>findClass</code> 方法来获取 <code>Class</code>。该方法首先会调用<code>getData</code>方法来获取类的字节码，然后调用父类的<code>defineClass</code>方法将字节码转化未 <code>Class</code>并返回。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study.zl.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/10/13 10:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String classpath;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SelfClassLoader</span><span class="params">(String classpath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.classpath = classpath;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] data = getData(name);</span><br><span class="line">            <span class="keyword">if</span> (data != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 调用 defineClass 方法将字节码转化为Class</span></span><br><span class="line">                <span class="keyword">return</span> defineClass(name, data, <span class="number">0</span> , data.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.findClass(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回类的字节码</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> className</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getData(String className) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        InputStream in = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">        String path = classpath + File.separatorChar + className.replace(<span class="string">'.'</span>, File.separatorChar) + <span class="string">".class"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">            out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2048</span>];</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((len = in.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                out.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> out.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            in.close();</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h6 id="资源文件的读取"><a href="#资源文件的读取" class="headerlink" title="资源文件的读取"></a><code>资源文件的读取</code></h6><p>在 java 中可以使用 Class 或者是 ClassLoader 读取资源文件。比如现在项目的<code>resources</code>目录下面有一个 <code>application.properties</code>文件，可以使用项目中某个类的<code>class.getResource</code>方法或者某个类的类加载器<code>class.getClassLoader().getResource</code>方法。方法所传资源文件路径是向对于<code>resources</code>的目录。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study.zl.classloader.p2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/10/13 14:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class&lt;App&gt; appClass = App.class;</span><br><span class="line">        <span class="comment">// 通过 class 获取资源时，必须有 / ,否则会从该类所在包下面读取</span></span><br><span class="line">        URL resource1 = appClass.getResource(<span class="string">"/application.properties"</span>);</span><br><span class="line">        <span class="comment">// 通过 ClassLoader 读取资源，所不同的是 ClassLoader 还有一个 getResources 方法</span></span><br><span class="line">        URL resource2 = appClass.getClassLoader().getResource(<span class="string">"application.properties"</span>);</span><br><span class="line">        System.out.println(resource1.toString());</span><br><span class="line">        System.out.println(resource2.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="comment">// file:/D:/code/struct-parent/interview-ready/target/classes/application.properties</span></span><br><span class="line">    <span class="comment">// file:/D:/code/struct-parent/interview-ready/target/classes/application.properties</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h6 id="读取Properties文件"><a href="#读取Properties文件" class="headerlink" title="读取Properties文件"></a><code>读取Properties文件</code></h6><p>在spring核心包中提供了一个工具类<code>PropertiesLoaderUtils</code>，该工具类可以将<code>ClassLoader</code>读取到的资源转换未<code>Properties</code>文件。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  pom.xml文件引入 spring framework 核心包依赖</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-core&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.5.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// application.properties文件加入内容</span></span><br><span class="line">#Tue Jun 18 23:47:55 GMT 2019</span><br><span class="line">server.port=<span class="number">8080</span></span><br><span class="line">server.name=spring-boot-application</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.study.zl.classloader.p2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.UrlResource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.PropertiesLoaderUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/10/13 14:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class&lt;App&gt; appClass = App.class;</span><br><span class="line">        <span class="comment">// 定义Properties对象</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 读取资源集合</span></span><br><span class="line">            Enumeration&lt;URL&gt; urls = appClass.getClassLoader().getResources(<span class="string">"application.properties"</span>);</span><br><span class="line">            <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">                <span class="comment">// 使用工具类加载</span></span><br><span class="line">                properties.putAll(PropertiesLoaderUtils.loadProperties(<span class="keyword">new</span> UrlResource(urls.nextElement())));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出</span></span><br><span class="line">        System.out.println(properties);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="comment">// &#123;server.port=8080, server.name=spring-boot-application&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;类加载器的区别&quot;&gt;&lt;a href=&quot;#类加载器的区别&quot; class=&quot;headerlink&quot; title=&quot;类加载器的区别&quot;&gt;&lt;/a&gt;&lt;code&gt;类加载器的区别&lt;/code&gt;&lt;/h6&gt;&lt;p&gt;java中提供了三种类加载器，分别是启动类加载器，扩展类加载器，系统类加载
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="基础" scheme="https://zhilongao.github.io/categories/java/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="ClassLoader" scheme="https://zhilongao.github.io/categories/java/%E5%9F%BA%E7%A1%80/ClassLoader/"/>
    
    
  </entry>
  
  <entry>
    <title>CountDownLatch</title>
    <link href="https://zhilongao.github.io/wiki/ans-countdownlatch-source/"/>
    <id>https://zhilongao.github.io/wiki/ans-countdownlatch-source/</id>
    <published>2019-09-30T13:29:36.000Z</published>
    <updated>2019-10-08T12:24:10.408Z</updated>
    
    <content type="html"><![CDATA[<h6 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><code>应用场景</code></h6><p>① 下一步的任务需要等待上一步任务执行完成才能执行的场景。比如：有一批任务交给线程池来处理，我们需要知道任务从开始到结束一共执行了多长的时间。下面的代码展示了这种场景的使用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unite</span><span class="params">(JobExecutionContext jobContext)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Set&lt;String&gt; batchNoSet = getBatchSet(jobContext);  </span><br><span class="line">    Set&lt;String&gt; idCardSet = updateLoanInfoFromSrc(batchNoSet);</span><br><span class="line">    <span class="comment">// 任务开始之前获取到系统现在的时间</span></span><br><span class="line">    Long start = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 创建 CountDownLatch 对象，以任务个数做为该对象的初始化参数</span></span><br><span class="line">    CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(idCardSet.size());</span><br><span class="line">    <span class="keyword">for</span> (String idCard : idCardSet) &#123;</span><br><span class="line">        <span class="comment">// 创建任务线程</span></span><br><span class="line">        CaseUnitedThread thread = <span class="keyword">new</span> CaseUnitedThread(idCard.trim(), latch);</span><br><span class="line">        <span class="comment">// 任务交给线程池处理-&gt;每执行一次任务，CountDownLatch对象的 state值减去1</span></span><br><span class="line">        threadPool.execute(thread);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待归户完毕</span></span><br><span class="line">    latch.await();</span><br><span class="line">    logger.info(<span class="string">"case united finish: total time = &#123;&#125;"</span>, System.currentTimeMillis() - start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a><code>源码分析</code></h6><hr><p><code>类结构</code></p><p><code>CountDownLatch</code>类内部定义比较简单，有一个类型为<code>Sync:sync</code>属性，而<code>CountDownLatch</code>最重要的两个方法<code>countDown</code>和<code>await</code>的内部实现是由<code>Sync:sync</code>来完成的。而<code>Sync</code>类又继承自<code>AQS</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// jdk1.8</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatch</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 内部属性，相关操作会交由该对象来完成</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">    <span class="comment">// 构造函数，初始化 sync 属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 参数值必须大于等于0</span></span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">        <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 静态内部类，继承了AQS</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对外提供的构造函数，初始化对象时，会将 AQS 中的 state 值设置为 count</span></span><br><span class="line">        Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">            setState(count);</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">        <span class="comment">// 尝试获取共享锁，若是 state 值为0，返回 1，否则返回 -1</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 尝试释放共享锁</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 自旋，可能多个线程同时尝试释放共享锁，同时修改 state 值，造成线程安全问题</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> c = getState();</span><br><span class="line">                <span class="comment">// 若是 state 的值已经为 0，则尝试释放共享锁失败。</span></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">               <span class="comment">// 通过 CAS 操作将原有 state 的值减去1，失败重试</span></span><br><span class="line">                <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc)) &#123;</span><br><span class="line">                    <span class="comment">// state值为0时，返回 true</span></span><br><span class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><code>countDown方法</code></p><p>当某个线程调用<code>CountDownLatch</code> 的 <code>countDown</code>方法时，内部操作的原理其实是将<code>AQS</code>中的<code>state</code>属性值减<code>1</code>。</p><hr><p>① 当一个线程调用<code>countDown</code>方法时，该方法内部会调用<code>Sync:sync</code>的<code>releaseShared(int arg)</code>方法。而<code>releaseShared(int arg)</code>方法则是由<code>Sync</code>的父类<code>AQS</code>定义的方法。</p><p>② <code>AQS</code>的<code>releaseShared(int arg)</code>方法首先调用<code>tryReleaseShared(int arg)</code>方法，该方法在<code>AQS</code>中是一个空方法，具体逻辑在其子类<code>Sync</code>中实现。</p><p>③ <code>Sync</code>的<code>tryReleaseShared(int arg)</code>方法尝试释放共享锁。由于可能会有多个线程同时调用<code>countDown</code>方法修改<code>state</code>的值，故对<code>state</code>值的修改需要使用<code>自旋</code>加<code>CAS</code>操作。若修改前读到<code>state</code>的值为<code>0</code>，直接返回<code>false</code>。若修改前<code>state</code>的值不为<code>0</code>，通过<code>CAS</code>操作将其值修改为<code>state-1</code>，若修改后的值为<code>0</code>，返回<code>true</code>。</p><p>④ 第 ③ 方法其实是执行了两个操作，第一是将<code>state</code>的值减去<code>1</code>，第二是判断修改后的<code>state</code>值是否为<code>0</code>。若是第 ③ 步返回值为<code>true</code>，证明<code>state</code>的值已经为<code>0</code>，可以做一些操作来唤醒调用<code>await</code>方法的线程。故第 ② 步判断返回值为<code>true</code>的话，执行<code>doReleaseShared()</code>方法。</p><hr><p>⑤ <code>doReleaseShared</code>释放共享锁，一段自旋操作。① 该方法首先获取到头节点，使用变量<code>h</code>保存。若是当前<code>h</code>节点不为空并且<code>h</code>节点不等于尾节点时，执行操作（这么判断的原因在于，若是头节点等于尾节点，就没必要唤醒线程。因为若是只有一个头节点时，没有需要唤醒的线程）。② 若节点<code>h</code>的<code>waitStatus</code>属性值为<code>Node.SIGNAL</code>，则<code>CAS</code>操作将其设置为<code>0</code>。若设置成功，调用<code>unparkSuccessor</code>方法唤醒线程。若设置失败，继续执行<code>for</code>循环。③ 若节点<code>h</code>的<code>waitStatus</code>属性值为<code>0</code>，则通过<code>CAS</code>操作将其设置为<code>Node.PROPAGATE</code>。若设置失败，继续执行<code>for</code>循环。若设置成功，继续执行后面的语句，即当<code>h==head</code>时，跳出<code>for</code>循环。</p><p>⑥ 在上述步骤 ⑤ 中，将<code>waitStatus</code>状态值由<code>Node.SIGNAL</code>设置为<code>0</code>成功后，调用了<code>unparkSuccessor</code>方法，该方法会唤醒传入节点的下一个节点的线程。① 该方法首先会获取到传入节点<code>node</code>的<code>waitStatus</code>属性值，若是该值小于<code>0</code>，通过<code>CAS</code>操作将该值修改为<code>0</code>。② 获取到<code>node</code>节点的下一个节点<code>s</code>，该节点需要是<code>waitStatus</code>属性值小于等于<code>0</code>的。③ 调用<code>LockSupport</code>的<code>unpark</code>方法唤醒<code>s</code>节点所对应的线程。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CountDownLatch</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 调用sync的releaseShared方法</span></span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AQS</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// tryReleaseShared</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AQS</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sync</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自旋，可能多个线程同时尝试释放共享锁，同时修改 state 值，造成线程安全问题</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// 若是 state 的值已经为 0，则尝试释放共享锁失败。</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过 CAS 操作将原有 state 的值减去1，失败重试</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc)) &#123;</span><br><span class="line">            <span class="comment">// state值为0时，返回 true</span></span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS-&gt; 释放共享模式的动作</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 保存头节点</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">// 头节点不为空并且头节点不为尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="comment">// 获取到头节点的等待状态</span></span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="comment">// 若是头节点的等待状态为SIGNAL</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">// 节点的状态由 Node.SIGNAL更新为0失败，继续执行自旋</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="comment">// 节点状态由 Node.SIGNAL更新为0成功，调用unparkSuccessor(Node node)唤醒后继节点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="comment">// 若是该节点的状态为0，并且由0设置为PROPAGATE失败，继续执行自旋   </span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp; !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="comment">// ws小于0的状态有三个 SIGNAL(-1) CONDITION(-2) PROPAGATE(-3)</span></span><br><span class="line">    <span class="comment">// 若是 ws 小于0,CAS操作将其修改为0</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// ws大于0仅有一种情况，即 CANCELLED(1)</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 从尾节点找到一个距离node节点最近的状态值&lt;=0的节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                s = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若是该节点不为null，直接唤醒该节点线程</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><code>await</code></p><p>当一个线程调用一个<code>CountDownLatch</code>对象的<code>await</code>方法时，该线程会等到其<code>state</code>值为<code>0</code>时执行，否则不会执行。</p><p>① 当调用 <code>CountDownLatch</code> 的 <code>await</code> 方法时，会调用<code>Sync:sync</code>的<code>acquireSharedInterruptibly(int arg)</code>方法，而<code>acquireSharedInterruptibly(int arg)</code>方法是由<code>Sync:sync</code>的父类<code>AQS</code>定义的方法。</p><p>② <code>AQS</code>的<code>acquireSharedInterruptibly(int arg)</code>方法首先会去判断当前线程是否被中断，若是当前线程已经被中断，则直接抛出中断异常。若是当前线程没被中断，会去调用<code>tryAcquireShared(int arg)</code>方法。而该<code>tryAcquireShared(int arg)</code>方法在<code>AQS</code>中是一个空方法，具体的逻辑是由子类<code>Sync</code>来实现的。</p><p>③ <code>Sync</code>重写父类的<code>tryAcquireShared(int arg)</code>方法，其方法的目的就是判断当前<code>state</code>的值是否为<code>0</code>，若是该值为<code>0</code>，返回<code>1</code>，否则返回<code>-1</code>。</p><p>④ 步骤 ② 会根据步骤 ③ 方法返回的值进行判断。若是返回值不小于<code>0</code>，该方法什么也不做（不会挂起当前的线程）；若是返回值小于<code>0</code>，证明<code>state</code>的值不为<code>0</code>，当前线程不能执行，需要执行进一步的操作，即调用<code>doAcquireSharedInterruptibly(int arg)</code>方法。</p><hr><p>⑤ <code>doAcquireSharedInterruptibly</code>方法，添加到等待队列，AQS里面的方法。① 该方法首先会在队列中添加一个共享模式的节点。② 一段自旋操作，获取到该节点<code>node</code>的前一个节点<code>p</code>，若是<code>p</code>节点正好为<code>head</code>节点，调用<code>tryAcquireShared</code>方法尝试获取共享锁（<code>state</code>为<code>0</code>返回<code>1</code>，否则返回<code>-1</code>）,若是获取共享锁成功，调用<code>setHeadAndPropagate</code>方法，该方法可能会唤醒当前线程。 ③ 若是上一步操做获取共享锁失败，首先调用<code>shouldParkAfterFailedAcquire</code>方法判断当前线程是否可以被挂起。若是该方法返回值为<code>true</code>，调用<code>parkAndCheckInterrupt</code>方法挂起当前线程，并返回当前线程的中断标识。若是中断标识为<code>true</code>，立即抛出中断异常。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CountDownLatch</span></span><br><span class="line"><span class="comment">// 1.委托给sync的acquireSharedInterruptibly方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AQS</span></span><br><span class="line"><span class="comment">// 2.尝试获取，若获取不到在调用doAcquireSharedInterruptibly方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 若是当前线程已经被中断，直接抛出中断异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 若是当前 state的值不为0</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AQS</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// CountDownLatch-Sync</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 若是当前 state 的值为0，返回1，否则返回-1</span></span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS-&gt;获取共享锁的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 将当前线程封装成为 Node 节点，添加到等待队列(此时waitStatus值为0)</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="comment">// 判断是否执行失败的标识，失败时会将该节点清除</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取 node 节点的前一个节点p</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 若是节点p为等待队列的头节点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">// 若是p为头节点，尝试一下获取共享锁(具体逻辑由Sync实现)</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line"><span class="comment">// r &gt;= 0 证明 state 的值已经为 0，即获取到了共享锁。CountDownLatch:Sync返回1</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>;</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 1. 当获取锁失败后判断是否需要挂起线程</span></span><br><span class="line">            <span class="comment">// 2. 若是需要挂起线程，则挂起线程并检查中断</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 若是执行失败，调用 cancelAcquire(Node node)方法将这个节点从等待队列中删除</span></span><br><span class="line">        <span class="keyword">if</span> (failed) &#123;</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在自旋操作期间成功获取到共享锁执行的操作(此处传入的propagate值为1,节点为当前节点新加入队列的节点)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 首先保留原始头节点，然后将当前的节点设置为头节点</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="comment">// 已经将node节点设置为了头结点，需要唤醒下一个节点啦</span></span><br><span class="line">    <span class="comment">// 1.若是传入的值大于0</span></span><br><span class="line">    <span class="comment">// 2.若是传入的值小于等于0，原始头结点为null</span></span><br><span class="line">    <span class="comment">// 3.若是传入的值小于等于0，原始头节点不为null，原始头结点的waitStatus状态值小于0</span></span><br><span class="line">    <span class="comment">// 4.给h重新赋了一次值后h为null</span></span><br><span class="line">    <span class="comment">// 5.给h重新赋了一次值后h不为null,其waitStatus状态值小于0</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取传入节点的下一个节点s</span></span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="comment">// 若是s为null或者是s节点是共享模式，执行doReleaseShared方法</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared()) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 首先保存头结点</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">// 若是头结点不为空并且头结点不等于尾节点(证明不只有一个节点)</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="comment">// 获取头结点的waitStatus状态值</span></span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="comment">// 若是该状态值为SIGNAL</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">// 尝试将节点h的waitStatus状态值由SIGNAL修改为0</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>; </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 若是修改成功，执行unparkSuccessor方法，唤醒当前节点的下一个节点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="comment">// 若是该状态值为0,将其设置为PROPAGATE   </span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp; !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒node节点的下一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ws小于0，存在三种状态</span></span><br><span class="line">    <span class="comment">// SIGNAL(-1) CONDITION(-2) PROPAGATE(-3)</span></span><br><span class="line">    <span class="keyword">int</span> = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取node节点的下一个节点</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">// 去除一些无用的节点</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                s = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒操作</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;应用场景&quot;&gt;&lt;a href=&quot;#应用场景&quot; class=&quot;headerlink&quot; title=&quot;应用场景&quot;&gt;&lt;/a&gt;&lt;code&gt;应用场景&lt;/code&gt;&lt;/h6&gt;&lt;p&gt;① 下一步的任务需要等待上一步任务执行完成才能执行的场景。比如：有一批任务交给线程池来处理，我们需
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="源码" scheme="https://zhilongao.github.io/categories/java/%E6%BA%90%E7%A0%81/"/>
    
    
  </entry>
  
  <entry>
    <title>基础知识</title>
    <link href="https://zhilongao.github.io/wiki/fra-spring-base/"/>
    <id>https://zhilongao.github.io/wiki/fra-spring-base/</id>
    <published>2019-09-30T02:08:09.000Z</published>
    <updated>2019-09-30T02:22:40.524Z</updated>
    
    <content type="html"><![CDATA[<h6 id="spring事务"><a href="#spring事务" class="headerlink" title="spring事务"></a><code>spring事务</code></h6><p>spring关于事务提供了两种编程模型，注解和接口编程。</p><p>基于注解：① xml文件开启注解驱动，相关类和方法上通过@Transactional注解标识。② spring在启动是会为这些class生成spring内部管理的bean，若是发现带有@Transactional注解的类和方法，会为其生成代理类，代理类中会做相关的事物处理（正常提交，异常回滚）。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>基于接口：需要实现TransactionCallback接口。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="spring事务传播属性"><a href="#spring事务传播属性" class="headerlink" title="spring事务传播属性"></a><code>spring事务传播属性</code></h6><table><thead><tr><th>常量名称</th><th align="center">常量解释</th></tr></thead><tbody><tr><td>PROPAGATION_REQUIRED(propagation_required)</td><td align="center">支持当前事物，如果当前没有事物，就新建一个事物。这是最常见的选择，也是spring默认的事物传播。</td></tr><tr><td>PROPAGATION_REQUIRES_NEW(propagation_requires_new)</td><td align="center">新建事物，如果当前存在事物，就把当前事物挂起。新建的事物和挂起的事物没有任何的关系，是两个独立的事物。外层事物失败回滚之后，不能回滚内层事物执行的结果。内层事物失败抛出异常，外层事物捕获，也可以不处理回滚操作。</td></tr><tr><td>PROPAGATION_SUPPORTS(propagation_supports)</td><td align="center">支持当前事物，如果当前没有事物，就以非事物的方式执行。</td></tr><tr><td>PROPAGATION_MANDATORY(propagation_mandatory)</td><td align="center">支持当前事物，如果当前没有事物，就抛出异常。</td></tr><tr><td>PROPAGATION_NOT_SUPPORTED(propagation_not_supported)</td><td align="center">以非事物方式执行操作，如果当前存在事物，就把当前事物挂起。</td></tr><tr><td>PROPAGATION_NEVER(propagation_never)</td><td align="center">以非事物方式执行操作，如果当前存在事物，就抛出异常。</td></tr><tr><td>PROPAGATION_NESTED(propagation_nested)</td><td align="center">如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务，则按REQUIRED属性执行。它使用了一个单独的事务，这个事务拥有多个可以回滚的保存点。内部事务的回滚不会对外部事务造成影响。它只对DataSourceTransactionManager事务管理器起效。</td></tr></tbody></table><h6 id="数据库事务隔离级别"><a href="#数据库事务隔离级别" class="headerlink" title="数据库事务隔离级别"></a><code>数据库事务隔离级别</code></h6><table><thead><tr><th>隔离级别</th><th>隔离级别的值</th><th>导致的问题</th></tr></thead><tbody><tr><td>Read Uncommited</td><td>0</td><td>允许脏读，不可重复读，幻读</td></tr><tr><td>Read Commited</td><td>1</td><td>避免脏读，允许不可重复读和幻读</td></tr><tr><td>RepeatableRead</td><td>2</td><td>避免脏读和不可重复读，允许幻读</td></tr><tr><td>Serializable</td><td>3</td><td>避免脏读 ，不可重复读，幻读，事物一个一个执行，执行效率低</td></tr></tbody></table><h6 id="spring事务隔离级别"><a href="#spring事务隔离级别" class="headerlink" title="spring事务隔离级别"></a><code>spring事务隔离级别</code></h6><table><thead><tr><th>常量名称</th><th>常量解释</th></tr></thead><tbody><tr><td>ISOLATION_DEFAULT(isolation_default)</td><td>PlatfromTransactionManager默认的事物隔离级别，使用数据库默认的事物隔离级别。</td></tr><tr><td>ISOLATION_READ_UNCOMMITTED(isolation_read_uncommitted)</td><td>读未提交</td></tr><tr><td>ISOLATION_READ_COMMITTED(isolation_read_committed)</td><td>读已提交</td></tr><tr><td>ISOLATION_REPEATABLE_READ(isolation_repeatable)</td><td>可重复读</td></tr><tr><td>ISOLATION_SERIALIZABLE(isolation_serializable)</td><td>串行化</td></tr></tbody></table><h6 id="参考"><a href="#参考" class="headerlink" title="参考"></a><code>参考</code></h6><p><a href="http://www.codeceo.com/article/spring-transactions.html" target="_blank" rel="noopener">深入了解spring事务原理</a></p><p><a href="https://blog.igevin.info/posts/restful-architecture-in-general/#restful_features" target="_blank" rel="noopener">Restful风格</a></p><p><a href="http://www.zsythink.net/archives/1182" target="_blank" rel="noopener">一致性hash</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;spring事务&quot;&gt;&lt;a href=&quot;#spring事务&quot; class=&quot;headerlink&quot; title=&quot;spring事务&quot;&gt;&lt;/a&gt;&lt;code&gt;spring事务&lt;/code&gt;&lt;/h6&gt;&lt;p&gt;spring关于事务提供了两种编程模型，注解和接口编程。&lt;/p&gt;

      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="框架" scheme="https://zhilongao.github.io/categories/java/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="spring" scheme="https://zhilongao.github.io/categories/java/%E6%A1%86%E6%9E%B6/spring/"/>
    
    
  </entry>
  
  <entry>
    <title>注解驱动</title>
    <link href="https://zhilongao.github.io/wiki/fra-spring-annotation/"/>
    <id>https://zhilongao.github.io/wiki/fra-spring-annotation/</id>
    <published>2019-09-30T02:07:41.000Z</published>
    <updated>2019-10-20T07:17:06.568Z</updated>
    
    <content type="html"><![CDATA[<h6 id="元注解-Meta-Annotations"><a href="#元注解-Meta-Annotations" class="headerlink" title="元注解(Meta-Annotations)"></a><code>元注解(Meta-Annotations)</code></h6><p>所谓元注解，是指能够声明在其他注解上的注解，若是一个注解标注在其他注解上，那么他就是元注解。如<code>java</code>的<code>@Documented</code> <code>@Repeatable</code> <code>@Inherited</code>等注解，<code>spring</code>的<code>@Component</code>等注解。</p><hr><h6 id="spring内建模式注解"><a href="#spring内建模式注解" class="headerlink" title="spring内建模式注解"></a><code>spring内建模式注解</code></h6><p>spring中提供了诸如<code>@Repository</code> <code>@Service</code> <code>@Controller</code> <code>@Configuration</code>等的注解，用以标记某一领域内的对象，故称这类注解为模式注解。这些注解均派生自<code>@Component</code>，spring可以通过这些注解的元标注<code>@Component</code>来扫描并注册这些组件。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @Controller注解定义</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Controller &#123;</span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h6 id="自定义模式注解"><a href="#自定义模式注解" class="headerlink" title="自定义模式注解"></a><code>自定义模式注解</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义派生注解</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> StringRepository &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 属性方法名称必须与<span class="doctag">@Component</span>#value()一致</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被自定义注解修饰的bean</span></span><br><span class="line"><span class="meta">@StringRepository</span>(value = <span class="string">"stringService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(<span class="string">"jack"</span>, <span class="string">"tom"</span>, <span class="string">"seven"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext();</span><br><span class="line">        context.setConfigLocation(<span class="string">"classpath:beans1.xml"</span>);</span><br><span class="line">        context.refresh();</span><br><span class="line">        StringService stringService = (StringService)context.getBean(<span class="string">"stringService"</span>);</span><br><span class="line">        System.out.printf(<span class="string">"stringService.findAll() = %s \n"</span>, stringService.findAll());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="comment">// stringService.findAll() = [jack, tom, seven] </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- beans1.xml --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context-3.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.study.annotation.component"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h6 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a><code>原理分析</code></h6><p><code>spring</code> 会在初始化解析<code>xml</code> 文件时读取 <code>/META-INF/spring.handlers</code> 文件中的配置，该配置文件中定义了一些命名空间的处理类。比如 <code>context</code> 命名空间的处理类为 <code>ContextNamespaceHandler</code>，<code>aop</code>命名空间的处理类为<code>AopNamespaceHandler</code>。这些命名空间处理类在<code>spring</code>应用上下文启动时，调用其<code>init</code>方法。该方法会去注册该命名空间下所有<code>local</code>元素的<code>Bean</code>定义解析器。如<code>context</code>命名空间处理类会去注册<code>annotation-config</code>，<code>component-scan</code>的<code>Bean</code>定义解析器。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// spring.handlers文件</span><br><span class="line">http\://www.springframework.org/schema/context=org.springframework.context.config.ContextNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/aop=org.springframework.aop.config.AopNamespaceHandler</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">        <span class="comment">// 注册annotation-config解析器</span></span><br><span class="line">registerJava5DependentParser(<span class="string">"annotation-config"</span>,                                 <span class="string">"org.springframework.context.annotation.AnnotationConfigBeanDefinitionParser"</span>);</span><br><span class="line">        <span class="comment">// 注册component-scan解析器</span></span><br><span class="line">registerJava5DependentParser(<span class="string">"component-scan"</span>,<span class="string">"org.springframework.context.annotation.ComponentScanBeanDefinitionParser"</span>);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>关于<code>&lt;context:component-scan&gt;</code>元素的<code>Bean</code>定义解析器<code>ComponentScanBeanDefinitionParser</code>。该类实现了<code>BeanDefinitionParser</code>接口，解析至该元素时，会去调用<code>parse</code>方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ComponentScanBeanDefinitionParser处理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComponentScanBeanDefinitionParser</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionParser</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">   <span class="comment">// 包扫描路径</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BASE_PACKAGE_ATTRIBUTE = <span class="string">"base-package"</span>;  </span><br><span class="line">   <span class="comment">// 使用默认过滤器属性 </span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String USE_DEFAULT_FILTERS_ATTRIBUTE = <span class="string">"use-default-filters"</span>; </span><br><span class="line">    </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RESOURCE_PATTERN_ATTRIBUTE = <span class="string">"resource-pattern"</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 解析 base-package 属性，获取到一个扫包路径数组</span></span><br><span class="line">String basePackage = element.getAttribute(BASE_PACKAGE_ATTRIBUTE);</span><br><span class="line">basePackage = parserContext.getReaderContext().getEnvironment().resolvePlaceholders(basePackage);</span><br><span class="line">String[] basePackages = StringUtils.tokenizeToStringArray(basePackage,</span><br><span class="line">ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);</span><br><span class="line"><span class="comment">// 2. 配置 ClassPathBeanDefinitionScanner 对象</span></span><br><span class="line">ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element);</span><br><span class="line">        <span class="comment">// 3. ClassPathBeanDefinitionScanner执行 doScan 方法，获取 BeanDefinitionHolder集合</span></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; beanDefinitions = scanner.doScan(basePackages);</span><br><span class="line">        <span class="comment">// 4. 注册集合中的这些 BeanDefinitionHolder</span></span><br><span class="line">registerComponents(parserContext.getReaderContext(), beanDefinitions, element);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**************配置ClassPathBeanDefinitionScanner**************/</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ClassPathBeanDefinitionScanner <span class="title">configureScanner</span><span class="params">(ParserContext parserContext, Element element)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 关于 use-default-filters 属性，若是用户配置了，取用户配置的值，否则默认为 true</span></span><br><span class="line"><span class="keyword">boolean</span> useDefaultFilters = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (element.hasAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE)) &#123;</span><br><span class="line">useDefaultFilters = Boolean.valueOf(element.getAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 调用 createScanner 方法创建一个 ClassPathBeanDefinitionScanner 对象，并设置相关属性</span></span><br><span class="line">ClassPathBeanDefinitionScanner scanner = createScanner(parserContext.getReaderContext(), useDefaultFilters);                     scanner.setBeanDefinitionDefaults(parserContext.getDelegate().getBeanDefinitionDefaults());scanner.setAutowireCandidatePatterns(parserContext.getDelegate().getAutowireCandidatePatterns());</span><br><span class="line"><span class="comment">// 3. 若是元素中包含 resource-pattern 属性</span></span><br><span class="line"><span class="keyword">if</span> (element.hasAttribute(RESOURCE_PATTERN_ATTRIBUTE)) &#123;</span><br><span class="line">scanner.setResourcePattern(element.getAttribute(RESOURCE_PATTERN_ATTRIBUTE));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">parseBeanNameGenerator(element, scanner);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">parseScope(element, scanner);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">parseTypeFilters(element, scanner, parserContext);</span><br><span class="line"><span class="keyword">return</span> scanner;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个 ClassPathBeanDefinitionScanner对象</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ClassPathBeanDefinitionScanner <span class="title">createScanner</span><span class="params">(XmlReaderContext readerContext, <span class="keyword">boolean</span> useDefaultFilters)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ClassPathBeanDefinitionScanner(</span><br><span class="line">            readerContext.getRegistry(), useDefaultFilters,</span><br><span class="line">readerContext.getEnvironment(), readerContext.getResourceLoader());</span><br><span class="line">&#125;   </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><code>ClassPathBeanDefinitionScanner</code>执行<code>doScan</code>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ClassPathBeanDefinitionScanner处理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathBeanDefinitionScanner</span> <span class="keyword">extends</span> <span class="title">ClassPathScanningCandidateComponentProvider</span> </span>&#123;</span><br><span class="line">   <span class="comment">// BeanDefinition注册器 </span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> BeanDefinitionRegistry registry;</span><br><span class="line">   <span class="comment">// Environment环境</span></span><br><span class="line">   <span class="keyword">private</span> Environment environment;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">private</span> BeanDefinitionDefaults beanDefinitionDefaults = <span class="keyword">new</span> BeanDefinitionDefaults();</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassPathBeanDefinitionScanner</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(registry, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassPathBeanDefinitionScanner</span><span class="params">(BeanDefinitionRegistry registry, <span class="keyword">boolean</span> useDefaultFilters)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(registry, useDefaultFilters, getOrCreateEnvironment(registry));</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassPathBeanDefinitionScanner</span><span class="params">(BeanDefinitionRegistry registry, <span class="keyword">boolean</span> useDefaultFilters,</span></span></span><br><span class="line"><span class="function"><span class="params">Environment environment)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>(registry, useDefaultFilters, environment,</span><br><span class="line">(registry <span class="keyword">instanceof</span> ResourceLoader ? (ResourceLoader) registry : <span class="keyword">null</span>));</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造函数 BeanDefinitionRegistry useDefaultFilters Environment ResourceLoader</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassPathBeanDefinitionScanner</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        BeanDefinitionRegistry registry, <span class="keyword">boolean</span> useDefaultFilters,</span></span></span><br><span class="line"><span class="function"><span class="params">Environment environment, ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 设置 BeanDefinitionRegistry</span></span><br><span class="line"><span class="keyword">this</span>.registry = registry;</span><br><span class="line"><span class="comment">// 2. 若是使用默认过滤器，执行父类 ClassPathScanningCandidateComponentProvider方法</span></span><br><span class="line"><span class="keyword">if</span> (useDefaultFilters) &#123;</span><br><span class="line">registerDefaultFilters();</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 3. 父类 ClassPathScanningCandidateComponentProvider 方法</span></span><br><span class="line">setEnvironment(environment);</span><br><span class="line">        <span class="comment">// 4. 父类 ClassPathScanningCandidateComponentProvider 方法</span></span><br><span class="line">setResourceLoader(resourceLoader);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/************************doScan方法****************/</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建一个存储 BeanDefinitinHolder的集合</span></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> LinkedHashSet&lt;BeanDefinitionHolder&gt;();</span><br><span class="line">        <span class="comment">// 2. 循环遍历给定的包路径数组</span></span><br><span class="line"><span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">            <span class="comment">// 3. 调用 findCandidateComponents 方法找到给定包下的 BeanDefinition</span></span><br><span class="line">Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);     </span><br><span class="line">            <span class="comment">// 4. 遍历这些 BeanDefinition</span></span><br><span class="line"><span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">                <span class="comment">// 5.获取scope元信息ScopeMetadata并设置到candidate的scope属性中，如：single</span></span><br><span class="line">ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">                <span class="comment">// 6. 为这个 candidate 生成一个 beanName</span></span><br><span class="line">String beanName = <span class="keyword">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="keyword">this</span>.registry);</span><br><span class="line">                <span class="comment">// 7. 若是 candidate 是 AbstractBeanDefinition 的子类，调用 postProcessBeanDefinition方法</span></span><br><span class="line"><span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">&#125;</span><br><span class="line">                <span class="comment">// 8. 若是 candidiate 是 AnnotatedBeanDefinition 的子类</span></span><br><span class="line"><span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);&#125;</span><br><span class="line">                <span class="comment">// 9. 调用 checkCandidate 方法检验</span></span><br><span class="line"><span class="keyword">if</span> (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(candidate, beanName);</span><br><span class="line">definitionHolder =</span><br><span class="line">AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">beanDefinitions.add(definitionHolder);</span><br><span class="line">registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 返回BeanDefinitionHolder集合，在类 ComponentScanBeanDefinitionParser 中注册</span></span><br><span class="line"><span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><code>ClassPathScanningCandidateComponentProvider</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathScanningCandidateComponentProvider</span> <span class="keyword">implements</span> <span class="title">EnvironmentCapable</span>, <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 组件包含项过滤器列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;TypeFilter&gt; includeFilters = <span class="keyword">new</span> LinkedList&lt;TypeFilter&gt;();</span><br><span class="line">    <span class="comment">// 组件排除项过滤器列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;TypeFilter&gt; excludeFilters = <span class="keyword">new</span> LinkedList&lt;TypeFilter&gt;();</span><br><span class="line">    <span class="comment">// MetadataReaderFactory-&gt;CachingMetadataReaderFactory</span></span><br><span class="line">    <span class="keyword">private</span> MetadataReaderFactory metadataReaderFactory;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> ResourcePatternResolver resourcePatternResolver;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 通过给定的包路径寻找候选组件</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Set&lt;BeanDefinition&gt; <span class="title">findCandidateComponents</span><span class="params">(String basePackage)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建一个集合，用以存储 BeanDefinition</span></span><br><span class="line">Set&lt;BeanDefinition&gt; candidates = <span class="keyword">new</span> LinkedHashSet&lt;BeanDefinition&gt;();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 2. 将包路径(com.study.annotation.component)转化为class文件路径</span></span><br><span class="line">            <span class="comment">// (classpath*:com/study/annotation/component/**/*.class)</span></span><br><span class="line">String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +</span><br><span class="line">resolveBasePackage(basePackage) + <span class="string">'/'</span> + <span class="keyword">this</span>.resourcePattern;</span><br><span class="line">            <span class="comment">// 3. 将class文件路径转化packageSearchPath转化为Resource数组</span></span><br><span class="line">Resource[] resources = <span class="keyword">this</span>.resourcePatternResolver.getResources(packageSearchPath);</span><br><span class="line">            <span class="comment">// 4. 循环遍历Resource数组</span></span><br><span class="line"><span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">                <span class="comment">// 5.若是这个资源Resource可读    </span></span><br><span class="line"><span class="keyword">if</span> (resource.isReadable()) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 6.获取这个资源Resource的MetadataReader对象</span></span><br><span class="line">MetadataReader metadataReader = <span class="keyword">this</span>.metadataReaderFactory.getMetadataReader(resource);</span><br><span class="line">                        <span class="comment">// 7. 判断metadataReader是否是候选组件</span></span><br><span class="line">                        <span class="comment">//org.springframework.core.type.classreading.SimpleMetadataReader</span></span><br><span class="line"><span class="keyword">if</span> (isCandidateComponent(metadataReader)) &#123;</span><br><span class="line">                            <span class="comment">// 8. 生成一个 ScannedGenericBeanDefinition对象</span></span><br><span class="line">ScannedGenericBeanDefinition sbd = <span class="keyword">new</span> ScannedGenericBeanDefinition(metadataReader);</span><br><span class="line">sbd.setResource(resource);</span><br><span class="line">sbd.setSource(resource);</span><br><span class="line">                            <span class="comment">// 9.若ScannedGenericBeanDefinition是候选组件，加入到candidates中</span></span><br><span class="line"><span class="keyword">if</span> (isCandidateComponent(sbd)) &#123;</span><br><span class="line">...</span><br><span class="line">candidates.add(sbd);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> candidates;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断给定的 MetadataReader 是否是候选组件(SimpleMetadataReader)</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isCandidateComponent</span><span class="params">(MetadataReader metadataReader)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 循环排除项过滤器</span></span><br><span class="line"><span class="keyword">for</span> (TypeFilter tf : <span class="keyword">this</span>.excludeFilters) &#123;</span><br><span class="line"><span class="keyword">if</span> (tf.match(metadataReader, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 循环包含项过滤器</span></span><br><span class="line"><span class="keyword">for</span> (TypeFilter tf : <span class="keyword">this</span>.includeFilters) &#123;</span><br><span class="line"><span class="keyword">if</span> (tf.match(metadataReader, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line"><span class="keyword">return</span> isConditionMatch(metadataReader);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isConditionMatch</span><span class="params">(MetadataReader metadataReader)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.conditionEvaluator = <span class="keyword">new</span> ConditionEvaluator(getRegistry(), getEnvironment(), getResourceLoader());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> !<span class="keyword">this</span>.conditionEvaluator.shouldSkip(metadataReader.getAnnotationMetadata());</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 判断给定的 AnnotatedBeanDefinition 是否是候选组件</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isCandidateComponent</span><span class="params">(AnnotatedBeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 获取AnnotatedBeanDefinition的AnnotationMetadata注解元信息，实现类为</span></span><br><span class="line">        <span class="comment">// org.springframework.core.type.classreading.AnnotationMetadataReadingVisitor</span></span><br><span class="line">AnnotationMetadata metadata = beanDefinition.getMetadata();</span><br><span class="line"><span class="keyword">return</span> (metadata.isIndependent() &amp;&amp; (metadata.isConcrete() ||</span><br><span class="line">(metadata.isAbstract() &amp;&amp; metadata.hasAnnotatedMethods(Lookup.class.getName()))));</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册默认的过滤器-&gt;@Component @ManagedBean @Named</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerDefaultFilters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(Component.class));        </span><br><span class="line">ClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(</span><br><span class="line">((Class&lt;? extends Annotation&gt;) ClassUtils.forName(<span class="string">"javax.annotation.ManagedBean"</span>, cl)), <span class="keyword">false</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(</span><br><span class="line">((Class&lt;? extends Annotation&gt;) ClassUtils.forName(<span class="string">"javax.inject.Named"</span>, cl)), <span class="keyword">false</span>));</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置环境Environment</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.environment = environment;</span><br><span class="line"><span class="keyword">this</span>.conditionEvaluator = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(@Nullable ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置resourcePatternResolver</span></span><br><span class="line"><span class="keyword">this</span>.resourcePatternResolver = ResourcePatternUtils.getResourcePatternResolver(resourceLoader);</span><br><span class="line">        <span class="comment">// 设置metadataReaderFactory</span></span><br><span class="line"><span class="keyword">this</span>.metadataReaderFactory = <span class="keyword">new</span> CachingMetadataReaderFactory(resourceLoader);</span><br><span class="line"><span class="keyword">this</span>.componentsIndex = CandidateComponentsIndexLoader.loadIndex(<span class="keyword">this</span>.resourcePatternResolver.getClassLoader());</span><br><span class="line">&#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>关于<code>MetadataReaderFactory</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顶层接口，提供两种方式获取MetadataReader-&gt;className和Resource</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MetadataReaderFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">MetadataReader <span class="title">getMetadataReader</span><span class="params">(String className)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="function">MetadataReader <span class="title">getMetadataReader</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMetadataReaderFactory</span> <span class="keyword">implements</span> <span class="title">MetadataReaderFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ResourceLoader resourceLoader;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据给定的Resource返回一个MetadataReader对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MetadataReader <span class="title">getMetadataReader</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> SimpleMetadataReader(resource, <span class="keyword">this</span>.resourceLoader.getClassLoader());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachingMetadataReaderFactory</span> <span class="keyword">extends</span> <span class="title">SimpleMetadataReaderFactory</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CACHE_LIMIT = <span class="number">256</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cacheLimit = DEFAULT_CACHE_LIMIT;</span><br><span class="line">    <span class="comment">// Resource-&gt;MetadataReader映射</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Resource, MetadataReader&gt; metadataReaderCache =</span><br><span class="line">  <span class="keyword">new</span> LinkedHashMap&lt;Resource, MetadataReader&gt;(DEFAULT_CACHE_LIMIT, <span class="number">0.75f</span>, <span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;Resource, MetadataReader&gt; eldest)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> size() &gt; getCacheLimit();</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 基于Resource方式获取MetadataReader</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MetadataReader <span class="title">getMetadataReader</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 缓存限制小于等于0，直接调用父类SimpleMetadataReaderFactory方法获取</span></span><br><span class="line"><span class="keyword">if</span> (getCacheLimit() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.getMetadataReader(resource);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 缓存限制大于0，锁定缓存</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.metadataReaderCache) &#123;</span><br><span class="line">            <span class="comment">// 从缓存加载，若是加载不到，调用父类方法加载，存入缓存并返回</span></span><br><span class="line">MetadataReader metadataReader = <span class="keyword">this</span>.metadataReaderCache.get(resource);</span><br><span class="line"><span class="keyword">if</span> (metadataReader == <span class="keyword">null</span>) &#123;</span><br><span class="line">metadataReader = <span class="keyword">super</span>.getMetadataReader(resource);</span><br><span class="line"><span class="keyword">this</span>.metadataReaderCache.put(resource, metadataReader);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> metadataReader;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCacheLimit</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.cacheLimit;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于<code>MetadataReader</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 元信息读取接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MetadataReader</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取资源信息Resource</span></span><br><span class="line">    <span class="function">Resource <span class="title">getResource</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 获取Class的元信息ClassMetadata</span></span><br><span class="line"><span class="function">ClassMetadata <span class="title">getClassMetadata</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取注解Annotation的元信息AnnotationMetadata</span></span><br><span class="line"><span class="function">AnnotationMetadata <span class="title">getAnnotationMetadata</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元信息读取接口的简单实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleMetadataReader</span> <span class="keyword">implements</span> <span class="title">MetadataReader</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Resource resource;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassMetadata classMetadata;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AnnotationMetadata annotationMetadata;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造方法，通过给定的Resource和ClassLoader创建一个SimpleMetadataReader对象</span></span><br><span class="line">SimpleMetadataReader(Resource resource, ClassLoader classLoader) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">InputStream is = <span class="keyword">new</span> BufferedInputStream(resource.getInputStream());</span><br><span class="line">ClassReader classReader;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">classReader = <span class="keyword">new</span> ClassReader(is);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NestedIOException();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">is.close();</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 创建AnnotationMetadataReadingVisitor对象</span></span><br><span class="line">AnnotationMetadataReadingVisitor visitor = <span class="keyword">new</span> AnnotationMetadataReadingVisitor(classLoader);</span><br><span class="line">classReader.accept(visitor, ClassReader.SKIP_DEBUG);</span><br><span class="line">        <span class="comment">// 将SimpleMetadataReader的annotationMetadata和classMetadata属性均设置为visitor</span></span><br><span class="line"><span class="keyword">this</span>.annotationMetadata = visitor;</span><br><span class="line"><span class="keyword">this</span>.classMetadata = visitor;</span><br><span class="line">        <span class="comment">// 将SimpleMetadataReader的resource设置为resource</span></span><br><span class="line"><span class="keyword">this</span>.resource = resource;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Resource <span class="title">getResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.resource;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ClassMetadata <span class="title">getClassMetadata</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.classMetadata;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AnnotationMetadata <span class="title">getAnnotationMetadata</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.annotationMetadata;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>关于加载<code>BeanDefinition</code>时的过滤器 <code>TypeFilter</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 上层接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TypeFilter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">match</span><span class="params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractTypeHierarchyTraversingFilter</span> <span class="keyword">implements</span> <span class="title">TypeFilter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否考虑继承</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> considerInherited;</span><br><span class="line">    <span class="comment">// 是否考虑接口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> considerInterfaces;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 实现上层接口 TypeFilter 的 match 方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 调用 matchSelf方法，若是返回 true，直接返回</span></span><br><span class="line"><span class="keyword">if</span> (matchSelf(metadataReader)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 2. 获取 metadatdaReader的 ClassMetadata</span></span><br><span class="line">ClassMetadata metadata = metadataReader.getClassMetadata();</span><br><span class="line"><span class="keyword">if</span> (matchClassName(metadata.getClassName())) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. 若时考虑继承，则匹配父类</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.considerInherited) &#123;</span><br><span class="line">            <span class="comment">// 从Class元信息ClassMetadata中判断该类是否有父类</span></span><br><span class="line"><span class="keyword">if</span> (metadata.hasSuperClass()) &#123;</span><br><span class="line">                <span class="comment">// 若是该类有父类，调用matchSuperClass方法</span></span><br><span class="line">Boolean superClassMatch = matchSuperClass(metadata.getSuperClassName());</span><br><span class="line"><span class="keyword">if</span> (superClassMatch != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (superClassMatch.booleanValue()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (match(metadata.getSuperClassName(), metadataReaderFactory)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                        ...</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.considerInterfaces) &#123;</span><br><span class="line"><span class="keyword">for</span> (String ifc : metadata.getInterfaceNames()) &#123;</span><br><span class="line">Boolean interfaceMatch = matchInterface(ifc);</span><br><span class="line"><span class="keyword">if</span> (interfaceMatch != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (interfaceMatch.booleanValue()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (match(ifc, metadataReaderFactory)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">matchSelf</span><span class="params">(MetadataReader metadataReader)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">matchClassName</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Boolean <span class="title">matchSuperClass</span><span class="params">(String superClassName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationTypeFilter</span> <span class="keyword">extends</span> <span class="title">AbstractTypeHierarchyTraversingFilter</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;? extends Annotation&gt; annotationType;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> considerMetaAnnotations;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// MetadataReader时SimpleMetadataReader</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">matchSelf</span><span class="params">(MetadataReader metadataReader)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取到 MetadataReader 的注解元信息 AnnotationMetadata</span></span><br><span class="line">AnnotationMetadata metadata = metadataReader.getAnnotationMetadata();</span><br><span class="line">        <span class="comment">//该MetadataReader直接被annotationType注解修饰返回true</span></span><br><span class="line">        <span class="comment">//修饰该MetadataReader注解的元注解中有annotationType返回true</span></span><br><span class="line"><span class="keyword">return</span> metadata.hasAnnotation(<span class="keyword">this</span>.annotationType.getName()) ||</span><br><span class="line">(<span class="keyword">this</span>.considerMetaAnnotations &amp;&amp; metadata.hasMetaAnnotation(<span class="keyword">this</span>.annotationType.getName()));</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Boolean <span class="title">matchSuperClass</span><span class="params">(String superClassName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> hasAnnotation(superClassName);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Boolean <span class="title">hasAnnotation</span><span class="params">(String typeName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Object.class.getName().equals(typeName)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeName.startsWith(<span class="string">"java"</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.annotationType.getName().startsWith(<span class="string">"java"</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class&lt;?&gt; clazz = ClassUtils.forName(typeName, getClass().getClassLoader());</span><br><span class="line"><span class="keyword">return</span> ((<span class="keyword">this</span>.considerMetaAnnotations ? AnnotationUtils.getAnnotation(clazz, <span class="keyword">this</span>.annotationType) :</span><br><span class="line">clazz.getAnnotation(<span class="keyword">this</span>.annotationType)) != <span class="keyword">null</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>关于ClassReader</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Class信息读取类ClassReader</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassReader</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassReader</span><span class="params">(<span class="keyword">final</span> InputStream is)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(readClass(is, <span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(<span class="keyword">final</span> ClassVisitor classVisitor, <span class="keyword">final</span> <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        accept(classVisitor, <span class="keyword">new</span> Attribute[<span class="number">0</span>], flags);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(<span class="keyword">final</span> ClassVisitor classVisitor,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> Attribute[] attrs, <span class="keyword">final</span> <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>关于AnnotationMetadata</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************** AnnotatioMetadata接口 **************/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AnnotationMetadata</span> <span class="keyword">extends</span> <span class="title">ClassMetadata</span>, <span class="title">AnnotatedTypeMetadata</span> </span>&#123;</span><br><span class="line"><span class="function">Set&lt;String&gt; <span class="title">getAnnotationTypes</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Set&lt;String&gt; <span class="title">getMetaAnnotationTypes</span><span class="params">(String annotationName)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasAnnotation</span><span class="params">(String annotationName)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasMetaAnnotation</span><span class="params">(String metaAnnotationName)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasAnnotatedMethods</span><span class="params">(String annotationName)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Set&lt;MethodMetadata&gt; <span class="title">getAnnotatedMethods</span><span class="params">(String annotationName)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClassMetadata</span> </span>&#123;</span><br><span class="line"><span class="function">String <span class="title">getClassName</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isInterface</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isAnnotation</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isAbstract</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isConcrete</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isFinal</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isIndependent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasEnclosingClass</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">getEnclosingClassName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasSuperClass</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">getSuperClassName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">String[] getInterfaceNames();</span><br><span class="line"></span><br><span class="line">String[] getMemberClassNames();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AnnotatedTypeMetadata</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isAnnotated</span><span class="params">(String annotationName)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Map&lt;String, Object&gt; <span class="title">getAnnotationAttributes</span><span class="params">(String annotationName)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Map&lt;String, Object&gt; <span class="title">getAnnotationAttributes</span><span class="params">(String annotationName, <span class="keyword">boolean</span> classValuesAsString)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">MultiValueMap&lt;String, Object&gt; <span class="title">getAllAnnotationAttributes</span><span class="params">(String annotationName)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">MultiValueMap&lt;String, Object&gt; <span class="title">getAllAnnotationAttributes</span><span class="params">(String annotationName, <span class="keyword">boolean</span> classValuesAsString)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于<code>ClassMetadataReadingVisitor</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassMetadataReadingVisitor</span> <span class="keyword">extends</span> <span class="title">ClassVisitor</span> <span class="keyword">implements</span> <span class="title">ClassMetadata</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String enclosingClassName;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> independentInnerClass;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isInterface;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isAbstract;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIndependent</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">this</span>.enclosingClassName == <span class="keyword">null</span> || <span class="keyword">this</span>.independentInnerClass);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConcrete</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> !(<span class="keyword">this</span>.isInterface || <span class="keyword">this</span>.isAbstract);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAbstract</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.isAbstract;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassVisitor</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClassMetadata</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 <code>AnnotationMetadataReadingVisitor</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationMetadataReadingVisitor</span> <span class="keyword">extends</span> <span class="title">ClassMetadataReadingVisitor</span> <span class="keyword">implements</span> <span class="title">AnnotationMetadata</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasAnnotatedMethods</span><span class="params">(String annotationName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (MethodMetadata methodMetadata : <span class="keyword">this</span>.methodMetadataSet) &#123;</span><br><span class="line"><span class="keyword">if</span> (methodMetadata.isAnnotated(annotationName)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AnnotationMetadata</span> <span class="keyword">extends</span> <span class="title">ClassMetadata</span>, <span class="title">AnnotatedTypeMetadata</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AnnotatedTypeMetadata</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AnnotatedBeanDefinition基于注解的BeanDefinition</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AnnotatedBeanDefinition</span> <span class="keyword">extends</span> <span class="title">BeanDefinition</span> </span>&#123;</span><br><span class="line"><span class="function">AnnotationMetadata <span class="title">getMetadata</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">MethodMetadata <span class="title">getFactoryMethodMetadata</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GenericBeanDefinition层次性的BeanDefinition定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericBeanDefinition</span> <span class="keyword">extends</span> <span class="title">AbstractBeanDefinition</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String parentName;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">GenericBeanDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">GenericBeanDefinition</span><span class="params">(BeanDefinition original)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(original);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParentName</span><span class="params">(String parentName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.parentName = parentName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getParentName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.parentName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AbstractBeanDefinition <span class="title">cloneBeanDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> GenericBeanDefinition(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">this</span> == other || (other <span class="keyword">instanceof</span> GenericBeanDefinition &amp;&amp; <span class="keyword">super</span>.equals(other)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"Generic bean"</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.parentName != <span class="keyword">null</span>) &#123;</span><br><span class="line">sb.append(<span class="string">" with parent '"</span>).append(<span class="keyword">this</span>.parentName).append(<span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">sb.append(<span class="string">": "</span>).append(<span class="keyword">super</span>.toString());</span><br><span class="line"><span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ScannedGenericBeanDefinition 基于扫描获取到的 BeanDefinition</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScannedGenericBeanDefinition</span> <span class="keyword">extends</span> <span class="title">GenericBeanDefinition</span> <span class="keyword">implements</span> <span class="title">AnnotatedBeanDefinition</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AnnotationMetadata metadata;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScannedGenericBeanDefinition</span><span class="params">(MetadataReader metadataReader)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">this</span>.metadata = metadataReader.getAnnotationMetadata();</span><br><span class="line">setBeanClassName(<span class="keyword">this</span>.metadata.getClassName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AnnotationMetadata <span class="title">getMetadata</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.metadata;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MethodMetadata <span class="title">getFactoryMethodMetadata</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="spring组合注解"><a href="#spring组合注解" class="headerlink" title="spring组合注解"></a><code>spring组合注解</code></h6><h6 id="spring注解属性别名和覆盖"><a href="#spring注解属性别名和覆盖" class="headerlink" title="spring注解属性别名和覆盖"></a><code>spring注解属性别名和覆盖</code></h6><h6 id="Enable"><a href="#Enable" class="headerlink" title="Enable"></a><code>Enable</code></h6><h6 id="条件装配"><a href="#条件装配" class="headerlink" title="条件装配"></a><code>条件装配</code></h6>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;元注解-Meta-Annotations&quot;&gt;&lt;a href=&quot;#元注解-Meta-Annotations&quot; class=&quot;headerlink&quot; title=&quot;元注解(Meta-Annotations)&quot;&gt;&lt;/a&gt;&lt;code&gt;元注解(Meta-Annotation
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="框架" scheme="https://zhilongao.github.io/categories/java/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="spring" scheme="https://zhilongao.github.io/categories/java/%E6%A1%86%E6%9E%B6/spring/"/>
    
    
  </entry>
  
  <entry>
    <title>Unsafe</title>
    <link href="https://zhilongao.github.io/wiki/ans-unsafe-source/"/>
    <id>https://zhilongao.github.io/wiki/ans-unsafe-source/</id>
    <published>2019-09-27T09:19:05.000Z</published>
    <updated>2019-09-28T06:11:58.370Z</updated>
    
    <content type="html"><![CDATA[<h6 id="Unsafe类"><a href="#Unsafe类" class="headerlink" title="Unsafe类"></a><code>Unsafe类</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// jdk核心类库可操作的api</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsafe</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对外暴露的实例属性，类加载阶段加载</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe theUnsafe;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        theUnsafe = <span class="keyword">new</span> Unsafe();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Unsafe</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该类中的 theUnsafe 属性为该类的一个实例，对外只提供给jdk核心类库使用。我们在平常的开发中无法通过该方法来获取 theUnsafe 对象。（可以通过万能的反射方式获取）</span></span><br><span class="line">    <span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Class var0 = Reflection.getCallerClass();</span><br><span class="line">        <span class="keyword">if</span> (!VM.isSystemDomainLoader(var0.getClassLoader())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Unsafe"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> theUnsafe;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// native方法，阻塞当前线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">boolean</span> var1, <span class="keyword">long</span> var2)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// native方法，唤醒指定的线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Object var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h6 id="Unsafe操作"><a href="#Unsafe操作" class="headerlink" title="Unsafe操作"></a><code>Unsafe操作</code></h6><hr><p><code>获取Unsafe实例</code></p><p>由于<code>Unsafe</code>实例获取方法添加了类加载器验证，所以我们代码中编写的类是无法直接使用<code>Unsafe</code>类的。一般我们可以有两种方式获取<code>Unsafe</code>实例。① 从限制条件入手，修改引导类加载路径，将我们编写的路径添加到引导类路径中。② 通过反射的方式获取。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="comment">// 获取到Unsafe实例</span></span><br><span class="line">    Unsafe unsafe = getUnsafe();</span><br><span class="line">    System.out.println(unsafe);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.通过反射获取 Unsafe 实例</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Unsafe unsafe = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Field field = Unsafe.class.getDeclaredField(<span class="string">"theUnsafe"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        unsafe = (Unsafe)field.get(<span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unsafe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><code>非常规对象实例化</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 非常规对象实例化</span></span><br><span class="line">    People p1 = (People)getInstance(People.class);</span><br><span class="line">    People p2 = (People)getInstance(People.class);</span><br><span class="line">    System.out.println(p1);</span><br><span class="line">    System.out.println(p2);</span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="comment">// null:0</span></span><br><span class="line">    <span class="comment">// null:0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取指定类的实例，该方式不会调用指定类的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getInstance</span> <span class="params">(Class clazz)</span> </span>&#123;</span><br><span class="line">    Unsafe unsafe = getUnsafe();</span><br><span class="line">    Object p = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        p =  unsafe.allocateInstance(clazz);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可操作类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = <span class="string">"default"</span>;</span><br><span class="line">        <span class="keyword">this</span>.age = <span class="number">18</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">":"</span> + <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><code>多线程同步(CAS操作)</code></p><p>juc提供了一些原子操作类，这些类中使用了 Unsafe 类中提供的一些方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取到 Unsafe 类对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="comment">// value属性在内存地址中的偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line">    <span class="comment">// 静态代码块，初始化 valueOffset 属性</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 该类所持有的值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取当前值，并将其加1</span></span><br><span class="line">    <span class="comment">// 调用 UnSafe 类的 getAndAddInt 方法，返回 this 对象上地址偏移量为 valueOffset 处的值，并将其加1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsafe</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 某个对象的某个地址偏移处的值加上某个值，并将原始值返回    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> var5;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 获取到原始值</span></span><br><span class="line">            var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">        &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">        <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">getIntVolatile</span><span class="params">(Object var1, <span class="keyword">long</span> var2)</span></span>;</span><br><span class="line">    <span class="comment">// CAS更新</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br><span class="line">    ...    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><code>挂起与恢复</code></p><p>在<code>LockSupport</code>中提供了两个方法，<code>park</code>与<code>unpark</code>方法，而这两个方法实际上又是调用的<code>Unsafe</code>类中的<code>native</code>方法。<code>park</code>是将当前调用线程阻塞，而<code>unpark</code>方法则是唤醒指定的线程。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupport</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加载 Unsafe 类型的 UNSAFE 实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">...</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// LockSupport提供了挂起当前线程的多个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        setBlocker(t, blocker);</span><br><span class="line">        UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">        setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用 Unsafe 类的unpark方法唤醒指定的线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            UNSAFE.unpark(thread);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsafe</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// 操作系统底层提供的挂起线程的方法(阻塞线程)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">boolean</span> var1, <span class="keyword">long</span> var2)</span></span>;</span><br><span class="line">   <span class="comment">// 操作系统底层提供的唤醒线程的方法(取消阻塞线程)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Object var1)</span></span>; </span><br><span class="line">   <span class="comment">// 几个过期的方法</span></span><br><span class="line">   <span class="comment">// 获得对象锁(可重入锁)</span></span><br><span class="line">   <span class="meta">@Deprecated</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">monitorEnter</span><span class="params">(Object var1)</span></span>;</span><br><span class="line">   <span class="comment">// 释放对象锁 </span></span><br><span class="line">   <span class="meta">@Deprecated</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">monitorExit</span><span class="params">(Object var1)</span></span>;</span><br><span class="line">   <span class="comment">// 尝试获取对象锁 </span></span><br><span class="line">   <span class="meta">@Deprecated</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">tryMonitorEnter</span><span class="params">(Object var1)</span></span>;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><code>内存管理</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内存分配</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">allocateMemory</span><span class="params">(<span class="keyword">long</span> var1)</span></span>;</span><br><span class="line"><span class="comment">// 扩充内存</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">reallocateMemory</span><span class="params">(<span class="keyword">long</span> var1, <span class="keyword">long</span> var3)</span></span>;</span><br><span class="line"><span class="comment">// 释放内存</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">freeMemory</span><span class="params">(<span class="keyword">long</span> var1)</span></span>;</span><br><span class="line"><span class="comment">// 在给定的内存块中设置值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">setMemory</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4, <span class="keyword">byte</span> var6)</span></span>;</span><br><span class="line"><span class="comment">// 内存拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">copyMemory</span><span class="params">(Object var1, <span class="keyword">long</span> var2, Object var4, <span class="keyword">long</span> var5, <span class="keyword">long</span> var7)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关于堆外内存的使用</span></span><br><span class="line"><span class="comment">// 使用原因: 垃圾回收停顿的改善  提升程序IO操作的性能</span></span><br><span class="line"><span class="comment">// java实现堆外内存操作的类 DirectByteBuffer</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DirectByteBuffer</span> <span class="keyword">extends</span> <span class="title">MappedByteBuffer</span> <span class="keyword">implements</span> <span class="title">DirectBuffer</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><code>数组操作</code></p><hr><p><code>内存屏障</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;Unsafe类&quot;&gt;&lt;a href=&quot;#Unsafe类&quot; class=&quot;headerlink&quot; title=&quot;Unsafe类&quot;&gt;&lt;/a&gt;&lt;code&gt;Unsafe类&lt;/code&gt;&lt;/h6&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;t
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="源码" scheme="https://zhilongao.github.io/categories/java/%E6%BA%90%E7%A0%81/"/>
    
    
  </entry>
  
  <entry>
    <title>AQS</title>
    <link href="https://zhilongao.github.io/wiki/ans-aqs-source/"/>
    <id>https://zhilongao.github.io/wiki/ans-aqs-source/</id>
    <published>2019-09-27T06:19:27.000Z</published>
    <updated>2019-09-27T09:17:01.430Z</updated>
    
    <content type="html"><![CDATA[<hr><h6 id="AQS类内部结构"><a href="#AQS类内部结构" class="headerlink" title="AQS类内部结构"></a><code>AQS类内部结构</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head; <span class="comment">// 同步队列头节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail; <span class="comment">// 同步队列尾节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state; <span class="comment">// 锁状态值</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*nextWaiter 属性的几个状态值*/</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node(); <span class="comment">// 标记节点在共享模式下等待</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>; <span class="comment">// 标记节点在排他模式下等待</span></span><br><span class="line">        <span class="comment">/*waitStatus 属性的几个状态值*/</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>; <span class="comment">// 表示节点已经被取消</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>; <span class="comment">// 表示后面节点的线程需要被唤醒。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>; <span class="comment">// 表示节点在条件队列上</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>; <span class="comment">// 关于共享锁的状态 </span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">        <span class="keyword">volatile</span> Node prev; <span class="comment">// 前驱</span></span><br><span class="line"><span class="keyword">volatile</span> Node next; <span class="comment">// 后继</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread thread; <span class="comment">// 节点封装的线程</span></span><br><span class="line">        Node nextWaiter; <span class="comment">// 下一个等待的节点</span></span><br><span class="line">        <span class="comment">// addWaiter方法调用时，会构造一个Node节点</span></span><br><span class="line">        Node(Thread thread, Node mode) &#123;</span><br><span class="line">            <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h6 id="acquire方法"><a href="#acquire方法" class="headerlink" title="acquire方法"></a><code>acquire方法</code></h6><p>该方法定义为获取，<code>ReentrantLock</code>内部获取锁的操作会调用该方法。该方法的执行流程为：</p><p>① 执行<code>tryAcquire</code>，若是该方法返回为<code>true</code>，直接结束。否则执行下一步操作。(<code>tryAcquire</code>是一个空方法，具体逻辑由子类来实现)。</p><p>② 执行<code>addWaiter</code>方法，参数值为<code>Node.EXCLUSIVE</code>。① 该操作首先会将当前线程封装成为一个<code>Node</code>节点，该<code>Node</code>节点的<code>thread</code>值为当前线程，<code>nextWaiter</code>值为<code>null</code>。②  将创建好的该节点添加到同步队列的尾部。③ 将该节点返回。</p><p>③ 执行 <code>acquireQueued(Node node, int arg)</code>方法。该方法以自旋开始。① 获取到给定节点<code>node</code>的前驱节点<code>p</code>。若是<code>p</code>为头节点并且尝试获取锁成功，则将<code>node</code>节点设置为头节点（<code>thread</code>和<code>prev</code>属性设置为<code>null</code>），将<code>p</code>节点清除，返回线程中断表标识。② 若上面条件不满足或执行失败，执行<code>shouldParkAfterFailedAcquire</code>方法和<code>parkAndCheckInterrupt</code>方法。③ 首先是会执行<code>shouldParkAfterFailedAcquire(p, node)</code>方法的，该方法是判断当前线程获取锁失败后，是否需要挂起。执行逻辑是：判断前一个节点<code>p</code>的<code>waitStatus</code>状态值，若是该值为<code>Node.SIGNAL</code>，返回<code>true</code>。其它情况返回<code>false</code>。④ 若是<code>shouldParkAfterFailedAcquire(p, node)</code>方法返回值为<code>true</code>，执行<code>parkAndCheckInterrupt</code>方法，否则执行 ①。⑤ <code>parkAndCheckInterrupt</code>方法首先将当前线程挂起，然后返回线程的中断标识，若是为<code>true</code>，会将<code>interrupted</code>属性设置为<code>true</code>。</p><p>④ 由于<code>acquireQueued(Node node, int agr)</code>方法返回的是当前线程的中断标识，若是返回为<code>true</code>，立马中断当前线程。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) &#123;</span><br><span class="line">        selfInterrupt();</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一个空方法，具体逻辑由子类来实现</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// addWaiter方法，添加一个节点到同步队列</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加一个节点到同步队列，直到成功为止</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一段自旋操作中，成功获取到锁，该方法才会结束。</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) &#123;</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed) &#123;</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将给定的节点设置为头节点，① head指向node ② node的thread属性指向null ③ node的prev属性指向null</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    head = node;</span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line">    node.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当尝试获取锁失败后，判断是否应该将当前的线程挂起</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="comment">// 前一个节点waitStatus状态值为SIGNAL(-1),线程可以被安全的挂起</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 若是前一个节点被取消了(1)，跳过该节点</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// pred和node.prev重新赋值</span></span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 将pred的next指向node节点</span></span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 其它情况，CAS操作将 pred的状态值修改为 SIGNAL</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 挂起当前线程并且返回当前线程的中断状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h6 id="release方法"><a href="#release方法" class="headerlink" title="release方法"></a><code>release方法</code></h6><p>在<code>ReentrantLock</code>的<code>unlock</code>方法中，会直接调用此方法。该方法也是一个模板方法，① 首先会去调用<code>tryRelease(arg)</code>方法，此方法在<code>AQS</code>中是一个空方法，具体逻辑由子类来实现。 ② 若是 ① 调用后返回值为<code>true</code>，执行<code>unparkSuccessor(Node node)</code>方法。<code>unparkSuccessor(Node node)</code>方法会去唤醒<code>node</code>节点的下一个节点。③ 若是 ① 调用后返回值为<code>false</code>，直接返回<code>false</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先执行子类的tryRelease方法，根据其返回值执行具体的操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>) &#123;</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抽象方法，由具体的子类来实现</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 若是node节点存在后继节点，则将其唤醒</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">// 当node节点的next节点为null或者其已经被取消时，从尾节点向前遍历,找到一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                s = t;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到了一个不为null的节点，将其唤醒 </span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Condition与ConditionObject"><a href="#Condition与ConditionObject" class="headerlink" title="Condition与ConditionObject"></a><code>Condition与ConditionObject</code></h6><p>在AQS内部定义了一个类<code>ConditionObject</code>，该类实现了<code>Condition</code>接口。类直接的定义关系如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 条件队列头节点</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">        <span class="comment">// 条件队列尾节点</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h6 id="await方法"><a href="#await方法" class="headerlink" title="await方法"></a><code>await方法</code></h6><p>该方法是将当前线程添加到条件队列上。执行逻辑：① 若是当前线程已经被打断，直接抛出异常。 ② 调用<code>addConditionWaiter</code>方法，将当前的线程封装成为一个 Node 节点，添加到等待队列的尾部，并返回该节点。③  调用<code>fullyRelease</code>方法释放当前线程获取到的锁。④  while循环，调用 <code>isOnSyncQueue</code> 方法判断节点是否在同步队列，没在同步队列执行 <code>while</code> 循环体，挂起当前线程。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 判断中断，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// 添加到等待队列</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">// 释放该线程获取的锁</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加一个新的节点到等待队列。</span></span><br><span class="line"><span class="comment">// 1. 清除被取消的节点</span></span><br><span class="line"><span class="comment">// 2. 将当前线程封装成Node节点，添加到等待队列</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放当前线程获取到的锁</span></span><br><span class="line"><span class="comment">// 1. 获取到锁状态 state 的值</span></span><br><span class="line"><span class="comment">// 2. 调用 release 方法释放锁</span></span><br><span class="line"><span class="comment">// 3. 释放成功，返回state 之前的值。</span></span><br><span class="line"><span class="comment">// 4. 释放失败，抛出异常。</span></span><br><span class="line"><span class="comment">// 5. 若是释放失败，将当前线程节点的 waitStatus 状态值设置为 Node.CANCELLED（取消）</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> savedState = getState();</span><br><span class="line">        <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">            failed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed) &#123;</span><br><span class="line">            node.waitStatus = Node.CANCELLED;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判定给定的节点是否在同步队列上</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h6 id="signal方法"><a href="#signal方法" class="headerlink" title="signal方法"></a><code>signal方法</code></h6><p>① 调用<code>isHeldExclusively</code>方法，返回<code>false</code>，直接抛出异常，否则执行下一步。②  获取到等待队列的第一个节点，将其做为参数，调用<code>doSignal</code>方法。③ <code>doSignal</code>方法会将给定的节点从等待队列放到同步队列的尾部。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">        doSignal(first);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断获取到锁的线程是否为当前线程</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ReentrantLock的Sync的内部实现</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 first 节点从等待队列移动到同步队列</span></span><br><span class="line"><span class="comment">// 1. 将first节点从等待队列中去除</span></span><br><span class="line"><span class="comment">// 2. 调用 transferForSignal 方法将 first节点放到同步队列</span></span><br><span class="line"><span class="comment">// 3. 若是上一步失败，尝试下一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp; (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 node 节点添加到同步队列的尾部</span></span><br><span class="line"><span class="comment">// 1. cas操作将 node 节点的 waitStatus 状态值由 Node.CONDITION修改为0,修改失败返回false。</span></span><br><span class="line"><span class="comment">// 2. 将node节点添加到同步队列的尾部</span></span><br><span class="line"><span class="comment">// 3. 若是node节点的waitStatus状态值大于0,或者将node节点的状态值设置为SIGNAL失败，唤醒该节点线程。</span></span><br><span class="line"><span class="comment">// 4. 返回 true。</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h6 id="signalAll方法"><a href="#signalAll方法" class="headerlink" title="signalAll方法"></a><code>signalAll方法</code></h6><p>具体逻辑：大体和<code>signal</code>方法相同，但其会执行<code>doSignalAll(first)</code>方法而不是<code>doSignal(first)</code>方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignalAll(first);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1. 清除等待队列 lastWaiter = firstWaiter = null;</span></span><br><span class="line"><span class="comment">// 2. 从 first节点开始，依次调用 transferForSignal方法，直到节点为null。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignalAll</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    lastWaiter = firstWaiter = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        Node next = first.nextWaiter;</span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">        transferForSignal(first);</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (first != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h6 id=&quot;AQS类内部结构&quot;&gt;&lt;a href=&quot;#AQS类内部结构&quot; class=&quot;headerlink&quot; title=&quot;AQS类内部结构&quot;&gt;&lt;/a&gt;&lt;code&gt;AQS类内部结构&lt;/code&gt;&lt;/h6&gt;&lt;figure class=&quot;highlight java&quot;&gt;
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="源码" scheme="https://zhilongao.github.io/categories/java/%E6%BA%90%E7%A0%81/"/>
    
    
  </entry>
  
  <entry>
    <title>lambda和stream</title>
    <link href="https://zhilongao.github.io/wiki/java-style-lambda/"/>
    <id>https://zhilongao.github.io/wiki/java-style-lambda/</id>
    <published>2019-09-23T11:11:56.000Z</published>
    <updated>2019-09-25T05:42:41.729Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.infoq.cn/article/Java-se-8-lambda" target="_blank" rel="noopener">参考文章1</a></p><p><a href="https://my.oschina.net/chenxiaobian/blog/704421" target="_blank" rel="noopener">参考文章2</a></p><h6 id="功能性接口的简化"><a href="#功能性接口的简化" class="headerlink" title="功能性接口的简化"></a><code>功能性接口的简化</code></h6><hr><ol><li>lambda表达式可以简化<code>Runnable</code>，<code>Comparator</code>这种接口的写法。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*****lambda表达式简化线程的创建*****/</span></span><br><span class="line"><span class="comment">// 普通写法</span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// lambda写法</span></span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"><span class="comment">// do something                </span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****lambda表达式简化 Collections.sort 排序*****/</span></span><br><span class="line"><span class="comment">// 普通写法</span></span><br><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1 - o2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// lambda写法</span></span><br><span class="line">Collections.sort(list, (x, y) -&gt; x - y);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****自定义功能接口*****/</span></span><br><span class="line">List&lt;String&gt; params = Arrays.asList(<span class="keyword">new</span> String[]&#123;<span class="string">"app"</span>, <span class="string">"red"</span>, <span class="string">"blue"</span>&#125;);</span><br><span class="line"><span class="comment">// 映射List中元素的length集合</span></span><br><span class="line">List&lt;Integer&gt; res1 = <span class="keyword">new</span> CollectionUtils&lt;String, Integer&gt;().map(params, (String param) -&gt; param.length());</span><br><span class="line"><span class="comment">// 映射list中以元素的大写集合</span></span><br><span class="line">List&lt;String&gt; res2 = <span class="keyword">new</span> CollectionUtils&lt;String, String&gt;().map(params, (String param) -&gt; param.toUpperCase());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义函数式接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyOP</span>&lt;<span class="title">P</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(P obj)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 集合操作类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollectionUtils</span>&lt;<span class="title">P</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 对集合中的元素进行操作，操作完成之后返回一个新的集合</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;R&gt; <span class="title">map</span><span class="params">(List&lt;P&gt; input, MyOP&lt;P, R&gt; myOp)</span> </span>&#123;</span><br><span class="line">        List&lt;R&gt; result = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span> (P obj : input) &#123;</span><br><span class="line">            result.add(myOp.apply(obj));</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="方法和构造方法的引用"><a href="#方法和构造方法的引用" class="headerlink" title="方法和构造方法的引用"></a><code>方法和构造方法的引用</code></h6><hr><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lambda表达式的一般写法</span></span><br><span class="line">params.forEach((v) -&gt; System.out.print(v + <span class="string">"\t"</span>));</span><br><span class="line"><span class="comment">// lambda的简化写法</span></span><br><span class="line">params.forEach(System.out::print);</span><br><span class="line"></span><br><span class="line"><span class="comment">// lambda构造方法的简写 Date::new</span></span><br><span class="line">List&lt;Long&gt; dateValues = Arrays.asList(<span class="keyword">new</span> Long[] &#123;<span class="number">0L</span>, <span class="number">1000L</span>&#125;);</span><br><span class="line">List&lt;Date&gt; map = <span class="keyword">new</span> CollectionUtils&lt;Long, Date&gt;().map(dateValues, Date::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure><h6 id="接口的默认方法"><a href="#接口的默认方法" class="headerlink" title="接口的默认方法"></a><code>接口的默认方法</code></h6><hr><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 解决了接口的演化问题（接口中新增默认实现方法，不影响原先的实现类）</span><br><span class="line"><span class="number">2</span>. 实现了行为的多继承 （一个类可以实现多个接口的默认方法）</span><br></pre></td></tr></table></figure><h6 id="stream"><a href="#stream" class="headerlink" title="stream"></a><code>stream</code></h6><hr><p><code>Stream原理</code>：流式操作，由 jdk 内部分配多个线程来执行 stream 内部的操作。并发流使用的默认线程数等于你机器的处理器核心数。</p><p><code>Stream场景</code>：由于 Stream 是由 jdk 内部来为任务分配线程，所以在 一些耗时操作慎用 Stream。</p><p><code>Stream应用</code>：Stream.of()方法，可以接收单个参数，也可以接收一个数组参数，将其转换为一个Stream对象。下面是几个Stream的简单应用demo。</p><hr><p>（1）实例代码(forEach方法遍历)-&gt;接收一个参数, 通过forEach方法接收一个功能接口。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">Stream.of(list).forEach(System.out::println);</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><hr><p>（2）实例代码(forEach方法遍历)-&gt;接收一个数组，通过forEach方法接收一个功能接口。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(list.toArray()).forEach(System.out::println);</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><hr><p>（3）实例代码(filter方法过滤)-&gt; 找处以小写字母’a’开头的字符串</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">"Abc"</span>, <span class="string">"abc"</span>, <span class="string">"ccc"</span>, <span class="string">"asD"</span>)</span><br><span class="line">    .filter((str) -&gt; &#123;<span class="keyword">return</span> str.startsWith(<span class="string">"a"</span>);&#125;)</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// asD</span></span><br></pre></td></tr></table></figure><hr><p>（4）实例方法-&gt;(map方法建立映射)-&gt; 统计给出数组中每个字符串的长度</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">"A"</span>, <span class="string">"abc"</span>, <span class="string">"cc"</span>, <span class="string">"a"</span>)</span><br><span class="line">    .map((str) -&gt; str.length())</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><hr><p> （5）实例方法-&gt;(reduce方法的使用) -&gt; 初始值为 100，计算初始值加1到5的值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">int</span> init = <span class="number">100</span>;</span><br><span class="line">Integer result = integerList.stream()</span><br><span class="line">    .reduce(init, (a, b) -&gt; a + b);</span><br><span class="line">System.out.println(<span class="string">"result-&gt;"</span> + result);</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// 115</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.infoq.cn/article/Java-se-8-lambda&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考文章1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://my.oschina.net/c
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="新特性" scheme="https://zhilongao.github.io/categories/java/%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>负载均衡</title>
    <link href="https://zhilongao.github.io/wiki/fra-spring-cloud-loadbalance/"/>
    <id>https://zhilongao.github.io/wiki/fra-spring-cloud-loadbalance/</id>
    <published>2019-09-21T01:31:06.000Z</published>
    <updated>2019-09-21T08:05:15.345Z</updated>
    
    <content type="html"><![CDATA[<p>完善中。。。。</p><h6 id="负载均衡算法基础-理论"><a href="#负载均衡算法基础-理论" class="headerlink" title="负载均衡算法基础(理论)"></a><code>负载均衡算法基础(理论)</code></h6><p><a href="https://en.wikipedia.org/wiki/Load_balancing_(computing)" target="_blank" rel="noopener">参考资料</a></p><hr><p>负载均衡分类：客户端负载均衡  服务端负载均衡</p><hr><p>负载均衡算法</p><p>​    随机   轮询</p><p>​    权重</p><hr><h6 id="Ribbon的实现-设计"><a href="#Ribbon的实现-设计" class="headerlink" title="Ribbon的实现(设计)"></a><code>Ribbon的实现(设计)</code></h6><p>设计分析</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 核心接口</span></span><br><span class="line">com.netflix.loadbalancer.IRule</span><br><span class="line">com.netflix.loadbalancer.ILoadBalancer</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务实例定义实体</span></span><br><span class="line">Netflix Eureka </span><br><span class="line">com.netflix.appinfo.InstanceInfo</span><br><span class="line"></span><br><span class="line">Spring Cloud Commons</span><br><span class="line">org.springframework.cloud.client.ServiceInstance</span><br><span class="line"></span><br><span class="line">Netflix Ribbon</span><br><span class="line">com.netflix.loadbalancer.Server</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;完善中。。。。&lt;/p&gt;
&lt;h6 id=&quot;负载均衡算法基础-理论&quot;&gt;&lt;a href=&quot;#负载均衡算法基础-理论&quot; class=&quot;headerlink&quot; title=&quot;负载均衡算法基础(理论)&quot;&gt;&lt;/a&gt;&lt;code&gt;负载均衡算法基础(理论)&lt;/code&gt;&lt;/h6&gt;&lt;p&gt;&lt;a h
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="框架" scheme="https://zhilongao.github.io/categories/java/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="spring-cloud" scheme="https://zhilongao.github.io/categories/java/%E6%A1%86%E6%9E%B6/spring-cloud/"/>
    
    
  </entry>
  
  <entry>
    <title>ReentrantLock</title>
    <link href="https://zhilongao.github.io/wiki/ans-reentlock-source/"/>
    <id>https://zhilongao.github.io/wiki/ans-reentlock-source/</id>
    <published>2019-09-18T12:31:57.000Z</published>
    <updated>2019-09-27T09:29:08.157Z</updated>
    
    <content type="html"><![CDATA[<hr><h6 id="类关系与锁初始化"><a href="#类关系与锁初始化" class="headerlink" title="类关系与锁初始化"></a><code>类关系与锁初始化</code></h6><p>在<code>ReentrantLock</code>类内部有一个属性，<code>Sync:sync</code>，该属性对应的类是定义在<code>ReentrantLock</code>内部的一个静态类（抽象类）。<code>ReentrantLock</code>内部又为<code>Sync</code>定义了两个子类<code>NonfairSync</code>和<code>FairSync</code>。根据类名便可看到非公平与公平之分。我们通过api使用<code>ReentrantLock</code>类时，会调用其构造函数创建一个该类型的对象，构造函数可传参数<code>true|false</code>，确定创建公平或非公平锁。若没传递参数，会默认创建非公平锁。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 几个类定义关系图</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认创建非公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 参数为 true 创建公平锁，false 创建非公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h6 id="方法调用关系"><a href="#方法调用关系" class="headerlink" title="方法调用关系"></a><code>方法调用关系</code></h6><p>调用<code>ReentrantLock:lock</code>方法或是<code>ReentrantLock:unlock</code>方法时，<code>ReentrantLock</code>会委托<code>Sync</code>来执行具体的上锁或者是释放锁的逻辑。① 关于<code>lock</code>，在<code>Sync</code>内部定义了一个抽象方法<code>Sync:lock</code>，在其子类<code>FairSync</code>和<code>NonfairSync</code>均实现了这个方法。这两个实现类的<code>lock</code>方法最终又会调用<code>Sync</code>的父类<code>AQS</code>的<code>acquire</code>方法。② 关于<code>unlock</code>，实际上调用的是<code>Sync</code>的父类<code>AQS</code>的<code>release</code>方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*****ReentrantLock*****/</span></span><br><span class="line"><span class="comment">// 上锁，调用sync的lock方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解锁，调用sync的父类aqs的release方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*****Sync*****/</span></span><br><span class="line"><span class="comment">// 上锁-&gt; 抽象方法，具体逻辑由子类FairSync或NonfairSync来实现</span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 解锁-&gt; Sync的父类AbstractQueuedSynchronizer定义的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FairSync类实现的lock方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// NonfairSync类实现的lock方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h6 id="lock之公平与非公平"><a href="#lock之公平与非公平" class="headerlink" title="lock之公平与非公平"></a><code>lock之公平与非公平</code></h6><p>① <code>NonfairSync:lock</code>方法在执行时，首先会通过CAS操作直接修改锁状态<code>state</code>的值，若是执行成功，则成功获取到锁，若是执行失败，调用<code>AbstractQueuedSynchronizer:acquire(1)</code>方法来执行普通的上锁逻辑。<code>FairSync:lock</code>方法在执行时，直接调用 <code>AbstractQueuedSynchronizer:acquire(1)</code>方法来执行普通的上锁逻辑。（非公平锁直接忽略了排队等待获取锁的线程）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*****NonfairSync*****/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*****FairSync*****/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>② 在上面的分析中，非公平锁的实现类在尝试设置锁失败时，直接调用<code>AQS</code>的<code>acquire</code>方法，而公平锁的实现类直接调用<code>AQS</code>的<code>acquire</code>方法。<code>AQS:acquire</code>方法属于一个模板方法，内部定义了获取锁的操作步骤。其中<code>tryAcquire</code>方法是其第一个调用的方法，也是一个没有实现的空方法，具体的实现逻辑由其子类来实现。</p><p><code>NonfairSync:tryAcquire</code>方法内部会调用其父类的<code>Sync:nonfairTryAcquire</code>方法，该方法语义为非公平尝试获取。具体逻辑：首先判断锁的状态，若是没有线程获取到锁，执行通过<code>CAS</code>操作修改锁状态，若是成功返回<code>true</code>。若是未成功，继续判断获取锁的线程是否为当前线程，若是当前线程，将锁状态值加上方法传入的值，并将锁状态值更新（可重入），返回<code>true</code>，否则返回<code>false</code>。 </p><p><code>FairSync:tryAcquire</code>方法的执行逻辑：判断是   否有线程获取到锁，若是没有线程获取到锁，继续判断是否有线程等待获取锁，若是无线程等待获取锁，<code>CAS</code>操作获取锁，成功返回<code>true</code>。操作获取锁失败，或者有线程等待获取锁，或者已有线程获取到锁，继续判断当前获取到锁的线程是否为当前线程，是则执行可重入锁操作并返回<code>true</code>，否则返回<code>false</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*****AbstractQueuedSynchronizer *****/</span></span><br><span class="line"><span class="comment">// AQS中定义的获取锁的模板方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一个未实现的方法，具体逻辑由子类来实现</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*****NonfairSync*****/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*****Sync*****/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****FairSync*****/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h6 id="unlock执行逻辑"><a href="#unlock执行逻辑" class="headerlink" title="unlock执行逻辑"></a><code>unlock执行逻辑</code></h6><p>调用<code>ReentrantLock:unlock</code>方法时，<code>Sync</code>会调用父类的<code>AbstractQueuedSynchronizer：release</code>方法。</p><p>具体逻辑是：① 首先<code>tryRelease</code>方法会被调用，而这个方法在<code>AQS</code>中是一个没有具体实现的空方法，具体逻辑由子类<code>Sync</code>来实现。② 子类中首先会去判断当前线程是否就是获取到锁的线程，若不是直接抛出异常，否则执行下一步的逻辑。③  获取到锁状态<code>state</code>的值，并用<code>state</code>值减去方法传的参数值（释放多少次），计算出一个结果。④  若是计算出来的这个结果为<code>0</code>，将<code>state</code>的值设置为<code>0</code>，并将获取锁的线程设置为<code>null</code>，并返回<code>true</code>。⑤ 若是计算出来的这个结果不为<code>0</code>，将<code>state</code>的值设置为计算得到的值，返回<code>false</code>。</p><p>子类执行完<code>tryRelease</code>方法后，会返回一个值。① 若是该值为<code>true</code>，<code>AQS:release</code>方法会执行其它逻辑，执行完返回<code>true</code>。② 若是该值为<code>false</code>，<code>AQS:release</code>方法直接返回<code>false</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*****ReentrantLock *****/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*****AbstractQueuedSynchronizer *****/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****Sync*****/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h6 id="LockSupport与Unsafe"><a href="#LockSupport与Unsafe" class="headerlink" title="LockSupport与Unsafe"></a><code>LockSupport与Unsafe</code></h6><hr><p>在<code>LockSupport</code>中提供了两个方法，<code>park</code>与<code>unpark</code>方法，而这两个方法实际上又是调用的<code>Unsafe</code>类中的<code>native</code>方法。<code>park</code>是将当前调用线程阻塞，而<code>unpark</code>方法则是唤醒指定的线程。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupport</span> </span>&#123;</span><br><span class="line">    <span class="comment">// jdk内部用于操作内存地址的类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">...</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用 Unsafe 类的park方法将当前线程阻塞</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        setBlocker(t, blocker);</span><br><span class="line">        UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">        setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用 Unsafe 类的unpark方法唤醒指定的线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            UNSAFE.unpark(thread);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="comment">// jdk核心类库可操作的api</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsafe</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe theUnsafe;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        theUnsafe = <span class="keyword">new</span> Unsafe();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Unsafe</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该类中的 theUnsafe 属性为该类的一个实例，对外只提供给jdk核心类库使用。我们在平常的开发中无法通过该方法来获取 theUnsafe 对象。（可以通过万能的反射方式获取）</span></span><br><span class="line">    <span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Class var0 = Reflection.getCallerClass();</span><br><span class="line">        <span class="keyword">if</span> (!VM.isSystemDomainLoader(var0.getClassLoader())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Unsafe"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> theUnsafe;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// native方法，阻塞当前线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">boolean</span> var1, <span class="keyword">long</span> var2)</span></span>;</span><br><span class="line">    <span class="comment">// native方法，唤醒指定的线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Object var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>关于可重入锁的Condition分析—-&gt; 等待队列</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ReentrantLock</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sync</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS-&gt;ConditionObject</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1173984872572414699L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConditionObject</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加一个等待的线程</span></span><br><span class="line">    <span class="comment">// 若是最后一个节点不为null，并且其 waitStatus 状态值不为 CONDITION。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node t = lastWaiter;</span><br><span class="line">        <span class="comment">// 添加之前先清理一番</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line">            t = lastWaiter;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建一个节点， 将其加入到同步队列的尾部</span></span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            firstWaiter = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            t.nextWaiter = node;</span><br><span class="line">        &#125;    </span><br><span class="line">        lastWaiter = node;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个方法的目的就一个: 从等待队列中清除 waitStatus 状态值不为 CONDITION 的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node t = firstWaiter;</span><br><span class="line">        Node trail = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 在节点 t 不为 null 的情况下，不断的执行循环操作</span></span><br><span class="line">        <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 首先保存下一个节点，然后判断当前节点</span></span><br><span class="line">            Node next = t.nextWaiter;</span><br><span class="line">            <span class="comment">// 若是节点的 waitStatus 状态值不为 CONDITION，将节点 t 的 nextWaiter指向为null</span></span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">                t.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 这种情况是: 第一个节点的 waitStatus状态值已经不为 CONDITION 了，可能 next节点为等待节点，故先将 firstWaiter指向 next。若是当前的 trail不为null, 则 trail的nextWaiter也应该指向 next</span></span><br><span class="line">                <span class="keyword">if</span> (trail == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    firstWaiter = next;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    trail.nextWaiter = next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 这种情况是: 遍历到了最后一个节点，并且其 waitStatus 状态值不为 CONDITION，故需要在跳出循环之前将lastWaiter节点更新为 trail节点。</span></span><br><span class="line">                <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    lastWaiter = trail;</span><br><span class="line">                &#125; </span><br><span class="line">            <span class="comment">// 若是节点的 waitStatus 状态值为 CONDITION    </span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                trail = t;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// 下一次循环遍历的节点</span></span><br><span class="line">            t = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/****************************************************/</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取锁状态标识(0: 未上锁  &gt;=1 上锁)</span></span><br><span class="line">            <span class="keyword">int</span> savedState = getState();</span><br><span class="line">            <span class="comment">// 释放成功，返回释放前 state 的值</span></span><br><span class="line">            <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> savedState;</span><br><span class="line">            <span class="comment">// 否则直接抛出异常    </span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 若是操作失败，将当前节点的waitStatus状态值设置未CANCELLED</span></span><br><span class="line">            <span class="keyword">if</span> (failed) &#123;</span><br><span class="line">                node.waitStatus = Node.CANCELLED;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 缩放锁-&gt;在调用await方法时，释放掉当前线程所持有的锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// tryRelease时 ReentrantLock的内部类Sync的方法，成功释放锁返回true，否则返回 false。</span></span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="comment">// 当前线程已经进入到await状态，唤醒啦一个线程来获取锁</span></span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>) &#123;</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;    </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其它情况返回 false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点添加到同步队列和条件队列的区别(两点区别判断给定节点当前所处位置)</span></span><br><span class="line">    <span class="comment">// 同步队列: 双向列表，节点有 prev 和 next 指针指向前驱节点和后继节点。nextWaiter 状态值为 null。</span></span><br><span class="line">    <span class="comment">// 条件队列: 单向列表，节点有 nextWaiter 指针指向后继节点。waitStatus 状态值为 Node.CONDITION</span></span><br><span class="line">    <span class="comment">// 若是节点已经在同步队列上，则返回 true</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 若是 waitStatus 为 Node.CONDITION，证明在条件队列，返回 false。</span></span><br><span class="line">        <span class="comment">// 若不是在条件队列，但是节点的 prev 为 null，也返回 false。</span></span><br><span class="line">        <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 若是节点的 next 指针不指向 null，直接返回 true</span></span><br><span class="line">        <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 从同步队列的尾部找</span></span><br><span class="line">        <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1. 若是在同步队列中找到了，返回 true。</span></span><br><span class="line">    <span class="comment">// 2. 若是在同步队列中没有找到，返回 false。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">findNodeFromTail</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 若是找到的化，直接返回 true</span></span><br><span class="line">            <span class="keyword">if</span> (t == node) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;    </span><br><span class="line">            <span class="comment">// 已经找了一遍，但还是没有找到，返回 false</span></span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取前一个节点判断</span></span><br><span class="line">            t = t.prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted() ?</span><br><span class="line">            (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class="line">        <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关于await方法</span></span><br><span class="line">    <span class="comment">// 1. 若是当前线程已经被中断，直接抛出异常，结束方法的运行。</span></span><br><span class="line">    <span class="comment">// 2. 调用 addConditionWaiter 方法， 将当前的线程封装成为一个 Node 节点，添加到等待队列的尾部。</span></span><br><span class="line">    <span class="comment">// 3. 调用 fullyRelease 方法，释放当前线程所获取到的锁。</span></span><br><span class="line">    <span class="comment">// 4. while循环，调用 isOnSyncQueue 方法判断节点是否在同步队列，没在同步队列执行 while 循环体。挂起当前线程。</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 加入到等待队列</span></span><br><span class="line">        Node node = addConditionWaiter();</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">        <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 线程没在同步队列。</span></span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">            <span class="comment">// 挂起当前线程</span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// 当前线程被唤醒时，执行。检查线程是否被打断，若是已经被打断，结束执行。</span></span><br><span class="line">            <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) &#123;</span><br><span class="line">            interruptMode = REINTERRUPT;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">if</span> (interruptMode != <span class="number">0</span>) &#123;</span><br><span class="line">            reportInterruptAfterWait(interruptMode);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// </span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">// 获取节点的前驱节点</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="comment">// 前驱节点为 head，尝试获取锁，并获取成功</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 获取锁失败执行 park 操作。</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) &#123;</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed) &#123;</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// signal 方法分析</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 拥有锁的线程非当前线程，直接抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 获取到条件队列的第一个节点，对其执行 doSignal 操作。</span></span><br><span class="line">        Node first = firstWaiter;</span><br><span class="line">        <span class="keyword">if</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">            doSignal(first);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// signalAll 方法分析</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 同 signal</span></span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取都条件队列的第一个节点，对其执行 doSignall 操作</span></span><br><span class="line">        Node first = firstWaiter;</span><br><span class="line">        <span class="keyword">if</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">            doSignalAll(first);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 操作是将给定的节点从条件队列转移至同步队列。若是操作失败，会去尝试给定节点的下一个节点，直到条件队列中已经没有节点了。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 总会执行的操作: firstWaiter 指向 first 节点的 nextWaiter 节点。</span></span><br><span class="line">            <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 若是 firstWaiter 为 null 了，则 lastWaiter 也将指向 null。</span></span><br><span class="line">                lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 下面的操作是将 first 节点添加到 同步队列，故将其 nextWaiter 属性值指向为 null。</span></span><br><span class="line">            first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 若是将 first 节点从条件队列转移至同步队列失败并且 firstWaiter 不为 null。    </span></span><br><span class="line">        &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp; (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Node 节点 waitStatus 属性的几个状态值。</span></span><br><span class="line">    <span class="comment">// static final int CANCELLED =  1; 表示节点已经被取消</span></span><br><span class="line">    <span class="comment">// static final int SIGNAL    = -1; 表示后面节点的线程需要被唤醒。</span></span><br><span class="line">    <span class="comment">// static final int CONDITION = -2; 表示节点在条件队列上</span></span><br><span class="line">    <span class="comment">// static final int PROPAGATE = -3; 关于共享锁的状态</span></span><br><span class="line">    <span class="comment">// 0; 非以上值，取0  </span></span><br><span class="line">    <span class="comment">// Node 节点 nextWaiter 属性的几个状态值</span></span><br><span class="line">    <span class="comment">// static final Node SHARED = new Node(); 标记节点在共享模式下等待</span></span><br><span class="line"><span class="comment">// static final Node EXCLUSIVE = null; 标记节点在排他模式下等待</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 操作: 将节点从条件队列转移至同步队列，操作成功返回 true。</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// case 操作尝试，失败返回 false。</span></span><br><span class="line">        <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 将该节点添加到同步队列的尾部，并返回该节点的前一个节点</span></span><br><span class="line">        Node p = enq(node);</span><br><span class="line">        <span class="comment">// 获取返回节点的 waitStatus 状态值</span></span><br><span class="line">        <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">        <span class="comment">// ws 节点被取消</span></span><br><span class="line">        <span class="comment">// ws 未被取消，尝试将其waitStatus状态值从 ws 设置为 SIGNAL失败</span></span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)) &#123;</span><br><span class="line">            <span class="comment">// 唤醒该节点的线程</span></span><br><span class="line">            LockSupport.unpark(node.thread);</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="comment">// 返回 true。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将节点插入到队列，必要时初始化。 返回值为 node 节点的前一个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">            <span class="comment">// 同步队列为 null，初始化 head 和 tail。</span></span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node())) &#123;</span><br><span class="line">                    tail = head;</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// doSignalAll, 唤醒条件队列上的所有线程</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignalAll</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 清除条件队列</span></span><br><span class="line">        lastWaiter = firstWaiter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 循环操作，从第一个节点开始，将条件队列上的所有节点添加到同步队列</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 保存下一个节点</span></span><br><span class="line">            Node next = first.nextWaiter;</span><br><span class="line">            <span class="comment">// 清除 first 节点的 nextWaiter属性</span></span><br><span class="line">            first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 将 first 节点转移至同不队列</span></span><br><span class="line">            transferForSignal(first);</span><br><span class="line">            <span class="comment">// 更新 first 节点</span></span><br><span class="line">            first = next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (first != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h6 id=&quot;类关系与锁初始化&quot;&gt;&lt;a href=&quot;#类关系与锁初始化&quot; class=&quot;headerlink&quot; title=&quot;类关系与锁初始化&quot;&gt;&lt;/a&gt;&lt;code&gt;类关系与锁初始化&lt;/code&gt;&lt;/h6&gt;&lt;p&gt;在&lt;code&gt;ReentrantLock&lt;/code&gt;类
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="源码" scheme="https://zhilongao.github.io/categories/java/%E6%BA%90%E7%A0%81/"/>
    
    
  </entry>
  
  <entry>
    <title>监听器模式</title>
    <link href="https://zhilongao.github.io/wiki/design-pattern-listener/"/>
    <id>https://zhilongao.github.io/wiki/design-pattern-listener/</id>
    <published>2019-09-13T02:58:12.000Z</published>
    <updated>2019-09-25T11:40:02.799Z</updated>
    
    <content type="html"><![CDATA[<h6 id="监听器模式"><a href="#监听器模式" class="headerlink" title="监听器模式"></a><code>监听器模式</code></h6><p>针对监听器模式，jdk提供了<code>EventListener</code>接口和<code>EventObject</code>类，分别定义事件监听器和事件对象。下面是通过扩展这两个接口实现一个简单的事件监听器模式。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/13 11:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 事件源</span></span><br><span class="line">        MyEventSource eventSource = <span class="keyword">new</span> MyEventSource();</span><br><span class="line">        <span class="comment">// 创建事件监听器-&gt;处理EventObject</span></span><br><span class="line">        StartEventListener startEventListener = <span class="keyword">new</span> StartEventListener();</span><br><span class="line">        ClosedEventListener closedEventListener = <span class="keyword">new</span> ClosedEventListener();</span><br><span class="line">        <span class="comment">// 添加事件监听器</span></span><br><span class="line">        eventSource.addEventListener(startEventListener);</span><br><span class="line">        eventSource.addEventListener(closedEventListener);</span><br><span class="line">        <span class="comment">// 创建事件对象</span></span><br><span class="line">        EventObject startEventObject = <span class="keyword">new</span> EventObject(<span class="string">"start"</span>);</span><br><span class="line">        EventObject closedEventObject = <span class="keyword">new</span> EventObject(<span class="string">"closed"</span>);</span><br><span class="line">        <span class="comment">// 事件源-&gt;通知事件监听者来处理</span></span><br><span class="line">        eventSource.notifyListenerEvents(startEventObject);</span><br><span class="line">        eventSource.notifyListenerEvents(closedEventObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/13 11:00</span></span><br><span class="line"><span class="comment"> * 扩展的监听器接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyEventListener</span> <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理EventObject</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleEvent</span><span class="params">(EventObject event)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/13 11:21</span></span><br><span class="line"><span class="comment"> * 启动事件监听器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartEventListener</span> <span class="keyword">implements</span> <span class="title">MyEventListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleEvent</span><span class="params">(EventObject event)</span> </span>&#123;</span><br><span class="line">        Object source = event.getSource();</span><br><span class="line">        <span class="keyword">if</span> (source.equals(<span class="string">"start"</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"context has start!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/13 11:24</span></span><br><span class="line"><span class="comment"> * 关闭事件监听器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClosedEventListener</span> <span class="keyword">implements</span> <span class="title">MyEventListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleEvent</span><span class="params">(EventObject event)</span> </span>&#123;</span><br><span class="line">        Object source = event.getSource();</span><br><span class="line">        <span class="keyword">if</span> (source.equals(<span class="string">"closed"</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"context has closed!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/13 11:03</span></span><br><span class="line"><span class="comment"> * 事件源-&gt;添加 删除 通知</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEventSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听器列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Vector&lt;EventListener&gt; listeners = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册监听器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> eventListener</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEventListener</span><span class="params">(EventListener eventListener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!listeners.contains(eventListener)) &#123;</span><br><span class="line">            listeners.add(eventListener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除监听器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> eventListener</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeEventListener</span><span class="params">(EventListener eventListener)</span> </span>&#123;</span><br><span class="line">        listeners.remove(eventListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收外部的事件-&gt;将事件交给事件监听者来处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyListenerEvents</span><span class="params">(EventObject event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (EventListener eventListener : listeners) &#123;</span><br><span class="line">            ((MyEventListener)eventListener).handleEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="jdk中监听器模式的实现"><a href="#jdk中监听器模式的实现" class="headerlink" title="jdk中监听器模式的实现"></a><code>jdk中监听器模式的实现</code></h6><p>jdk针对监听器模式并未定义太多的实现，只是定义了一个<code>EventListener</code>接口和一个<code>EventObject</code>类，我们可以扩展<code>EventListener</code>接口来定义处理<code>EventObject</code>的方法。在<code>EventObject</code>中有一个属性<code>Object:source</code>，该属性可以在定义<code>EventObject</code>的时候，传入一些参数值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventObject</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">transient</span> Object  source;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EventObject</span><span class="params">(Object source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (source == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"null source"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.source = source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> source;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">"[source="</span> + source + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="spring中监听器模式的实现"><a href="#spring中监听器模式的实现" class="headerlink" title="spring中监听器模式的实现"></a><code>spring中监听器模式的实现</code></h6><p>在spring中定义了<code>ApplicationListener</code>接口和<code>ApplicationEvent</code>类，其中<code>ApplicationListener</code>接口实现了jdk中定义的<code>EventListener</code>接口，并定义了<code>onApplicationEvent</code>方法来处理事件，并且每个<code>ApplicationListener</code>只会处理特定的事件。<code>ApplicationEvent</code>类继承了jdk中定义的<code>EventObject</code>类，用以定义事件对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 扩展的事件监听器接口-&gt;采用泛型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationListener</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span>&gt; <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(E event)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展的EventObject</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationEvent</span> <span class="keyword">extends</span> <span class="title">EventObject</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7099057708183571937L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timestamp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ApplicationEvent</span><span class="params">(Object source)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(source);</span><br><span class="line"><span class="keyword">this</span>.timestamp = System.currentTimeMillis();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getTimestamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.timestamp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="spring中监听器模式的使用"><a href="#spring中监听器模式的使用" class="headerlink" title="spring中监听器模式的使用"></a><code>spring中监听器模式的使用</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/13 11:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        <span class="comment">// 注册监听器</span></span><br><span class="line">        context.addApplicationListener(<span class="keyword">new</span> ApplicationListener&lt;MyApplicationEvent&gt;() &#123;</span><br><span class="line">            <span class="comment">// 接收到事件</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(MyApplicationEvent event)</span> </span>&#123;</span><br><span class="line">                System.out.println(event.getSource());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        context.refresh();</span><br><span class="line">        <span class="comment">// 发布事件</span></span><br><span class="line">        context.publishEvent(<span class="keyword">new</span> MyApplicationEvent(<span class="string">"study spring！"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApplicationEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span></span>&#123;</span><br><span class="line">    MyApplicationEvent(Object source) &#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;监听器模式&quot;&gt;&lt;a href=&quot;#监听器模式&quot; class=&quot;headerlink&quot; title=&quot;监听器模式&quot;&gt;&lt;/a&gt;&lt;code&gt;监听器模式&lt;/code&gt;&lt;/h6&gt;&lt;p&gt;针对监听器模式，jdk提供了&lt;code&gt;EventListener&lt;/code&gt;接口和&lt;c
      
    
    </summary>
    
      <category term="设计模式" scheme="https://zhilongao.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>观察者模式</title>
    <link href="https://zhilongao.github.io/wiki/design-pattern-observer/"/>
    <id>https://zhilongao.github.io/wiki/design-pattern-observer/</id>
    <published>2019-09-13T01:54:53.000Z</published>
    <updated>2019-09-25T11:40:26.715Z</updated>
    
    <content type="html"><![CDATA[<h6 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a><code>观察者模式</code></h6><p>可以通过jdk中提供的<code>Observable</code>类和<code>Observer</code>接口来实现观察者模式。下面通过简单的会员订阅频道，然后频道定期的去给订阅的会员推送消息，展示jdk中观察者模式的使用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/13 9:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 科技频道</span></span><br><span class="line">        TechnologyChannel technologyChannel = <span class="keyword">new</span> TechnologyChannel();</span><br><span class="line">        technologyChannel.setTitle(<span class="string">"科技频道"</span>);</span><br><span class="line">        <span class="comment">// 用户</span></span><br><span class="line">        Members member1 = <span class="keyword">new</span> Members();</span><br><span class="line">        Members member2 = <span class="keyword">new</span> Members();</span><br><span class="line">        <span class="comment">// 用户订阅该科技频道</span></span><br><span class="line">        technologyChannel.addObserver(member1);</span><br><span class="line">        technologyChannel.addObserver(member2);</span><br><span class="line">        <span class="comment">// 给会员定时推送消息</span></span><br><span class="line">        String[] messages = &#123;<span class="string">"华为"</span>, <span class="string">"小米"</span>, <span class="string">"苹果"</span>&#125;;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) &#123;</span><br><span class="line">            <span class="comment">// 创建消息</span></span><br><span class="line">            NotifyMessage message = <span class="keyword">new</span> NotifyMessage();</span><br><span class="line">            String id = UUID.randomUUID().toString();</span><br><span class="line">            message.setId(id);</span><br><span class="line">            message.setCreateTime(System.currentTimeMillis());</span><br><span class="line">            message.setTitle(<span class="string">"手机"</span>);</span><br><span class="line">            message.setContent(messages[random.nextInt(<span class="number">3</span>)] + <span class="string">"又出新机，赶快来订购吧!"</span>);</span><br><span class="line">            <span class="comment">// 评到发送消息给订阅的会员</span></span><br><span class="line">            technologyChannel.setChanged();</span><br><span class="line">            technologyChannel.notifyObservers(message);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/13 9:14</span></span><br><span class="line"><span class="comment"> * 频道</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TechnologyChannel</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setChanged();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/13 9:13</span></span><br><span class="line"><span class="comment"> * 会员</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Members</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> TechnologyChannel) &#123;</span><br><span class="line">            TechnologyChannel channel = (TechnologyChannel)o;</span><br><span class="line">            String title = channel.getTitle();</span><br><span class="line">            NotifyMessage message = (NotifyMessage)arg;</span><br><span class="line">            System.out.println(<span class="string">"channel:"</span> + title);</span><br><span class="line">            System.out.println(<span class="string">"message:"</span> + message);</span><br><span class="line">            System.out.println(<span class="string">"======================="</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/13 9:28</span></span><br><span class="line"><span class="comment"> * 消息通知</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotifyMessage</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> Long createTime;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="jdk中观察者模式的实现"><a href="#jdk中观察者模式的实现" class="headerlink" title="jdk中观察者模式的实现"></a><code>jdk中观察者模式的实现</code></h6><ol><li>观察者（类似订阅模式中的订阅者）。jdk中定义了一个公共的接口<code>Observer</code>，里面定义了一个<code>update</code>方法，该方法可以接收被观察者对象和一个参数对象。我们可以通过实现该接口，重写<code>update</code>方法来实现观察者的逻辑。</li><li>被观察者（类似订阅模式中的被订阅者）。jdk中定义了一个类<code>Observable</code>，可以实现添加，移除，通知观察者。该类里面有两个属性<code>boolean:changed</code>和<code>Vector:obs</code>。当我们执行<code>addObserver</code>方法来添加观察者时，若是该观察者还未被加入到<code>Vector:obs</code>中，会将观察者加入到该集合。当我们执行<code>notifyObservers</code>方法来通知观察者时，只有<code>changed</code>属性为<code>true</code>时，才会依次调用观察者的<code>update</code>方法。若是该值为<code>true</code>，在调用观察者的<code>update</code>方法之前，又会将该值设置为<code>false</code>。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> Vector&lt;Observer&gt; obs;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Observable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obs = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!obs.contains(o)) &#123;</span><br><span class="line">            obs.addElement(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知所有的观察者，可以传递一个参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">        Object[] arrLocal;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 若是状态未变化，不做任何事情</span></span><br><span class="line">            <span class="keyword">if</span> (!changed) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将Vector转化为一个数组</span></span><br><span class="line">            arrLocal = obs.toArray();</span><br><span class="line">            <span class="comment">// 将changed设置为false</span></span><br><span class="line">            clearChanged();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 循环遍历Observer数组，调用其update方法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arrLocal.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">            ((Observer)arrLocal[i]).update(<span class="keyword">this</span>, arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;观察者模式&quot;&gt;&lt;a href=&quot;#观察者模式&quot; class=&quot;headerlink&quot; title=&quot;观察者模式&quot;&gt;&lt;/a&gt;&lt;code&gt;观察者模式&lt;/code&gt;&lt;/h6&gt;&lt;p&gt;可以通过jdk中提供的&lt;code&gt;Observable&lt;/code&gt;类和&lt;code&gt;Obs
      
    
    </summary>
    
      <category term="设计模式" scheme="https://zhilongao.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>分布式配置</title>
    <link href="https://zhilongao.github.io/wiki/fra-spring-cloud-config/"/>
    <id>https://zhilongao.github.io/wiki/fra-spring-cloud-config/</id>
    <published>2019-09-12T03:55:17.000Z</published>
    <updated>2019-09-15T07:48:44.405Z</updated>
    
    <content type="html"><![CDATA[<h6 id="分布式配置"><a href="#分布式配置" class="headerlink" title="分布式配置"></a><code>分布式配置</code></h6><hr><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">相关产品</span><br><span class="line">国内：Disconf(百度)Apollo(携程)Nacos(阿里)</span><br><span class="line">国外: Spring-Cloud-Config  Netfix Archaius</span><br></pre></td></tr></table></figure><hr><h6 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a><code>客户端</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关于配置项的刷新-&gt;主动刷新(拉的模式)</span></span><br><span class="line"><span class="number">1</span>. 客户端可以通过接口 http:<span class="comment">//127.0.0.1:8082/actuator/refresh 来主动刷新配置(post方法) ，但是该接口的调用需要修改配置文件里面的值。</span></span><br><span class="line">management.endpoint.refresh.enabled=<span class="keyword">true</span></span><br><span class="line"><span class="number">2</span>. 当配置项发生变化时，bean里面引用的配置项并未发生变化。需要使用 <span class="meta">@RefreshScope</span> 注解来标记，只有使用该注解标记的类，当配置项发生变化时，引用的配置项才会发生变化。</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span><span class="comment">// (开关 阈值  文案等配置，其它配置可以重启服务器)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;my.name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String myName = <span class="string">"jack-1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/myName"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMyName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">3</span>. 可以配置定时器来每隔指定的时间去主动刷新配置</span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableScheduling</span> <span class="comment">// 开启定时任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigClientApp.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定时刷新配置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ContextRefresher contextRefresher;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Environment environment;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConfigClientApp</span><span class="params">(ContextRefresher contextRefresher, Environment environment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.contextRefresher = contextRefresher;</span><br><span class="line">        <span class="keyword">this</span>.environment = environment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置定时器每隔5秒刷新一次配置项</span></span><br><span class="line">    <span class="meta">@Scheduled</span>(fixedRate = <span class="number">5</span> * <span class="number">1000</span>, initialDelay = <span class="number">3</span> * <span class="number">1000</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">autoRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; updatedPropertyNames = contextRefresher.refresh();</span><br><span class="line">        updatedPropertyNames.forEach( propertyName -&gt;</span><br><span class="line">            System.err.printf(</span><br><span class="line">                    <span class="string">"[Thread :%s] 当前配置已更新，具体 Key：%s , Value : %s \n"</span>,</span><br><span class="line">                    Thread.currentThread().getName(),</span><br><span class="line">                    propertyName,</span><br><span class="line">                    environment.getProperty(propertyName)</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a><code>服务端</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="comment">// 激活配置管理服务器</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServerApp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigServerApp.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义配置实现,绕过git实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EnvironmentRepository <span class="title">environmentRepository</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (String application, String profile, String label) -&gt; &#123;</span><br><span class="line">            Environment environment = <span class="keyword">new</span> Environment(<span class="string">"default"</span>, profile);</span><br><span class="line">            List&lt;PropertySource&gt; propertySources = environment.getPropertySources();</span><br><span class="line">            Map&lt;String, Object&gt; source = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">            source.put(<span class="string">"name"</span>, <span class="string">"微服务-&gt;long"</span>);</span><br><span class="line">            PropertySource propertySource = <span class="keyword">new</span> PropertySource(<span class="string">"map"</span>, source);</span><br><span class="line">            propertySources.add(propertySource);</span><br><span class="line">            <span class="keyword">return</span> environment;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="客户端流程分析"><a href="#客户端流程分析" class="headerlink" title="客户端流程分析"></a><code>客户端流程分析</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 在客户端，我们可以配置形如: localhost:8080/&#123;name&#125;/&#123;profiles&#125;/&#123;label&#125; 去从服务端获取配置。</span></span><br><span class="line"><span class="comment">2. 在服务端是通过 EnvironmentController 类来对外提供服务的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(method = RequestMethod.GET, path = <span class="string">"$&#123;spring.cloud.config.server.prefix:&#125;"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnvironmentController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/&#123;name&#125;/&#123;profiles&#125;/&#123;label:.*&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Environment <span class="title">labelled</span><span class="params">(@PathVariable String name, @PathVariable String profiles,</span></span></span><br><span class="line"><span class="function"><span class="params">@PathVariable String label)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (name != <span class="keyword">null</span> &amp;&amp; name.contains(<span class="string">"(_)"</span>)) &#123;</span><br><span class="line"><span class="comment">// "(_)" is uncommon in a git repo name, but "/" cannot be matched</span></span><br><span class="line"><span class="comment">// by Spring MVC</span></span><br><span class="line">name = name.replace(<span class="string">"(_)"</span>, <span class="string">"/"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (label != <span class="keyword">null</span> &amp;&amp; label.contains(<span class="string">"(_)"</span>)) &#123;</span><br><span class="line"><span class="comment">// "(_)" is uncommon in a git branch name, but "/" cannot be matched</span></span><br><span class="line"><span class="comment">// by Spring MVC</span></span><br><span class="line">label = label.replace(<span class="string">"(_)"</span>, <span class="string">"/"</span>);</span><br><span class="line">&#125;</span><br><span class="line">Environment environment = <span class="keyword">this</span>.repository.findOne(name, profiles, label);</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.acceptEmpty</span><br><span class="line">&amp;&amp; (environment == <span class="keyword">null</span> || environment.getPropertySources().isEmpty())) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> EnvironmentNotFoundException(<span class="string">"Profile Not found"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> environment;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="服务端流程分析"><a href="#服务端流程分析" class="headerlink" title="服务端流程分析"></a><code>服务端流程分析</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 在 @EnableConfigServer 注解中使用了 @Import 注解导入了配置类 ConfigServerConfiguration。</span></span><br><span class="line"><span class="comment">2. 在配置类 ConfigServerConfiguration 上面使用 @Configuration 注解表明该类是一个配置类，该配置类</span></span><br><span class="line"><span class="comment">会在上下文中创建一个类型为 ConfigServerConfiguration.Marker 的bean。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(ConfigServerConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableConfigServer &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServerConfiguration</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Marker <span class="title">enableConfigServerMarker</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Marker();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Marker</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. ConfigServerAutoConfiguration 类上面使用了 @ConditionalOnBean 注解，只有当上下文中存在类型</span></span><br><span class="line"><span class="comment">为 ConfigServerConfiguration.Marker 的bean时，才会执行该配置类的流程（条件装配）。</span></span><br><span class="line"><span class="comment">2. 在该类中导入了一些配置类，EnvironmentRepositoryConfiguration 等这些类会根据条件判断创建相关的</span></span><br><span class="line"><span class="comment">bean。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 配置类</span></span><br><span class="line"><span class="meta">@ConditionalOnBean</span>(ConfigServerConfiguration.Marker.class) <span class="comment">// 条件装配</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(ConfigServerProperties.class)</span><br><span class="line"><span class="meta">@Import</span>(&#123; EnvironmentRepositoryConfiguration.class, CompositeConfiguration.class,</span><br><span class="line">ResourceRepositoryConfiguration.class, ConfigServerEncryptionConfiguration.class,</span><br><span class="line">ConfigServerMvcConfiguration.class &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServerAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. EnvironmentRepositoryConfiguration 通过 @Import 注解导入了一些相关的配置类。</span></span><br><span class="line"><span class="comment">JdbcRepositoryConfiguration GitRepositoryConfiguration 分别时基于jdbc和git实现配置</span></span><br><span class="line"><span class="comment">的仓储。</span></span><br><span class="line"><span class="comment">2. GitRepositoryConfiguration 继承啦 DefaultRepositoryConfiguration 类，属于默认实现。</span></span><br><span class="line"><span class="comment">3. 在 DefaultRepositoryConfiguration 类中 通过 @ConditionalOnMissingBean 注解表明当前</span></span><br><span class="line"><span class="comment">上下文中若是没有 EnvironmentRepository 类型的bean存在时，会创建一个类型为 </span></span><br><span class="line"><span class="comment">MultipleJGitEnvironmentRepository 的bean</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// EnvironmentRepositoryConfiguration 配置</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(&#123; SvnKitEnvironmentProperties.class,</span><br><span class="line">CredhubEnvironmentProperties.class, JdbcEnvironmentProperties.class,</span><br><span class="line">NativeEnvironmentProperties.class, VaultEnvironmentProperties.class &#125;)</span><br><span class="line"><span class="meta">@Import</span>(&#123; CompositeRepositoryConfiguration.class, JdbcRepositoryConfiguration.class,</span><br><span class="line">VaultConfiguration.class, VaultRepositoryConfiguration.class,</span><br><span class="line">CredhubConfiguration.class, CredhubRepositoryConfiguration.class,</span><br><span class="line">SvnRepositoryConfiguration.class, NativeRepositoryConfiguration.class,</span><br><span class="line">GitRepositoryConfiguration.class, DefaultRepositoryConfiguration.class &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnvironmentRepositoryConfiguration</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GitRepositoryConfiguration git实现的配置，继承了 DefaultRepositoryConfiguration 默认实现</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Profile</span>(<span class="string">"git"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GitRepositoryConfiguration</span> <span class="keyword">extends</span> <span class="title">DefaultRepositoryConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// JdbcRepositoryConfiguration jdbc实现的配置</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Profile</span>(<span class="string">"jdbc"</span>)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(JdbcTemplate.class)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JdbcRepositoryConfiguration</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnBean</span>(JdbcTemplate.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> JdbcEnvironmentRepository <span class="title">jdbcEnvironmentRepository</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">JdbcEnvironmentRepositoryFactory factory,</span></span></span><br><span class="line"><span class="function"><span class="params">JdbcEnvironmentProperties environmentProperties)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> factory.build(environmentProperties);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(value = EnvironmentRepository.class, search = SearchStrategy.CURRENT)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultRepositoryConfiguration</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MultipleJGitEnvironmentRepository <span class="title">defaultEnvironmentRepository</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">MultipleJGitEnvironmentRepositoryFactory gitEnvironmentRepositoryFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">MultipleJGitEnvironmentProperties environmentProperties)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">return</span> gitEnvironmentRepositoryFactory.build(environmentProperties);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">到此，还有一个问题，那就是 ConfigServerAutoConfiguration 时如何加载的，通过相关jar包里面的</span></span><br><span class="line"><span class="comment">spring.factories 文件可以看到 ConfigServerAutoConfiguration 被 EnableAutoConfiguration</span></span><br><span class="line"><span class="comment">通过spring的spi加载。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"># Autoconfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.cloud.config.server.config.ConfigServerAutoConfiguration,\</span><br><span class="line">org.springframework.cloud.config.server.config.EncryptionAutoConfiguration</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;分布式配置&quot;&gt;&lt;a href=&quot;#分布式配置&quot; class=&quot;headerlink&quot; title=&quot;分布式配置&quot;&gt;&lt;/a&gt;&lt;code&gt;分布式配置&lt;/code&gt;&lt;/h6&gt;&lt;hr&gt;
&lt;figure class=&quot;highlight tex&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="框架" scheme="https://zhilongao.github.io/categories/java/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="spring-cloud" scheme="https://zhilongao.github.io/categories/java/%E6%A1%86%E6%9E%B6/spring-cloud/"/>
    
    
  </entry>
  
  <entry>
    <title>questions</title>
    <link href="https://zhilongao.github.io/wiki/questions/"/>
    <id>https://zhilongao.github.io/wiki/questions/</id>
    <published>2019-09-12T02:40:03.000Z</published>
    <updated>2019-09-12T02:46:20.517Z</updated>
    
    <content type="html"><![CDATA[<ol><li>说说dubbo服务上下线时你们是如何处理的?</li><li>dubbo的协议有哪些,哪些使用场景?</li><li>dubbo使用的系列化框架是什么?</li><li>dubbo服务容错机制?</li><li>socket协议的几种状态,socket协议的三次握手,为什么是三次握手?</li><li>说说nio和io有什么不同,nio有哪些场景?</li><li>http请求有哪些方法?</li><li>jdk1.8有哪些新特性,使用过哪些?</li><li>谈谈对GC的理解，对G1有了解吗?</li><li>Collection.sort底层默认使用哪种排序算法，说说你熟悉的排序算法有哪些?</li><li>基本数据类型,占用字节,包装类,为什么会有包装类?</li><li>多线程你们在项目中怎么用的?</li><li>jdk1.8中Stream在并行处理时，适合哪些情景，不适合哪些情景?(第一次遇到这样问的,没回答上来)<br>适合计算密集型,不适合IO密集型。因为Stream被分配到的是核心线程池，IO密集型会造成线程阻塞。</li><li>你们reids在使用中，过期时间是怎么设置的，分两步设置不能保证原子性，怎么解决的?</li><li>写一下二分查找算法？</li><li>写一个单例?(DCL)？</li><li>说说dubbo和spring cloud有什么区别?</li><li>你们数据库是怎么优化的,说说实例?</li><li>了解redis吗，说说redis基本数据结构，有哪些常用的指令？</li></ol><hr><p>1、说说 dubbo 的执行流程<br>2、redis 基本数据结构，你们是怎么用的（讲了下 5 分钟发帖 10 次）<br>3、数据库连接池了解吗？<br>4、生产环境项目打印日志出现了时间长的现象，你怎么排查<br>5、接口出现频繁 GC ，怎么排查</p><hr><p>1 线程池用过哪些，在项目中是怎么使用的</p><p>2 sql优化怎么做的，哪些情况触发不了索引 , sql优化除了索引还要看哪些指标</p><p>3 redis有没有遇到数据库满了的情况</p><p>4  说说redis cluster</p><p>5 springmvc  springboot springcloud的区别</p><p>6 对restful有了解吗，弹弹restful</p><p>7 说说对spring的理解</p><p>8 @Autowired和@Resource的区别</p><p>9 设计模式有哪些了解，说说设计模式遵循的原则</p><p>10 交给你一个项目，怎么推进</p><p>11 通过哪些途径学习，看些什么书</p><p>12 总结下自己</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;说说dubbo服务上下线时你们是如何处理的?&lt;/li&gt;
&lt;li&gt;dubbo的协议有哪些,哪些使用场景?&lt;/li&gt;
&lt;li&gt;dubbo使用的系列化框架是什么?&lt;/li&gt;
&lt;li&gt;dubbo服务容错机制?&lt;/li&gt;
&lt;li&gt;socket协议的几种状态,socket协
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="面试题" scheme="https://zhilongao.github.io/categories/java/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>linux系统</title>
    <link href="https://zhilongao.github.io/wiki/linux-system-problem/"/>
    <id>https://zhilongao.github.io/wiki/linux-system-problem/</id>
    <published>2019-09-09T12:19:57.000Z</published>
    <updated>2019-09-10T06:35:55.531Z</updated>
    
    <content type="html"><![CDATA[<h6 id="linux三种网络模式"><a href="#linux三种网络模式" class="headerlink" title="linux三种网络模式"></a><code>linux三种网络模式</code></h6><p>在我们安装vmware的时候，vmware会为三种网络模式各自创建一个虚拟机网络, 其中 VMnet0(表示桥接模式) VMnet8(NAT模式) VMnet1(仅主机模式) </p><hr><p>桥接模式<br>    和主机一样，也会占用一个局域网中的ip。信息的发送和接受，虚拟网络适配器和主机的物理网络适配器进行交换，虚拟网络适配器可以通过主机的物理网络适配器访问外部网络。在局域网中的其它主机能够识别到发送信息的ip为该虚拟机的ip。 </p><p>NAT模式<br>    虚拟机发送数据时，NAT虚拟机网络适配器会以主机的名义将数据包裹发送出去，接收时通过特殊的标识识别。在外部网络中并不知道当前虚拟机的存在。</p><p>主机模式<br>    仅可以和主机通信，无法访问外部网络。</p><hr><p>​    <a href="https://www.cnblogs.com/xuan52rock/p/5295069.html" target="_blank" rel="noopener">一篇介绍的很形象的文章</a></p><hr><h6 id="centos7之动态ip与静态ip"><a href="#centos7之动态ip与静态ip" class="headerlink" title="centos7之动态ip与静态ip"></a><code>centos7之动态ip与静态ip</code></h6><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">centos7获取ip地址的方法主要有两种 1:动态获取  2:设置静态ip</span><br><span class="line"></span><br><span class="line">我们一般通过VMWare安装完centos7后，可以使用命令ip addr查看虚拟机的ip地址。但是刚安装完的centos7有些没有设置ip地址，我们可以通过下面两种方式来设置ip地址。</span><br><span class="line"></span><br><span class="line">1. 动态获取ip(前提是路由器已经开启了DHCP(动态主机设置协议))</span><br><span class="line">  a: 需要修改网卡的配置文件 /etc/sysconfig/network-scripts/ifcfg-ens33 其中ifcfg-ens33为网卡名。修改该文件的两处地方既可。</span><br><span class="line">   (1) bootproto=dhcp</span><br><span class="line">   (2) onboot=yes</span><br><span class="line">  b: 重启下网络服务</span><br><span class="line">   [root@mini ~]# systemctl restart network</span><br><span class="line">  c: 通过 ip addr 命令可以看到ens33的网卡已经有相应的ip地址啦</span><br><span class="line">  d: 通过 ping www.baidu.com 查看网络是否通畅</span><br><span class="line">  </span><br><span class="line">在VMware里，点击'编辑'-'虚拟网络编辑器'  </span><br><span class="line">2. 配置静态ip地址(网络模式在nat模式下)</span><br><span class="line">  a: 也是需要修改网卡配置文件 /etc/sysconfig/network-srcipts/ifcfg-ens33 其中ifcfg-ens33为网卡名。修改该文件的两处地方既可。</span><br><span class="line">   (1) bootproto=static</span><br><span class="line">   (2) onboot=yes </span><br><span class="line">  b: 还需要在该网卡配置文件的后面加上几行，分别是ip地址，子网掩码，网关，dns服务器</span><br><span class="line">    IPADDR=192.168.25.156 #静态ip</span><br><span class="line">    NETMASK=255.255.255.0 #子网掩码</span><br><span class="line">    GATEWAY=192.168.1.1 #网关</span><br><span class="line">    DNS1=192.168.25.2</span><br><span class="line">    DNS2=8.8.8.8 #谷歌的dns服务器</span><br><span class="line">  c: 重启下网络服务</span><br><span class="line">  [root@mini ~]# systemctl restart network</span><br><span class="line">  d: 通过 ip addr 命令可以看到ens33的网卡已经有新的ip地址啦</span><br><span class="line">  e: 通过 ping www.baidu.com 查看网络是否通畅</span><br><span class="line"></span><br><span class="line">3. 在 /etc/resolv.conf文件里面保存了dns地址，可以通过cat命令查看</span><br></pre></td></tr></table></figure><p><code>在设置静态ip时,子网掩码和网关地址可以在vmware的-&gt;编辑-&gt;虚拟网络编辑器-&gt;NAT设置 中查看，如下图所示</code></p><p><img src="https://raw.githubusercontent.com/zhilongao/images-repository/master/46f916fdc305a268fe584b8ba809ed3.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;linux三种网络模式&quot;&gt;&lt;a href=&quot;#linux三种网络模式&quot; class=&quot;headerlink&quot; title=&quot;linux三种网络模式&quot;&gt;&lt;/a&gt;&lt;code&gt;linux三种网络模式&lt;/code&gt;&lt;/h6&gt;&lt;p&gt;在我们安装vmware的时候，vmware
      
    
    </summary>
    
      <category term="系统" scheme="https://zhilongao.github.io/categories/%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="linux" scheme="https://zhilongao.github.io/categories/%E7%B3%BB%E7%BB%9F/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>字符串</title>
    <link href="https://zhilongao.github.io/wiki/alg-string-simple1/"/>
    <id>https://zhilongao.github.io/wiki/alg-string-simple1/</id>
    <published>2019-09-06T02:25:40.000Z</published>
    <updated>2019-09-29T08:26:16.315Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problemset/algorithms/" target="_blank" rel="noopener">题目来自leetcode</a></p><h6 id="字符串反转1-344"><a href="#字符串反转1-344" class="headerlink" title="字符串反转1(344)"></a><code>字符串反转1(344)</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目要求：编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组char[]的形式给出。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = s.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">char</span> temp = s[low];</span><br><span class="line">        s[low++] = s[high];</span><br><span class="line">        s[high--] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="字符串反转2-541"><a href="#字符串反转2-541" class="headerlink" title="字符串反转2(541)"></a><code>字符串反转2(541)</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目要求:给定一个字符串和一个整数 k，你需要对从字符串开头算起的每个 2k 个字符的前k个字符进行反转。如果剩余少于 k 个字符，则将剩余的所有全部反转。如果有小于 2k 但大于或等于 k 个字符，则反转前 k 个字符，并将剩余的字符保持原样。</span></span><br><span class="line"><span class="comment">示例：输入: s = "abcdefg", k = 2 输出: "bacdfeg"</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseStr</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算长度 整数遍历次数 剩余元素个数</span></span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">int</span> lastNum = len % (<span class="number">2</span> * k);</span><br><span class="line">    <span class="keyword">int</span> num = len / (<span class="number">2</span> * k);</span><br><span class="line">    <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">    <span class="comment">// 先将前2*k*num个元素做反转</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">2</span> * num; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> low = (i - <span class="number">1</span>) * k;</span><br><span class="line">        <span class="keyword">int</span> high = i * k - <span class="number">1</span>;</span><br><span class="line">        reverseChar(chars, low, high);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将剩余的不到2*k个元素反转</span></span><br><span class="line">    <span class="keyword">if</span> (lastNum &gt; k) &#123;</span><br><span class="line">        reverseChar(chars, <span class="number">2</span>*k*num, <span class="number">2</span>*k*num+k-<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reverseChar(chars, <span class="number">2</span>*k*num, len-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符数组反转函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseChar</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">char</span> temp = chars[low];</span><br><span class="line">        chars[low ++] = chars[high];</span><br><span class="line">        chars[high --] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="字符串反转3-557"><a href="#字符串反转3-557" class="headerlink" title="字符串反转3(557)"></a><code>字符串反转3(557)</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目要求: 给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</span></span><br><span class="line"><span class="comment">注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。</span></span><br><span class="line"><span class="comment">示例 1:</span></span><br><span class="line"><span class="comment">输入: "Let's take LeetCode contest"</span></span><br><span class="line"><span class="comment">输出: "s'teL ekat edoCteeL tsetnoc" </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 解法：将字符串按照空格拆分成为字符串数组，然后将每一个字符串翻转，最后将反转的字符串拼接到一起。</span></span><br><span class="line"><span class="comment">// 其中字符串的反转采用的方式为先转换为字符数组，然后反转字符数组。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    String[] split = s.split(<span class="string">"\\s+"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; split.length ; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars = split[i].toCharArray();</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> hig = chars.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; hig) &#123;</span><br><span class="line">            <span class="keyword">char</span> temp = chars[low];</span><br><span class="line">            chars[low ++] = chars[hig];</span><br><span class="line">            chars[hig --] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(chars);</span><br><span class="line">        <span class="keyword">if</span> (i != split.length - <span class="number">1</span>) &#123;</span><br><span class="line">            sb.append(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="字符串反转4-917"><a href="#字符串反转4-917" class="headerlink" title="字符串反转4(917)"></a><code>字符串反转4(917)</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目要求:给定一个字符串 S，返回 “反转后的” 字符串，其中不是字母的字符都保留在原地，而所有字母的位置发生反转。</span></span><br><span class="line"><span class="comment">示例 1：输入："ab-cd"  输出："dc-ba"</span></span><br><span class="line"><span class="comment">示例 2：输入："a-bC-dEf-ghIj" 输出："j-Ih-gfE-dCba"</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseOnlyLetters</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 双指针</span></span><br><span class="line">    StringBuffer buf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">int</span> j = S.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); i ++) &#123;</span><br><span class="line">        <span class="comment">// 位置i上的字符为字母时，可以做交换</span></span><br><span class="line">        <span class="keyword">if</span> (Character.isLetter(S.charAt(i))) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!Character.isLetter(S.charAt(j))) &#123;</span><br><span class="line">                j --;</span><br><span class="line">            &#125;</span><br><span class="line">            buf.append(S.charAt(j --));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            buf.append(S.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buf.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="字符串反转5-345"><a href="#字符串反转5-345" class="headerlink" title="字符串反转5(345)"></a><code>字符串反转5(345)</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目要求:编写一个函数，以字符串作为输入，反转该字符串中的元音字母。</span></span><br><span class="line"><span class="comment">示例 1: 输入: "hello" 输出: "holle"</span></span><br><span class="line"><span class="comment">示例 2: 输入: "leetcode" 输出: "leotcede"</span></span><br><span class="line"><span class="comment">说明: 元音字母不包含字母"y"。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 元音字母集合</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> Set&lt;Character&gt; sets = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="string">'a'</span>, <span class="string">'e'</span>, <span class="string">'i'</span>, <span class="string">'o'</span>, <span class="string">'u'</span>, <span class="string">'A'</span>, <span class="string">'E'</span>, <span class="string">'I'</span>, <span class="string">'O'</span>, <span class="string">'U'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用双指针,当两端同时为元音字母时,交换两个位置的字符。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseVowels</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = s.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!judgeVowel(chars[left])) &#123;</span><br><span class="line">            left ++;</span><br><span class="line">            <span class="keyword">if</span> (left &gt; s.length() -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!judgeVowel(chars[right])) &#123;</span><br><span class="line">            right --;</span><br><span class="line">            <span class="keyword">if</span> (right &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> temp = chars[left];</span><br><span class="line">        chars[left++] = chars[right];</span><br><span class="line">        chars[right--] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="报数问题-38"><a href="#报数问题-38" class="headerlink" title="报数问题(38)"></a><code>报数问题(38)</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目要求：</span></span><br><span class="line"><span class="comment">报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：</span></span><br><span class="line"><span class="comment">1.     1</span></span><br><span class="line"><span class="comment">2.     11</span></span><br><span class="line"><span class="comment">3.     21</span></span><br><span class="line"><span class="comment">4.     1211</span></span><br><span class="line"><span class="comment">5.     111221</span></span><br><span class="line"><span class="comment">说明：上一项报前一项，报数时是按照各数+数字报的。比如：给1报数的是2，报数时时1个1，即为11。给2报数的是3，报的数是11，2个1，即为21。报21时，1个2，1个1，即为1211</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 解法：就是按照规律统计前一项的数字，直到第n项统计出n-1为止。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    String res = <span class="string">"1"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        StringBuffer buf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">char</span> ch = res.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; res.length(); j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == res.charAt(j)) &#123;</span><br><span class="line">                num ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                buf.append(num).append(ch);</span><br><span class="line">                ch = res.charAt(j);</span><br><span class="line">                num = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        buf.append(num).append(ch);</span><br><span class="line">        res = buf.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="二进制求和-67"><a href="#二进制求和-67" class="headerlink" title="二进制求和(67)"></a><code>二进制求和(67)</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目要求：</span></span><br><span class="line"><span class="comment">    给定两个二进制字符串，返回他们的和（用二进制表示）。</span></span><br><span class="line"><span class="comment">    输入为非空字符串且只包含数字 1 和 0。</span></span><br><span class="line"><span class="comment">示例:</span></span><br><span class="line"><span class="comment">   输入: a = "11", b = "1"    输出: "100"</span></span><br><span class="line"><span class="comment">   输入: a = "1010", b = "1011"    输出: "10101"</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 从后往前遍历计算，将计算结果拼接到字符串后面，最后将字符串反转</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addBinaryA</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">    StringBuffer buf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.length() - <span class="number">1</span>, j  = b.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = ans;</span><br><span class="line">        <span class="comment">// 两个字符串长度可能不同，故先遍历完毕的字符串计算值用0代替</span></span><br><span class="line">        sum += (i &gt;= <span class="number">0</span> ? a.charAt(i) - <span class="string">'0'</span> : <span class="number">0</span>);</span><br><span class="line">        sum += (j &gt;= <span class="number">0</span> ? b.charAt(j) - <span class="string">'0'</span> : <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 拼接</span></span><br><span class="line">        buf.append(sum % <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 进位</span></span><br><span class="line">        ans = sum / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buf.append(ans == <span class="number">1</span> ? ans : <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> buf.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="验证回文串-125"><a href="#验证回文串-125" class="headerlink" title="验证回文串(125)"></a><code>验证回文串(125)</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目要求： 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</span></span><br><span class="line"><span class="comment">说明：本题中，我们将空字符串定义为有效的回文串。</span></span><br><span class="line"><span class="comment">示例：</span></span><br><span class="line"><span class="comment">  输入: "A man, a plan, a canal: Panama"    输出: true</span></span><br><span class="line"><span class="comment">  输入: "race a car"    输出: false</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindromeA</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.trim().length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将字符串转小写</span></span><br><span class="line">    String param = s.toLowerCase();</span><br><span class="line">    <span class="keyword">int</span> length = param.length();</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 左右两个指针遍历，相遇结束</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 从左起，定位到第一个字母或是数字</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; !isSuitable(param.charAt(left))) &#123;</span><br><span class="line">            left ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从右起，定位到第一个字母或是数字</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; !isSuitable(param.charAt(right))) &#123;</span><br><span class="line">            right --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不符合条件，返回false</span></span><br><span class="line">        <span class="keyword">if</span> (param.charAt(left ++) != param.charAt(right --)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判定给定的字符是否为字母或数字</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSuitable</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Character.isLetter(c) || Character.isDigit(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="有效括号-20"><a href="#有效括号-20" class="headerlink" title="有效括号(20)"></a><code>有效括号(20)</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目要求：</span></span><br><span class="line"><span class="comment">给定一个只包括 '('，')'，'&#123;'，'&#125;'，'['，']' 的字符串，判断字符串是否有效。</span></span><br><span class="line"><span class="comment">有效字符串需满足：</span></span><br><span class="line"><span class="comment">  左括号必须用相同类型的右括号闭合。</span></span><br><span class="line"><span class="comment">  左括号必须以正确的顺序闭合。</span></span><br><span class="line"><span class="comment">  注意空字符串可被认为是有效字符串。</span></span><br><span class="line"><span class="comment">示例:  输入: "()"  输出: true</span></span><br><span class="line"><span class="comment">      输入: "()[]&#123;&#125;" 输出: true</span></span><br><span class="line"><span class="comment">      输入: "(]"   输出: false</span></span><br><span class="line"><span class="comment">      输入: "([)]"  输出: false</span></span><br><span class="line"><span class="comment">      输入: "&#123;[]&#125;"  输出: true </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 解法：使用栈来操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 规律：对应的括号只有可能在紧邻的一位或者对称的位置找到</span></span><br><span class="line">    <span class="comment">// 空字符串直接返回 true</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.trim().length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> length = s.length();</span><br><span class="line">    <span class="comment">// 非2的偶数倍，直接返回false</span></span><br><span class="line">    <span class="keyword">if</span> (length % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过定义stack来实现，遇到左括号放入到stack中，遇到右括号从stack中弹出元素与之对比</span></span><br><span class="line">    <span class="comment">// 这种的扩展性较好，但是要引入HashMap,并且要匹配key,所以时间复杂度和空间复杂度都没下面的好</span></span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;Character&gt;();</span><br><span class="line">    Map&lt;Character, Character&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Character&gt;();</span><br><span class="line">    map.put(<span class="string">'('</span>, <span class="string">')'</span>);</span><br><span class="line">    map.put(<span class="string">'&#123;'</span>, <span class="string">'&#125;'</span>);</span><br><span class="line">    map.put(<span class="string">'['</span>, <span class="string">']'</span>);</span><br><span class="line">    Set&lt;Character&gt; keys = map.keySet();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length; j ++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(j);</span><br><span class="line">        <span class="keyword">if</span> (keys.contains(c)) &#123;</span><br><span class="line">            stack.push(c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty() ||  map.get(stack.pop()) != c) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下面这种时间复杂度和空间复杂度都要由于上面的，但是扩展性不好</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; length; i ++) &#123;</span></span><br><span class="line"><span class="comment">            char c = s.charAt(i);</span></span><br><span class="line"><span class="comment">            switch(c) &#123;</span></span><br><span class="line"><span class="comment">                case '(':</span></span><br><span class="line"><span class="comment">                case '&#123;':</span></span><br><span class="line"><span class="comment">                case '[':</span></span><br><span class="line"><span class="comment">                    stack.push(c);</span></span><br><span class="line"><span class="comment">                    break;</span></span><br><span class="line"><span class="comment">                case ')':</span></span><br><span class="line"><span class="comment">                    if (stack.isEmpty() || stack.pop() != '(') &#123;</span></span><br><span class="line"><span class="comment">                        return false;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                    continue;</span></span><br><span class="line"><span class="comment">                case '&#125;':</span></span><br><span class="line"><span class="comment">                    if (stack.isEmpty() || stack.pop() != '&#123;') &#123;</span></span><br><span class="line"><span class="comment">                        return false;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                    continue;</span></span><br><span class="line"><span class="comment">                case ']':</span></span><br><span class="line"><span class="comment">                    if (stack.isEmpty() || stack.pop() != '[') &#123;</span></span><br><span class="line"><span class="comment">                        return false;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                    continue;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            &#125; </span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="无重复字符的最长子串-3"><a href="#无重复字符的最长子串-3" class="headerlink" title="无重复字符的最长子串(3)"></a><code>无重复字符的最长子串(3)</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 滑动窗口解法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = s.length();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">    Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">    <span class="keyword">while</span>(left &lt; length &amp;&amp; right &lt; length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!set.contains(s.charAt(right))) &#123;</span><br><span class="line">            set.add(s.charAt(right ++));</span><br><span class="line">            ans = Math.max(ans, right - left);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            set.remove(s.charAt(left ++));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="最长回文子串-5"><a href="#最长回文子串-5" class="headerlink" title="最长回文子串(5)"></a><code>最长回文子串(5)</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 题目要求:给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</span></span><br><span class="line"><span class="comment">// 1.要判断一个字符串是否为回文字符串，可以通过下面几种方式来实现</span></span><br><span class="line"><span class="comment">// 第一种:通过栈的后进先出原理，将字符串翻转来对比前后两个字符串是否一致</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isHuiWen1</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        stack.push(str.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuffer buf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        buf.append(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (str.equals(buf.toString())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二种: 取消栈的引入，直接通过逆序输出拼接字符串(减少了额外的空间Stack)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isHuiWen2</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    StringBuffer buf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = str.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">        buf.append(str.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (buf.toString().equals(str)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第三中: 基于回文串左右两边两个字符相等的规律，定义两个变量做对比(优势是减少了字符串str的遍历次数，时间复杂度降低)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isHuiWen3</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = str.length();</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(str.charAt(left) == str.charAt(right))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        left ++;</span><br><span class="line">        right --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前这道题如何实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 给定一个字符串s,找到s中最长的回文子串。你可以假设s的最大长度为1000。</span></span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> resultLen = <span class="number">1</span>;</span><br><span class="line">    String resultStr = s.substring(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">        <span class="comment">// 从中间向两边查找对称的回文串</span></span><br><span class="line">        String oddStr = spread(s, len, i, i);</span><br><span class="line">        String evenStr = spread(s, len, i, i+<span class="number">1</span>);</span><br><span class="line">        String myStr = oddStr.length() &gt;= evenStr.length() ? oddStr : evenStr;</span><br><span class="line">        <span class="keyword">if</span> (myStr.length() &gt; resultLen) &#123;</span><br><span class="line">            resultStr = myStr;</span><br><span class="line">            resultLen = resultStr.length();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultStr;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">spread</span><span class="params">(String s, <span class="keyword">int</span> len, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = left;</span><br><span class="line">    <span class="keyword">int</span> r = right;</span><br><span class="line">    <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; len &amp;&amp; (s.charAt(l) == s.charAt(r))) &#123;</span><br><span class="line">        l --;</span><br><span class="line">        r ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(l+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="压缩字符串-443"><a href="#压缩字符串-443" class="headerlink" title="压缩字符串(443)"></a><code>压缩字符串(443)</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 题目要求: 给定一组字符串，使用原地算法将其压缩。</span></span><br><span class="line"><span class="comment">// 题目解法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compress</span><span class="params">(<span class="keyword">char</span>[] chars)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> anchor = <span class="number">0</span>; <span class="comment">// 描点，定位可以元素</span></span><br><span class="line">    <span class="keyword">int</span> write = <span class="number">0</span>; <span class="comment">// 写下标，定位写的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> read = <span class="number">0</span>; read &lt; chars.length; read ++) &#123;</span><br><span class="line">        <span class="comment">// 若是当前元素为最后一个元素或者是后一个元素与当前元素不相等，执行写入与统计写入操作</span></span><br><span class="line">        <span class="keyword">if</span> ((read == chars.length - <span class="number">1</span>) || (chars[read + <span class="number">1</span>] != chars[read])) &#123;</span><br><span class="line">            <span class="comment">// 将anchor位置处的元素写入到write位置处</span></span><br><span class="line">            chars[write ++] = chars[anchor];</span><br><span class="line">            <span class="comment">// 判断该元素是否需要压缩</span></span><br><span class="line">            <span class="keyword">if</span> (read &gt; anchor) &#123;</span><br><span class="line">                String numStr = read - anchor + <span class="number">1</span> + <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">char</span>[] numArr = numStr.toCharArray();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> num : numArr) &#123;</span><br><span class="line">                    chars[write ++] = num;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将锚点移动到下一个元素</span></span><br><span class="line">            anchor = read + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回覆盖的个数</span></span><br><span class="line">    <span class="keyword">return</span> write;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="字符串中的第一个唯一字符-387"><a href="#字符串中的第一个唯一字符-387" class="headerlink" title="字符串中的第一个唯一字符(387)"></a><code>字符串中的第一个唯一字符(387)</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目要求: 给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</span></span><br><span class="line"><span class="comment">说明: 你可以假设字符串只含有小写字母。</span></span><br><span class="line"><span class="comment">示例: s = "leetcode" 返回 0.s = "loveleetcode" 返回 2.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 第一中解法，遍历两次字符串，哈希表存储每个字符和其出现的个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstUniqCharA</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(s.charAt(i))) &#123;</span><br><span class="line">            map.put(s.charAt(i), <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(s.charAt(i), map.get(s.charAt(i)) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s.length(); j ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.get(s.charAt(j)) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种解法: 仅遍历26个字母，唯一的特征：第一个字符和最后一个字符的index相同</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstUniqCharB</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] originalChar = <span class="string">"abcdefghijklmnopqrstuvwxyz"</span>.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> index = s.length();</span><br><span class="line">    <span class="comment">// 此处循环26次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : originalChar) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = s.indexOf(c);</span><br><span class="line">        <span class="keyword">if</span> (left != -<span class="number">1</span> &amp;&amp; left == s.lastIndexOf(c)) &#123;</span><br><span class="line">            index = Math.min(index, left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(index != s.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="赎金信-383"><a href="#赎金信-383" class="headerlink" title="赎金信(383)"></a><code>赎金信(383)</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目要求: 给出两个字符串，用第二个字符串中的字符拼接成为第一个字符串，每个字符只能使用一次。可以返回true，否则返回false。</span></span><br><span class="line"><span class="comment">说明: 你可以假设两个字符串均只含有小写字母。</span></span><br><span class="line"><span class="comment">实例：</span></span><br><span class="line"><span class="comment">canConstruct("a", "b") -&gt; false  </span></span><br><span class="line"><span class="comment">canConstruct("aa", "ab") -&gt; false</span></span><br><span class="line"><span class="comment">canConstruct("aa", "aab") -&gt; true</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一个字符串里面的字符能不能由第二个字符串里面的字符构成，若可以，返回true。否则返回false。</span></span><br><span class="line">    <span class="comment">// 将26 个字母个数映射到一个26大小的数组上</span></span><br><span class="line">    <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; magazine.length(); i ++) &#123;</span><br><span class="line">        bucket[magazine.charAt(i) - <span class="string">'a'</span>] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ransomNote.length(); j ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (-- bucket[ransomNote.charAt(j) - <span class="string">'a'</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problemset/algorithms/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目来自leetcode&lt;/a&gt;&lt;/p&gt;
&lt;h6 id=&quot;字符串反转1-344&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="算法" scheme="https://zhilongao.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串" scheme="https://zhilongao.github.io/categories/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
  </entry>
  
  <entry>
    <title>array-ask</title>
    <link href="https://zhilongao.github.io/wiki/alg-array-simple1/"/>
    <id>https://zhilongao.github.io/wiki/alg-array-simple1/</id>
    <published>2019-09-05T01:52:30.000Z</published>
    <updated>2019-09-25T11:41:41.275Z</updated>
    
    <content type="html"><![CDATA[<h6 id="寻找递增序列"><a href="#寻找递增序列" class="headerlink" title="寻找递增序列"></a><code>寻找递增序列</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给定一个未经过排序的数组，找到最长且连续的递增序列(在美团面试题中出现过-leetcode674题)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> curr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            curr ++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            max = Math.max(max, curr);</span><br><span class="line">        curr = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(max, curr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;寻找递增序列&quot;&gt;&lt;a href=&quot;#寻找递增序列&quot; class=&quot;headerlink&quot; title=&quot;寻找递增序列&quot;&gt;&lt;/a&gt;&lt;code&gt;寻找递增序列&lt;/code&gt;&lt;/h6&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t
      
    
    </summary>
    
      <category term="算法" scheme="https://zhilongao.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数组" scheme="https://zhilongao.github.io/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/"/>
    
    
  </entry>
  
  <entry>
    <title>mongodb-base</title>
    <link href="https://zhilongao.github.io/wiki/mongodb-base/"/>
    <id>https://zhilongao.github.io/wiki/mongodb-base/</id>
    <published>2019-09-03T03:45:03.000Z</published>
    <updated>2019-09-24T11:49:12.228Z</updated>
    
    <content type="html"><![CDATA[<h6 id="安装步骤-centos7"><a href="#安装步骤-centos7" class="headerlink" title="安装步骤(centos7)"></a><code>安装步骤(centos7)</code></h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1.下载安装包</span><br><span class="line">wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel62-3.2.10.tgz</span><br><span class="line">2.解压安装包</span><br><span class="line">tar -zxvf mongodb-linux-x86_64-rhel62-3.2.10.tgz </span><br><span class="line">3.将解压目录移动到(/usr/local/mongodb)</span><br><span class="line">mv mongodb-linux-x86_64-rhel62-3.2.10 /usr/local/mongodb</span><br><span class="line">4.在/usr/local/mongodb目录下创建/data/db目录和/logs目录</span><br><span class="line">mkdir -p /usr/local/mongodb/data/db </span><br><span class="line">mkdir -p /usr/local/mongodb/logs</span><br><span class="line">5.在/usr/local/mongodb/logs目录下创建mongodb.log文件</span><br><span class="line">touch mongodb.log</span><br><span class="line">6.在/usr/local/mongodb/bin目录下创建mongodb的配置文件</span><br><span class="line">touch mongodb.conf</span><br><span class="line">7.编辑mongodb.conf文件</span><br><span class="line">vi mongodb.conf</span><br><span class="line">编辑内容</span><br><span class="line">dbpath = /usr/local/mongodb/data/db #数据文件存放目录</span><br><span class="line">logpath = /usr/local/mongodb/logs/mongodb.log #日志文件存放目录</span><br><span class="line">port = 27017  #端口</span><br><span class="line">fork = true  #以守护程序的方式启用，即在后台运行</span><br><span class="line">nohttpinterface = true</span><br><span class="line">auth=true</span><br><span class="line">bind_ip=0.0.0.0</span><br><span class="line">8.修改环境变量</span><br><span class="line">vi /etc/profile</span><br><span class="line">添加的内容</span><br><span class="line">export MONGODB_HOME=/usr/local/mongodb</span><br><span class="line">export PATH=$PATH:$MONGODB_HOME/bin</span><br><span class="line">9.编辑完成之后重启系统配置</span><br><span class="line">source /etc/profile</span><br><span class="line">10.在/usr/local/mongodb/bin目录下启动mongodb</span><br><span class="line">./mongod -f mongodb.conf</span><br><span class="line">11.关闭mongodb服务</span><br><span class="line">./mongod -f ./mongodb.conf --shutdown</span><br><span class="line">12.开启27017端口</span><br><span class="line"></span><br><span class="line">13.使用shell登录到mongodb</span><br><span class="line">./mongodb</span><br><span class="line"></span><br><span class="line">14.登录到相关数据库</span><br><span class="line">use test</span><br><span class="line"></span><br><span class="line">15.创建用户</span><br><span class="line">db.createUser(</span><br><span class="line">&#123;</span><br><span class="line">user: "test", </span><br><span class="line">pwd: "test", </span><br><span class="line">roles: [&#123; role: "readWrite", db: "test" &#125;]</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line">16.修改配置，开启验证</span><br><span class="line">auth=true</span><br><span class="line">17.重启服务</span><br><span class="line">停止服务，然后启动</span><br><span class="line">18.登录</span><br><span class="line">./mongodb</span><br><span class="line">19.验证</span><br><span class="line">auth('test', 'test')(返回1代表成功)</span><br><span class="line">20.操作</span><br><span class="line">db.user.find()</span><br><span class="line">db.user.insert(&#123;"name":'jack',"age": 12&#125;)</span><br></pre></td></tr></table></figure><h6 id="基本操作-gt-java-api的crud"><a href="#基本操作-gt-java-api的crud" class="headerlink" title="基本操作-&gt;java api的crud"></a><code>基本操作-&gt;java api的crud</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 引入依赖</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.mongodb&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mongo-java-driver&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.9.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.java代码</span><br><span class="line"><span class="comment">// 工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MongoUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String baseUrl = <span class="string">"192.168.25.147:27017"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String userName = <span class="string">"test"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String passWord = <span class="string">"test"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String url = <span class="string">"mongodb://"</span>+ userName +<span class="string">":"</span>+ passWord + <span class="string">"@"</span>+ baseUrl + <span class="string">"/"</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 获取MongoDatabase</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MongoDatabase <span class="title">getConnection</span><span class="params">(String dataName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取MongoClient</span></span><br><span class="line">        com.mongodb.client.MongoClient mongoClient = MongoClients.create(url + dataName);</span><br><span class="line">        <span class="comment">// 获取MongoDatabase</span></span><br><span class="line">        MongoDatabase db = mongoClient.getDatabase(dataName);</span><br><span class="line">        <span class="keyword">return</span> db;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本操作 -&gt; 获取所有</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findAll</span><span class="params">(String databaseName, String collectionName)</span> </span>&#123;</span><br><span class="line">MongoDatabase database = MongoUtil.getConnection(databaseName);</span><br><span class="line">    MongoCollection&lt;Document&gt; collection = database.getCollection(collectionName);</span><br><span class="line">    FindIterable&lt;Document&gt; documents = collection.find();</span><br><span class="line">    print(documents);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本操作 -&gt; 插入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String databaseName, String collectionName)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取database</span></span><br><span class="line">MongoDatabase database = MongoUtil.getConnection(databaseName);</span><br><span class="line"><span class="comment">// 获取Clooection</span></span><br><span class="line">MongoCollection&lt;Document&gt; collection = database.getCollection(collectionName);</span><br><span class="line"><span class="comment">// 创建Document</span></span><br><span class="line">Document document = <span class="keyword">new</span> Document()</span><br><span class="line">                    .append(<span class="string">"name"</span>, <span class="string">"mick11"</span>)</span><br><span class="line">                    .append(<span class="string">"age"</span>, <span class="string">"33"</span>)</span><br><span class="line">                    .append(<span class="string">"address"</span>, <span class="string">"长沙"</span>)</span><br><span class="line">                    .append(<span class="string">"sex"</span>, <span class="string">"男"</span>);</span><br><span class="line">    <span class="comment">// 插入document                </span></span><br><span class="line">collection.insertOne(document);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印所有</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(FindIterable&lt;Document&gt; documents)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (Document document : documents) &#123;</span><br><span class="line">System.out.println(document.toJson());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;安装步骤-centos7&quot;&gt;&lt;a href=&quot;#安装步骤-centos7&quot; class=&quot;headerlink&quot; title=&quot;安装步骤(centos7)&quot;&gt;&lt;/a&gt;&lt;code&gt;安装步骤(centos7)&lt;/code&gt;&lt;/h6&gt;&lt;figure class=&quot;hig
      
    
    </summary>
    
      <category term="数据库" scheme="https://zhilongao.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mongodb" scheme="https://zhilongao.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb/"/>
    
    
      <category term="mongo" scheme="https://zhilongao.github.io/tags/mongo/"/>
    
  </entry>
  
  <entry>
    <title>实际应用</title>
    <link href="https://zhilongao.github.io/wiki/redis-advance/"/>
    <id>https://zhilongao.github.io/wiki/redis-advance/</id>
    <published>2019-09-02T00:47:25.000Z</published>
    <updated>2019-09-24T11:51:45.844Z</updated>
    
    <content type="html"><![CDATA[<h6 id="list实现分布式队列"><a href="#list实现分布式队列" class="headerlink" title="list实现分布式队列"></a><code>list实现分布式队列</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需要的依赖jedis fastjson</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.9.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line"> &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.2.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/8 15:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String url = <span class="string">"192.168.25.150"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> port = <span class="number">6379</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构建queue</span></span><br><span class="line">        String queueKey = <span class="string">"message_queue"</span>;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(url, port);</span><br><span class="line">        <span class="comment">// 消息转换器</span></span><br><span class="line">        MessageConvert&lt;TaskItem&gt; convert = <span class="keyword">new</span> MessageConvert&lt;&gt;();</span><br><span class="line">        <span class="comment">// 消息队列</span></span><br><span class="line">        RedisQueue queue = <span class="keyword">new</span> RedisQueue(jedis, queueKey, convert);</span><br><span class="line">        <span class="comment">// 生产者</span></span><br><span class="line">        MessageProducer producer = <span class="keyword">new</span> MessageProducer(queue);</span><br><span class="line">        <span class="comment">// 消费者</span></span><br><span class="line">        MessageConsumer consumer = <span class="keyword">new</span> MessageConsumer(queue);</span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息队列</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/8 14:34</span></span><br><span class="line"><span class="comment"> * 分布式消息队列-list实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line">    <span class="keyword">private</span> String queueKey;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisQueue</span><span class="params">(Jedis jedis, String queueKey, MessageConvert messageConvert)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jedis = jedis;</span><br><span class="line">        <span class="keyword">this</span>.queueKey = queueKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.jedis.lpush(queueKey, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费消息-&gt;可重试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">poll</span><span class="params">(<span class="keyword">boolean</span> isRetry)</span> </span>&#123;</span><br><span class="line">        String message = jedis.rpop(queueKey);</span><br><span class="line">        <span class="keyword">if</span> (message == <span class="keyword">null</span> &amp;&amp; isRetry) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            message = jedis.rpop(queueKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/8 15:47</span></span><br><span class="line"><span class="comment"> * 消息生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageProducer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 队列</span></span><br><span class="line">    <span class="keyword">private</span> RedisQueue queue;</span><br><span class="line">    <span class="comment">// 消息转换器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MessageConvert&lt;TaskItem&gt; convert = <span class="keyword">new</span> MessageConvert&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageProducer</span><span class="params">(RedisQueue queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            send(<span class="string">"message:"</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">30</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并发送消息</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一条消息</span></span><br><span class="line">        TaskItem item = <span class="keyword">new</span> TaskItem();</span><br><span class="line">        item.id = UUID.randomUUID().toString();</span><br><span class="line">        item.msg = message;</span><br><span class="line">        <span class="comment">// 转换为字符串发送</span></span><br><span class="line">        String sendMess = convert.messageToString(item);</span><br><span class="line">        queue.push(sendMess);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/8 15:48</span></span><br><span class="line"><span class="comment"> * 消息消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageConsumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RedisQueue queue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageConsumer</span><span class="params">(RedisQueue queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(random.nextInt(<span class="number">10</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            receive();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object object = queue.poll(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (object != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/8 15:45</span></span><br><span class="line"><span class="comment"> * 消息转换器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageConvert</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Type taskType = <span class="keyword">new</span> TypeReference&lt;T&gt;() &#123;&#125;.getType();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将给定的消息转换为string类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">messageToString</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JSON.toJSONString(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将string类型的消息转换为T类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">stringToObject</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JSON.parseObject(message, taskType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="zset实现延时队列"><a href="#zset实现延时队列" class="headerlink" title="zset实现延时队列"></a><code>zset实现延时队列</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delayQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(url, port);</span><br><span class="line">    <span class="comment">// 延时队列</span></span><br><span class="line">    RedisDelayingQueue queue = <span class="keyword">new</span> RedisDelayingQueue(jedis, <span class="string">"q-demo"</span>);</span><br><span class="line">    DelayMessageConsumer consumer = <span class="keyword">new</span> DelayMessageConsumer(queue);</span><br><span class="line">    DelayMessageProducer producer = <span class="keyword">new</span> DelayMessageProducer(queue);</span><br><span class="line">    producer.start();</span><br><span class="line">    consumer.start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 首先让producer线程执行完成</span></span><br><span class="line">        producer.join();</span><br><span class="line">        <span class="comment">// 主线程睡眠6秒，等待consumer将消息消费完成</span></span><br><span class="line">        Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">        consumer.interrupt();</span><br><span class="line">        consumer.join();</span><br><span class="line">    &#125;  <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/7 16:56</span></span><br><span class="line"><span class="comment"> * 延时队列-&gt; 通过zset实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisDelayingQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line">    <span class="keyword">private</span> String queueKey;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisDelayingQueue</span><span class="params">(Jedis jedis, String queueKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jedis = jedis;</span><br><span class="line">        <span class="keyword">this</span>.queueKey = queueKey;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 执行消息的发送</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delay</span><span class="params">(String msg, <span class="keyword">long</span> score)</span> </span>&#123;</span><br><span class="line">        jedis.zadd(queueKey, score, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行消息的处理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">(MessageHandle handle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">            <span class="comment">// fixme 此处需要优化，保证操作的原子性</span></span><br><span class="line">            <span class="comment">// 获取一条数据(score最小的那条数据)</span></span><br><span class="line">            Set values = jedis.zrangeByScore(queueKey, <span class="number">0</span>, System.currentTimeMillis(), <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 若是队列中没有任务，线程睡眠500毫秒</span></span><br><span class="line">            <span class="keyword">if</span> (values.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String value = (String) values.iterator().next();</span><br><span class="line">            <span class="comment">// 从queueKey中移除该元素</span></span><br><span class="line">            <span class="keyword">if</span> (jedis.zrem(queueKey, value) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 将消息交给回调接口来处理</span></span><br><span class="line">                handle.handle(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/8 17:13</span></span><br><span class="line"><span class="comment"> * 延时队列-生产者线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayMessageProducer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    RedisDelayingQueue queue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelayMessageProducer</span><span class="params">(RedisDelayingQueue queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) &#123;</span><br><span class="line">            String message = <span class="string">"message:"</span>+ i;</span><br><span class="line">            <span class="keyword">long</span> score = random.nextInt(<span class="number">10</span>);</span><br><span class="line">            send(message, score);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String msg, <span class="keyword">long</span> delay)</span> </span>&#123;</span><br><span class="line">        TaskItem task = <span class="keyword">new</span> TaskItem();</span><br><span class="line">        task.id = UUID.randomUUID().toString();</span><br><span class="line">        task.msg = msg;</span><br><span class="line">        String message = JSON.toJSONString(task);</span><br><span class="line">        queue.delay(message, delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/8 17:11</span></span><br><span class="line"><span class="comment"> * 延时队列消费者线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayMessageConsumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    RedisDelayingQueue queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> MessageHandle handle = <span class="keyword">new</span> MessageHandle() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">            System.out.println(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelayMessageConsumer</span><span class="params">(RedisDelayingQueue queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue.loop(handle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/8 17:21</span></span><br><span class="line"><span class="comment"> * 消息处理回调接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageHandle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(String item)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;list实现分布式队列&quot;&gt;&lt;a href=&quot;#list实现分布式队列&quot; class=&quot;headerlink&quot; title=&quot;list实现分布式队列&quot;&gt;&lt;/a&gt;&lt;code&gt;list实现分布式队列&lt;/code&gt;&lt;/h6&gt;&lt;figure class=&quot;highlight
      
    
    </summary>
    
      <category term="数据库" scheme="https://zhilongao.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="redis" scheme="https://zhilongao.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/"/>
    
    
  </entry>
  
  <entry>
    <title>单链表</title>
    <link href="https://zhilongao.github.io/wiki/alg-linkedlist-simple1/"/>
    <id>https://zhilongao.github.io/wiki/alg-linkedlist-simple1/</id>
    <published>2019-08-31T03:56:40.000Z</published>
    <updated>2019-09-25T11:42:36.482Z</updated>
    
    <content type="html"><![CDATA[<p><code>单链表常见操作</code></p><p><code>1.如何实现一个单链表的逆序输出-&gt;反转单链表</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">    ListNode next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span> &amp;&amp; (next = head.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    head.next = prev;</span><br><span class="line">        prev = head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    head.next = prev;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;单链表常见操作&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1.如何实现一个单链表的逆序输出-&amp;gt;反转单链表&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;
      
    
    </summary>
    
      <category term="算法" scheme="https://zhilongao.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="https://zhilongao.github.io/categories/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/"/>
    
    
  </entry>
  
</feed>
