<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zl&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhilongao.github.io/"/>
  <updated>2019-09-28T06:11:58.370Z</updated>
  <id>https://zhilongao.github.io/</id>
  
  <author>
    <name>gaozhilong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Unsafe</title>
    <link href="https://zhilongao.github.io/wiki/ans-unsafe-source/"/>
    <id>https://zhilongao.github.io/wiki/ans-unsafe-source/</id>
    <published>2019-09-27T09:19:05.000Z</published>
    <updated>2019-09-28T06:11:58.370Z</updated>
    
    <content type="html"><![CDATA[<h6 id="Unsafe类"><a href="#Unsafe类" class="headerlink" title="Unsafe类"></a><code>Unsafe类</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// jdk核心类库可操作的api</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsafe</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对外暴露的实例属性，类加载阶段加载</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe theUnsafe;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        theUnsafe = <span class="keyword">new</span> Unsafe();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Unsafe</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该类中的 theUnsafe 属性为该类的一个实例，对外只提供给jdk核心类库使用。我们在平常的开发中无法通过该方法来获取 theUnsafe 对象。（可以通过万能的反射方式获取）</span></span><br><span class="line">    <span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Class var0 = Reflection.getCallerClass();</span><br><span class="line">        <span class="keyword">if</span> (!VM.isSystemDomainLoader(var0.getClassLoader())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Unsafe"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> theUnsafe;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// native方法，阻塞当前线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">boolean</span> var1, <span class="keyword">long</span> var2)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// native方法，唤醒指定的线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Object var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h6 id="Unsafe操作"><a href="#Unsafe操作" class="headerlink" title="Unsafe操作"></a><code>Unsafe操作</code></h6><hr><p><code>获取Unsafe实例</code></p><p>由于<code>Unsafe</code>实例获取方法添加了类加载器验证，所以我们代码中编写的类是无法直接使用<code>Unsafe</code>类的。一般我们可以有两种方式获取<code>Unsafe</code>实例。① 从限制条件入手，修改引导类加载路径，将我们编写的路径添加到引导类路径中。② 通过反射的方式获取。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="comment">// 获取到Unsafe实例</span></span><br><span class="line">    Unsafe unsafe = getUnsafe();</span><br><span class="line">    System.out.println(unsafe);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.通过反射获取 Unsafe 实例</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Unsafe unsafe = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Field field = Unsafe.class.getDeclaredField(<span class="string">"theUnsafe"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        unsafe = (Unsafe)field.get(<span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unsafe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><code>非常规对象实例化</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 非常规对象实例化</span></span><br><span class="line">    People p1 = (People)getInstance(People.class);</span><br><span class="line">    People p2 = (People)getInstance(People.class);</span><br><span class="line">    System.out.println(p1);</span><br><span class="line">    System.out.println(p2);</span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="comment">// null:0</span></span><br><span class="line">    <span class="comment">// null:0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取指定类的实例，该方式不会调用指定类的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getInstance</span> <span class="params">(Class clazz)</span> </span>&#123;</span><br><span class="line">    Unsafe unsafe = getUnsafe();</span><br><span class="line">    Object p = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        p =  unsafe.allocateInstance(clazz);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可操作类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = <span class="string">"default"</span>;</span><br><span class="line">        <span class="keyword">this</span>.age = <span class="number">18</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">":"</span> + <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><code>多线程同步(CAS操作)</code></p><p>juc提供了一些原子操作类，这些类中使用了 Unsafe 类中提供的一些方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取到 Unsafe 类对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="comment">// value属性在内存地址中的偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line">    <span class="comment">// 静态代码块，初始化 valueOffset 属性</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 该类所持有的值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取当前值，并将其加1</span></span><br><span class="line">    <span class="comment">// 调用 UnSafe 类的 getAndAddInt 方法，返回 this 对象上地址偏移量为 valueOffset 处的值，并将其加1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsafe</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 某个对象的某个地址偏移处的值加上某个值，并将原始值返回    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> var5;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 获取到原始值</span></span><br><span class="line">            var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">        &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">        <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">getIntVolatile</span><span class="params">(Object var1, <span class="keyword">long</span> var2)</span></span>;</span><br><span class="line">    <span class="comment">// CAS更新</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br><span class="line">    ...    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><code>挂起与恢复</code></p><p>在<code>LockSupport</code>中提供了两个方法，<code>park</code>与<code>unpark</code>方法，而这两个方法实际上又是调用的<code>Unsafe</code>类中的<code>native</code>方法。<code>park</code>是将当前调用线程阻塞，而<code>unpark</code>方法则是唤醒指定的线程。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupport</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加载 Unsafe 类型的 UNSAFE 实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">...</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// LockSupport提供了挂起当前线程的多个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        setBlocker(t, blocker);</span><br><span class="line">        UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">        setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用 Unsafe 类的unpark方法唤醒指定的线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            UNSAFE.unpark(thread);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsafe</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// 操作系统底层提供的挂起线程的方法(阻塞线程)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">boolean</span> var1, <span class="keyword">long</span> var2)</span></span>;</span><br><span class="line">   <span class="comment">// 操作系统底层提供的唤醒线程的方法(取消阻塞线程)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Object var1)</span></span>; </span><br><span class="line">   <span class="comment">// 几个过期的方法</span></span><br><span class="line">   <span class="comment">// 获得对象锁(可重入锁)</span></span><br><span class="line">   <span class="meta">@Deprecated</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">monitorEnter</span><span class="params">(Object var1)</span></span>;</span><br><span class="line">   <span class="comment">// 释放对象锁 </span></span><br><span class="line">   <span class="meta">@Deprecated</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">monitorExit</span><span class="params">(Object var1)</span></span>;</span><br><span class="line">   <span class="comment">// 尝试获取对象锁 </span></span><br><span class="line">   <span class="meta">@Deprecated</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">tryMonitorEnter</span><span class="params">(Object var1)</span></span>;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><code>内存管理</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内存分配</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">allocateMemory</span><span class="params">(<span class="keyword">long</span> var1)</span></span>;</span><br><span class="line"><span class="comment">// 扩充内存</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">reallocateMemory</span><span class="params">(<span class="keyword">long</span> var1, <span class="keyword">long</span> var3)</span></span>;</span><br><span class="line"><span class="comment">// 释放内存</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">freeMemory</span><span class="params">(<span class="keyword">long</span> var1)</span></span>;</span><br><span class="line"><span class="comment">// 在给定的内存块中设置值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">setMemory</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4, <span class="keyword">byte</span> var6)</span></span>;</span><br><span class="line"><span class="comment">// 内存拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">copyMemory</span><span class="params">(Object var1, <span class="keyword">long</span> var2, Object var4, <span class="keyword">long</span> var5, <span class="keyword">long</span> var7)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关于堆外内存的使用</span></span><br><span class="line"><span class="comment">// 使用原因: 垃圾回收停顿的改善  提升程序IO操作的性能</span></span><br><span class="line"><span class="comment">// java实现堆外内存操作的类 DirectByteBuffer</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DirectByteBuffer</span> <span class="keyword">extends</span> <span class="title">MappedByteBuffer</span> <span class="keyword">implements</span> <span class="title">DirectBuffer</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><code>数组操作</code></p><hr><p><code>内存屏障</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;Unsafe类&quot;&gt;&lt;a href=&quot;#Unsafe类&quot; class=&quot;headerlink&quot; title=&quot;Unsafe类&quot;&gt;&lt;/a&gt;&lt;code&gt;Unsafe类&lt;/code&gt;&lt;/h6&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;t
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="源码" scheme="https://zhilongao.github.io/categories/java/%E6%BA%90%E7%A0%81/"/>
    
    
  </entry>
  
  <entry>
    <title>AQS</title>
    <link href="https://zhilongao.github.io/wiki/ans-aqs-source/"/>
    <id>https://zhilongao.github.io/wiki/ans-aqs-source/</id>
    <published>2019-09-27T06:19:27.000Z</published>
    <updated>2019-09-27T09:17:01.430Z</updated>
    
    <content type="html"><![CDATA[<hr><h6 id="AQS类内部结构"><a href="#AQS类内部结构" class="headerlink" title="AQS类内部结构"></a><code>AQS类内部结构</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head; <span class="comment">// 同步队列头节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail; <span class="comment">// 同步队列尾节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state; <span class="comment">// 锁状态值</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*nextWaiter 属性的几个状态值*/</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node(); <span class="comment">// 标记节点在共享模式下等待</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>; <span class="comment">// 标记节点在排他模式下等待</span></span><br><span class="line">        <span class="comment">/*waitStatus 属性的几个状态值*/</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>; <span class="comment">// 表示节点已经被取消</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>; <span class="comment">// 表示后面节点的线程需要被唤醒。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>; <span class="comment">// 表示节点在条件队列上</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>; <span class="comment">// 关于共享锁的状态 </span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">        <span class="keyword">volatile</span> Node prev; <span class="comment">// 前驱</span></span><br><span class="line"><span class="keyword">volatile</span> Node next; <span class="comment">// 后继</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread thread; <span class="comment">// 节点封装的线程</span></span><br><span class="line">        Node nextWaiter; <span class="comment">// 下一个等待的节点</span></span><br><span class="line">        <span class="comment">// addWaiter方法调用时，会构造一个Node节点</span></span><br><span class="line">        Node(Thread thread, Node mode) &#123;</span><br><span class="line">            <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h6 id="acquire方法"><a href="#acquire方法" class="headerlink" title="acquire方法"></a><code>acquire方法</code></h6><p>该方法定义为获取，<code>ReentrantLock</code>内部获取锁的操作会调用该方法。该方法的执行流程为：</p><p>① 执行<code>tryAcquire</code>，若是该方法返回为<code>true</code>，直接结束。否则执行下一步操作。(<code>tryAcquire</code>是一个空方法，具体逻辑由子类来实现)。</p><p>② 执行<code>addWaiter</code>方法，参数值为<code>Node.EXCLUSIVE</code>。① 该操作首先会将当前线程封装成为一个<code>Node</code>节点，该<code>Node</code>节点的<code>thread</code>值为当前线程，<code>nextWaiter</code>值为<code>null</code>。②  将创建好的该节点添加到同步队列的尾部。③ 将该节点返回。</p><p>③ 执行 <code>acquireQueued(Node node, int arg)</code>方法。该方法以自旋开始。① 获取到给定节点<code>node</code>的前驱节点<code>p</code>。若是<code>p</code>为头节点并且尝试获取锁成功，则将<code>node</code>节点设置为头节点（<code>thread</code>和<code>prev</code>属性设置为<code>null</code>），将<code>p</code>节点清除，返回线程中断表标识。② 若上面条件不满足或执行失败，执行<code>shouldParkAfterFailedAcquire</code>方法和<code>parkAndCheckInterrupt</code>方法。③ 首先是会执行<code>shouldParkAfterFailedAcquire(p, node)</code>方法的，该方法是判断当前线程获取锁失败后，是否需要挂起。执行逻辑是：判断前一个节点<code>p</code>的<code>waitStatus</code>状态值，若是该值为<code>Node.SIGNAL</code>，返回<code>true</code>。其它情况返回<code>false</code>。④ 若是<code>shouldParkAfterFailedAcquire(p, node)</code>方法返回值为<code>true</code>，执行<code>parkAndCheckInterrupt</code>方法，否则执行 ①。⑤ <code>parkAndCheckInterrupt</code>方法首先将当前线程挂起，然后返回线程的中断标识，若是为<code>true</code>，会将<code>interrupted</code>属性设置为<code>true</code>。</p><p>④ 由于<code>acquireQueued(Node node, int agr)</code>方法返回的是当前线程的中断标识，若是返回为<code>true</code>，立马中断当前线程。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) &#123;</span><br><span class="line">        selfInterrupt();</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一个空方法，具体逻辑由子类来实现</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// addWaiter方法，添加一个节点到同步队列</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加一个节点到同步队列，直到成功为止</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一段自旋操作中，成功获取到锁，该方法才会结束。</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) &#123;</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed) &#123;</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将给定的节点设置为头节点，① head指向node ② node的thread属性指向null ③ node的prev属性指向null</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    head = node;</span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line">    node.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当尝试获取锁失败后，判断是否应该将当前的线程挂起</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="comment">// 前一个节点waitStatus状态值为SIGNAL(-1),线程可以被安全的挂起</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 若是前一个节点被取消了(1)，跳过该节点</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// pred和node.prev重新赋值</span></span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 将pred的next指向node节点</span></span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 其它情况，CAS操作将 pred的状态值修改为 SIGNAL</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 挂起当前线程并且返回当前线程的中断状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h6 id="release方法"><a href="#release方法" class="headerlink" title="release方法"></a><code>release方法</code></h6><p>在<code>ReentrantLock</code>的<code>unlock</code>方法中，会直接调用此方法。该方法也是一个模板方法，① 首先会去调用<code>tryRelease(arg)</code>方法，此方法在<code>AQS</code>中是一个空方法，具体逻辑由子类来实现。 ② 若是 ① 调用后返回值为<code>true</code>，执行<code>unparkSuccessor(Node node)</code>方法。<code>unparkSuccessor(Node node)</code>方法会去唤醒<code>node</code>节点的下一个节点。③ 若是 ① 调用后返回值为<code>false</code>，直接返回<code>false</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先执行子类的tryRelease方法，根据其返回值执行具体的操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>) &#123;</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抽象方法，由具体的子类来实现</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 若是node节点存在后继节点，则将其唤醒</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">// 当node节点的next节点为null或者其已经被取消时，从尾节点向前遍历,找到一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                s = t;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到了一个不为null的节点，将其唤醒 </span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Condition与ConditionObject"><a href="#Condition与ConditionObject" class="headerlink" title="Condition与ConditionObject"></a><code>Condition与ConditionObject</code></h6><p>在AQS内部定义了一个类<code>ConditionObject</code>，该类实现了<code>Condition</code>接口。类直接的定义关系如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 条件队列头节点</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">        <span class="comment">// 条件队列尾节点</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h6 id="await方法"><a href="#await方法" class="headerlink" title="await方法"></a><code>await方法</code></h6><p>该方法是将当前线程添加到条件队列上。执行逻辑：① 若是当前线程已经被打断，直接抛出异常。 ② 调用<code>addConditionWaiter</code>方法，将当前的线程封装成为一个 Node 节点，添加到等待队列的尾部，并返回该节点。③  调用<code>fullyRelease</code>方法释放当前线程获取到的锁。④  while循环，调用 <code>isOnSyncQueue</code> 方法判断节点是否在同步队列，没在同步队列执行 <code>while</code> 循环体，挂起当前线程。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 判断中断，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// 添加到等待队列</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">// 释放该线程获取的锁</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加一个新的节点到等待队列。</span></span><br><span class="line"><span class="comment">// 1. 清除被取消的节点</span></span><br><span class="line"><span class="comment">// 2. 将当前线程封装成Node节点，添加到等待队列</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放当前线程获取到的锁</span></span><br><span class="line"><span class="comment">// 1. 获取到锁状态 state 的值</span></span><br><span class="line"><span class="comment">// 2. 调用 release 方法释放锁</span></span><br><span class="line"><span class="comment">// 3. 释放成功，返回state 之前的值。</span></span><br><span class="line"><span class="comment">// 4. 释放失败，抛出异常。</span></span><br><span class="line"><span class="comment">// 5. 若是释放失败，将当前线程节点的 waitStatus 状态值设置为 Node.CANCELLED（取消）</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> savedState = getState();</span><br><span class="line">        <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">            failed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed) &#123;</span><br><span class="line">            node.waitStatus = Node.CANCELLED;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判定给定的节点是否在同步队列上</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h6 id="signal方法"><a href="#signal方法" class="headerlink" title="signal方法"></a><code>signal方法</code></h6><p>① 调用<code>isHeldExclusively</code>方法，返回<code>false</code>，直接抛出异常，否则执行下一步。②  获取到等待队列的第一个节点，将其做为参数，调用<code>doSignal</code>方法。③ <code>doSignal</code>方法会将给定的节点从等待队列放到同步队列的尾部。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">        doSignal(first);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断获取到锁的线程是否为当前线程</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ReentrantLock的Sync的内部实现</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 first 节点从等待队列移动到同步队列</span></span><br><span class="line"><span class="comment">// 1. 将first节点从等待队列中去除</span></span><br><span class="line"><span class="comment">// 2. 调用 transferForSignal 方法将 first节点放到同步队列</span></span><br><span class="line"><span class="comment">// 3. 若是上一步失败，尝试下一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp; (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 node 节点添加到同步队列的尾部</span></span><br><span class="line"><span class="comment">// 1. cas操作将 node 节点的 waitStatus 状态值由 Node.CONDITION修改为0,修改失败返回false。</span></span><br><span class="line"><span class="comment">// 2. 将node节点添加到同步队列的尾部</span></span><br><span class="line"><span class="comment">// 3. 若是node节点的waitStatus状态值大于0,或者将node节点的状态值设置为SIGNAL失败，唤醒该节点线程。</span></span><br><span class="line"><span class="comment">// 4. 返回 true。</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h6 id="signalAll方法"><a href="#signalAll方法" class="headerlink" title="signalAll方法"></a><code>signalAll方法</code></h6><p>具体逻辑：大体和<code>signal</code>方法相同，但其会执行<code>doSignalAll(first)</code>方法而不是<code>doSignal(first)</code>方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignalAll(first);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1. 清除等待队列 lastWaiter = firstWaiter = null;</span></span><br><span class="line"><span class="comment">// 2. 从 first节点开始，依次调用 transferForSignal方法，直到节点为null。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignalAll</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    lastWaiter = firstWaiter = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        Node next = first.nextWaiter;</span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">        transferForSignal(first);</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (first != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h6 id=&quot;AQS类内部结构&quot;&gt;&lt;a href=&quot;#AQS类内部结构&quot; class=&quot;headerlink&quot; title=&quot;AQS类内部结构&quot;&gt;&lt;/a&gt;&lt;code&gt;AQS类内部结构&lt;/code&gt;&lt;/h6&gt;&lt;figure class=&quot;highlight java&quot;&gt;
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="源码" scheme="https://zhilongao.github.io/categories/java/%E6%BA%90%E7%A0%81/"/>
    
    
  </entry>
  
  <entry>
    <title>lambda和stream</title>
    <link href="https://zhilongao.github.io/wiki/java-style-lambda/"/>
    <id>https://zhilongao.github.io/wiki/java-style-lambda/</id>
    <published>2019-09-23T11:11:56.000Z</published>
    <updated>2019-09-25T05:42:41.729Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.infoq.cn/article/Java-se-8-lambda" target="_blank" rel="noopener">参考文章1</a></p><p><a href="https://my.oschina.net/chenxiaobian/blog/704421" target="_blank" rel="noopener">参考文章2</a></p><h6 id="功能性接口的简化"><a href="#功能性接口的简化" class="headerlink" title="功能性接口的简化"></a><code>功能性接口的简化</code></h6><hr><ol><li>lambda表达式可以简化<code>Runnable</code>，<code>Comparator</code>这种接口的写法。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*****lambda表达式简化线程的创建*****/</span></span><br><span class="line"><span class="comment">// 普通写法</span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// lambda写法</span></span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"><span class="comment">// do something                </span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****lambda表达式简化 Collections.sort 排序*****/</span></span><br><span class="line"><span class="comment">// 普通写法</span></span><br><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1 - o2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// lambda写法</span></span><br><span class="line">Collections.sort(list, (x, y) -&gt; x - y);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****自定义功能接口*****/</span></span><br><span class="line">List&lt;String&gt; params = Arrays.asList(<span class="keyword">new</span> String[]&#123;<span class="string">"app"</span>, <span class="string">"red"</span>, <span class="string">"blue"</span>&#125;);</span><br><span class="line"><span class="comment">// 映射List中元素的length集合</span></span><br><span class="line">List&lt;Integer&gt; res1 = <span class="keyword">new</span> CollectionUtils&lt;String, Integer&gt;().map(params, (String param) -&gt; param.length());</span><br><span class="line"><span class="comment">// 映射list中以元素的大写集合</span></span><br><span class="line">List&lt;String&gt; res2 = <span class="keyword">new</span> CollectionUtils&lt;String, String&gt;().map(params, (String param) -&gt; param.toUpperCase());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义函数式接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyOP</span>&lt;<span class="title">P</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(P obj)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 集合操作类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollectionUtils</span>&lt;<span class="title">P</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 对集合中的元素进行操作，操作完成之后返回一个新的集合</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;R&gt; <span class="title">map</span><span class="params">(List&lt;P&gt; input, MyOP&lt;P, R&gt; myOp)</span> </span>&#123;</span><br><span class="line">        List&lt;R&gt; result = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span> (P obj : input) &#123;</span><br><span class="line">            result.add(myOp.apply(obj));</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="方法和构造方法的引用"><a href="#方法和构造方法的引用" class="headerlink" title="方法和构造方法的引用"></a><code>方法和构造方法的引用</code></h6><hr><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lambda表达式的一般写法</span></span><br><span class="line">params.forEach((v) -&gt; System.out.print(v + <span class="string">"\t"</span>));</span><br><span class="line"><span class="comment">// lambda的简化写法</span></span><br><span class="line">params.forEach(System.out::print);</span><br><span class="line"></span><br><span class="line"><span class="comment">// lambda构造方法的简写 Date::new</span></span><br><span class="line">List&lt;Long&gt; dateValues = Arrays.asList(<span class="keyword">new</span> Long[] &#123;<span class="number">0L</span>, <span class="number">1000L</span>&#125;);</span><br><span class="line">List&lt;Date&gt; map = <span class="keyword">new</span> CollectionUtils&lt;Long, Date&gt;().map(dateValues, Date::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure><h6 id="接口的默认方法"><a href="#接口的默认方法" class="headerlink" title="接口的默认方法"></a><code>接口的默认方法</code></h6><hr><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 解决了接口的演化问题（接口中新增默认实现方法，不影响原先的实现类）</span><br><span class="line"><span class="number">2</span>. 实现了行为的多继承 （一个类可以实现多个接口的默认方法）</span><br></pre></td></tr></table></figure><h6 id="stream"><a href="#stream" class="headerlink" title="stream"></a><code>stream</code></h6><hr><p><code>Stream原理</code>：流式操作，由 jdk 内部分配多个线程来执行 stream 内部的操作。并发流使用的默认线程数等于你机器的处理器核心数。</p><p><code>Stream场景</code>：由于 Stream 是由 jdk 内部来为任务分配线程，所以在 一些耗时操作慎用 Stream。</p><p><code>Stream应用</code>：Stream.of()方法，可以接收单个参数，也可以接收一个数组参数，将其转换为一个Stream对象。下面是几个Stream的简单应用demo。</p><hr><p>（1）实例代码(forEach方法遍历)-&gt;接收一个参数, 通过forEach方法接收一个功能接口。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">Stream.of(list).forEach(System.out::println);</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><hr><p>（2）实例代码(forEach方法遍历)-&gt;接收一个数组，通过forEach方法接收一个功能接口。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(list.toArray()).forEach(System.out::println);</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><hr><p>（3）实例代码(filter方法过滤)-&gt; 找处以小写字母’a’开头的字符串</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">"Abc"</span>, <span class="string">"abc"</span>, <span class="string">"ccc"</span>, <span class="string">"asD"</span>)</span><br><span class="line">    .filter((str) -&gt; &#123;<span class="keyword">return</span> str.startsWith(<span class="string">"a"</span>);&#125;)</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// asD</span></span><br></pre></td></tr></table></figure><hr><p>（4）实例方法-&gt;(map方法建立映射)-&gt; 统计给出数组中每个字符串的长度</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">"A"</span>, <span class="string">"abc"</span>, <span class="string">"cc"</span>, <span class="string">"a"</span>)</span><br><span class="line">    .map((str) -&gt; str.length())</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><hr><p> （5）实例方法-&gt;(reduce方法的使用) -&gt; 初始值为 100，计算初始值加1到5的值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">int</span> init = <span class="number">100</span>;</span><br><span class="line">Integer result = integerList.stream()</span><br><span class="line">    .reduce(init, (a, b) -&gt; a + b);</span><br><span class="line">System.out.println(<span class="string">"result-&gt;"</span> + result);</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// 115</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.infoq.cn/article/Java-se-8-lambda&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考文章1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://my.oschina.net/c
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="新特性" scheme="https://zhilongao.github.io/categories/java/%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>负载均衡</title>
    <link href="https://zhilongao.github.io/wiki/spring-cloud-loadbalance/"/>
    <id>https://zhilongao.github.io/wiki/spring-cloud-loadbalance/</id>
    <published>2019-09-21T01:31:06.000Z</published>
    <updated>2019-09-21T08:05:15.345Z</updated>
    
    <content type="html"><![CDATA[<p>完善中。。。。</p><h6 id="负载均衡算法基础-理论"><a href="#负载均衡算法基础-理论" class="headerlink" title="负载均衡算法基础(理论)"></a><code>负载均衡算法基础(理论)</code></h6><p><a href="https://en.wikipedia.org/wiki/Load_balancing_(computing)" target="_blank" rel="noopener">参考资料</a></p><hr><p>负载均衡分类：客户端负载均衡  服务端负载均衡</p><hr><p>负载均衡算法</p><p>​    随机   轮询</p><p>​    权重</p><hr><h6 id="Ribbon的实现-设计"><a href="#Ribbon的实现-设计" class="headerlink" title="Ribbon的实现(设计)"></a><code>Ribbon的实现(设计)</code></h6><p>设计分析</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 核心接口</span></span><br><span class="line">com.netflix.loadbalancer.IRule</span><br><span class="line">com.netflix.loadbalancer.ILoadBalancer</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务实例定义实体</span></span><br><span class="line">Netflix Eureka </span><br><span class="line">com.netflix.appinfo.InstanceInfo</span><br><span class="line"></span><br><span class="line">Spring Cloud Commons</span><br><span class="line">org.springframework.cloud.client.ServiceInstance</span><br><span class="line"></span><br><span class="line">Netflix Ribbon</span><br><span class="line">com.netflix.loadbalancer.Server</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;完善中。。。。&lt;/p&gt;
&lt;h6 id=&quot;负载均衡算法基础-理论&quot;&gt;&lt;a href=&quot;#负载均衡算法基础-理论&quot; class=&quot;headerlink&quot; title=&quot;负载均衡算法基础(理论)&quot;&gt;&lt;/a&gt;&lt;code&gt;负载均衡算法基础(理论)&lt;/code&gt;&lt;/h6&gt;&lt;p&gt;&lt;a h
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="框架" scheme="https://zhilongao.github.io/categories/java/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="spring-cloud" scheme="https://zhilongao.github.io/categories/java/%E6%A1%86%E6%9E%B6/spring-cloud/"/>
    
    
  </entry>
  
  <entry>
    <title>ReentrantLock</title>
    <link href="https://zhilongao.github.io/wiki/ans-reentlock-source/"/>
    <id>https://zhilongao.github.io/wiki/ans-reentlock-source/</id>
    <published>2019-09-18T12:31:57.000Z</published>
    <updated>2019-09-27T09:29:08.157Z</updated>
    
    <content type="html"><![CDATA[<hr><h6 id="类关系与锁初始化"><a href="#类关系与锁初始化" class="headerlink" title="类关系与锁初始化"></a><code>类关系与锁初始化</code></h6><p>在<code>ReentrantLock</code>类内部有一个属性，<code>Sync:sync</code>，该属性对应的类是定义在<code>ReentrantLock</code>内部的一个静态类（抽象类）。<code>ReentrantLock</code>内部又为<code>Sync</code>定义了两个子类<code>NonfairSync</code>和<code>FairSync</code>。根据类名便可看到非公平与公平之分。我们通过api使用<code>ReentrantLock</code>类时，会调用其构造函数创建一个该类型的对象，构造函数可传参数<code>true|false</code>，确定创建公平或非公平锁。若没传递参数，会默认创建非公平锁。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 几个类定义关系图</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认创建非公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 参数为 true 创建公平锁，false 创建非公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h6 id="方法调用关系"><a href="#方法调用关系" class="headerlink" title="方法调用关系"></a><code>方法调用关系</code></h6><p>调用<code>ReentrantLock:lock</code>方法或是<code>ReentrantLock:unlock</code>方法时，<code>ReentrantLock</code>会委托<code>Sync</code>来执行具体的上锁或者是释放锁的逻辑。① 关于<code>lock</code>，在<code>Sync</code>内部定义了一个抽象方法<code>Sync:lock</code>，在其子类<code>FairSync</code>和<code>NonfairSync</code>均实现了这个方法。这两个实现类的<code>lock</code>方法最终又会调用<code>Sync</code>的父类<code>AQS</code>的<code>acquire</code>方法。② 关于<code>unlock</code>，实际上调用的是<code>Sync</code>的父类<code>AQS</code>的<code>release</code>方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*****ReentrantLock*****/</span></span><br><span class="line"><span class="comment">// 上锁，调用sync的lock方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解锁，调用sync的父类aqs的release方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*****Sync*****/</span></span><br><span class="line"><span class="comment">// 上锁-&gt; 抽象方法，具体逻辑由子类FairSync或NonfairSync来实现</span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 解锁-&gt; Sync的父类AbstractQueuedSynchronizer定义的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FairSync类实现的lock方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// NonfairSync类实现的lock方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h6 id="lock之公平与非公平"><a href="#lock之公平与非公平" class="headerlink" title="lock之公平与非公平"></a><code>lock之公平与非公平</code></h6><p>① <code>NonfairSync:lock</code>方法在执行时，首先会通过CAS操作直接修改锁状态<code>state</code>的值，若是执行成功，则成功获取到锁，若是执行失败，调用<code>AbstractQueuedSynchronizer:acquire(1)</code>方法来执行普通的上锁逻辑。<code>FairSync:lock</code>方法在执行时，直接调用 <code>AbstractQueuedSynchronizer:acquire(1)</code>方法来执行普通的上锁逻辑。（非公平锁直接忽略了排队等待获取锁的线程）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*****NonfairSync*****/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*****FairSync*****/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>② 在上面的分析中，非公平锁的实现类在尝试设置锁失败时，直接调用<code>AQS</code>的<code>acquire</code>方法，而公平锁的实现类直接调用<code>AQS</code>的<code>acquire</code>方法。<code>AQS:acquire</code>方法属于一个模板方法，内部定义了获取锁的操作步骤。其中<code>tryAcquire</code>方法是其第一个调用的方法，也是一个没有实现的空方法，具体的实现逻辑由其子类来实现。</p><p><code>NonfairSync:tryAcquire</code>方法内部会调用其父类的<code>Sync:nonfairTryAcquire</code>方法，该方法语义为非公平尝试获取。具体逻辑：首先判断锁的状态，若是没有线程获取到锁，执行通过<code>CAS</code>操作修改锁状态，若是成功返回<code>true</code>。若是未成功，继续判断获取锁的线程是否为当前线程，若是当前线程，将锁状态值加上方法传入的值，并将锁状态值更新（可重入），返回<code>true</code>，否则返回<code>false</code>。 </p><p><code>FairSync:tryAcquire</code>方法的执行逻辑：判断是   否有线程获取到锁，若是没有线程获取到锁，继续判断是否有线程等待获取锁，若是无线程等待获取锁，<code>CAS</code>操作获取锁，成功返回<code>true</code>。操作获取锁失败，或者有线程等待获取锁，或者已有线程获取到锁，继续判断当前获取到锁的线程是否为当前线程，是则执行可重入锁操作并返回<code>true</code>，否则返回<code>false</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*****AbstractQueuedSynchronizer *****/</span></span><br><span class="line"><span class="comment">// AQS中定义的获取锁的模板方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一个未实现的方法，具体逻辑由子类来实现</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*****NonfairSync*****/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*****Sync*****/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****FairSync*****/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h6 id="unlock执行逻辑"><a href="#unlock执行逻辑" class="headerlink" title="unlock执行逻辑"></a><code>unlock执行逻辑</code></h6><p>调用<code>ReentrantLock:unlock</code>方法时，<code>Sync</code>会调用父类的<code>AbstractQueuedSynchronizer：release</code>方法。</p><p>具体逻辑是：① 首先<code>tryRelease</code>方法会被调用，而这个方法在<code>AQS</code>中是一个没有具体实现的空方法，具体逻辑由子类<code>Sync</code>来实现。② 子类中首先会去判断当前线程是否就是获取到锁的线程，若不是直接抛出异常，否则执行下一步的逻辑。③  获取到锁状态<code>state</code>的值，并用<code>state</code>值减去方法传的参数值（释放多少次），计算出一个结果。④  若是计算出来的这个结果为<code>0</code>，将<code>state</code>的值设置为<code>0</code>，并将获取锁的线程设置为<code>null</code>，并返回<code>true</code>。⑤ 若是计算出来的这个结果不为<code>0</code>，将<code>state</code>的值设置为计算得到的值，返回<code>false</code>。</p><p>子类执行完<code>tryRelease</code>方法后，会返回一个值。① 若是该值为<code>true</code>，<code>AQS:release</code>方法会执行其它逻辑，执行完返回<code>true</code>。② 若是该值为<code>false</code>，<code>AQS:release</code>方法直接返回<code>false</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*****ReentrantLock *****/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*****AbstractQueuedSynchronizer *****/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****Sync*****/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h6 id="LockSupport与Unsafe"><a href="#LockSupport与Unsafe" class="headerlink" title="LockSupport与Unsafe"></a><code>LockSupport与Unsafe</code></h6><hr><p>在<code>LockSupport</code>中提供了两个方法，<code>park</code>与<code>unpark</code>方法，而这两个方法实际上又是调用的<code>Unsafe</code>类中的<code>native</code>方法。<code>park</code>是将当前调用线程阻塞，而<code>unpark</code>方法则是唤醒指定的线程。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupport</span> </span>&#123;</span><br><span class="line">    <span class="comment">// jdk内部用于操作内存地址的类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">...</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用 Unsafe 类的park方法将当前线程阻塞</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        setBlocker(t, blocker);</span><br><span class="line">        UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">        setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用 Unsafe 类的unpark方法唤醒指定的线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            UNSAFE.unpark(thread);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="comment">// jdk核心类库可操作的api</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsafe</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe theUnsafe;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        theUnsafe = <span class="keyword">new</span> Unsafe();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Unsafe</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该类中的 theUnsafe 属性为该类的一个实例，对外只提供给jdk核心类库使用。我们在平常的开发中无法通过该方法来获取 theUnsafe 对象。（可以通过万能的反射方式获取）</span></span><br><span class="line">    <span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Class var0 = Reflection.getCallerClass();</span><br><span class="line">        <span class="keyword">if</span> (!VM.isSystemDomainLoader(var0.getClassLoader())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Unsafe"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> theUnsafe;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// native方法，阻塞当前线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">boolean</span> var1, <span class="keyword">long</span> var2)</span></span>;</span><br><span class="line">    <span class="comment">// native方法，唤醒指定的线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Object var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>关于可重入锁的Condition分析—-&gt; 等待队列</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ReentrantLock</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sync</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS-&gt;ConditionObject</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1173984872572414699L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConditionObject</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加一个等待的线程</span></span><br><span class="line">    <span class="comment">// 若是最后一个节点不为null，并且其 waitStatus 状态值不为 CONDITION。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node t = lastWaiter;</span><br><span class="line">        <span class="comment">// 添加之前先清理一番</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line">            t = lastWaiter;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建一个节点， 将其加入到同步队列的尾部</span></span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            firstWaiter = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            t.nextWaiter = node;</span><br><span class="line">        &#125;    </span><br><span class="line">        lastWaiter = node;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个方法的目的就一个: 从等待队列中清除 waitStatus 状态值不为 CONDITION 的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node t = firstWaiter;</span><br><span class="line">        Node trail = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 在节点 t 不为 null 的情况下，不断的执行循环操作</span></span><br><span class="line">        <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 首先保存下一个节点，然后判断当前节点</span></span><br><span class="line">            Node next = t.nextWaiter;</span><br><span class="line">            <span class="comment">// 若是节点的 waitStatus 状态值不为 CONDITION，将节点 t 的 nextWaiter指向为null</span></span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">                t.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 这种情况是: 第一个节点的 waitStatus状态值已经不为 CONDITION 了，可能 next节点为等待节点，故先将 firstWaiter指向 next。若是当前的 trail不为null, 则 trail的nextWaiter也应该指向 next</span></span><br><span class="line">                <span class="keyword">if</span> (trail == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    firstWaiter = next;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    trail.nextWaiter = next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 这种情况是: 遍历到了最后一个节点，并且其 waitStatus 状态值不为 CONDITION，故需要在跳出循环之前将lastWaiter节点更新为 trail节点。</span></span><br><span class="line">                <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    lastWaiter = trail;</span><br><span class="line">                &#125; </span><br><span class="line">            <span class="comment">// 若是节点的 waitStatus 状态值为 CONDITION    </span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                trail = t;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// 下一次循环遍历的节点</span></span><br><span class="line">            t = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/****************************************************/</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取锁状态标识(0: 未上锁  &gt;=1 上锁)</span></span><br><span class="line">            <span class="keyword">int</span> savedState = getState();</span><br><span class="line">            <span class="comment">// 释放成功，返回释放前 state 的值</span></span><br><span class="line">            <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> savedState;</span><br><span class="line">            <span class="comment">// 否则直接抛出异常    </span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 若是操作失败，将当前节点的waitStatus状态值设置未CANCELLED</span></span><br><span class="line">            <span class="keyword">if</span> (failed) &#123;</span><br><span class="line">                node.waitStatus = Node.CANCELLED;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 缩放锁-&gt;在调用await方法时，释放掉当前线程所持有的锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// tryRelease时 ReentrantLock的内部类Sync的方法，成功释放锁返回true，否则返回 false。</span></span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="comment">// 当前线程已经进入到await状态，唤醒啦一个线程来获取锁</span></span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>) &#123;</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;    </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其它情况返回 false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点添加到同步队列和条件队列的区别(两点区别判断给定节点当前所处位置)</span></span><br><span class="line">    <span class="comment">// 同步队列: 双向列表，节点有 prev 和 next 指针指向前驱节点和后继节点。nextWaiter 状态值为 null。</span></span><br><span class="line">    <span class="comment">// 条件队列: 单向列表，节点有 nextWaiter 指针指向后继节点。waitStatus 状态值为 Node.CONDITION</span></span><br><span class="line">    <span class="comment">// 若是节点已经在同步队列上，则返回 true</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 若是 waitStatus 为 Node.CONDITION，证明在条件队列，返回 false。</span></span><br><span class="line">        <span class="comment">// 若不是在条件队列，但是节点的 prev 为 null，也返回 false。</span></span><br><span class="line">        <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 若是节点的 next 指针不指向 null，直接返回 true</span></span><br><span class="line">        <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 从同步队列的尾部找</span></span><br><span class="line">        <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1. 若是在同步队列中找到了，返回 true。</span></span><br><span class="line">    <span class="comment">// 2. 若是在同步队列中没有找到，返回 false。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">findNodeFromTail</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 若是找到的化，直接返回 true</span></span><br><span class="line">            <span class="keyword">if</span> (t == node) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;    </span><br><span class="line">            <span class="comment">// 已经找了一遍，但还是没有找到，返回 false</span></span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取前一个节点判断</span></span><br><span class="line">            t = t.prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted() ?</span><br><span class="line">            (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class="line">        <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关于await方法</span></span><br><span class="line">    <span class="comment">// 1. 若是当前线程已经被中断，直接抛出异常，结束方法的运行。</span></span><br><span class="line">    <span class="comment">// 2. 调用 addConditionWaiter 方法， 将当前的线程封装成为一个 Node 节点，添加到等待队列的尾部。</span></span><br><span class="line">    <span class="comment">// 3. 调用 fullyRelease 方法，释放当前线程所获取到的锁。</span></span><br><span class="line">    <span class="comment">// 4. while循环，调用 isOnSyncQueue 方法判断节点是否在同步队列，没在同步队列执行 while 循环体。挂起当前线程。</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 加入到等待队列</span></span><br><span class="line">        Node node = addConditionWaiter();</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">        <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 线程没在同步队列。</span></span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">            <span class="comment">// 挂起当前线程</span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// 当前线程被唤醒时，执行。检查线程是否被打断，若是已经被打断，结束执行。</span></span><br><span class="line">            <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) &#123;</span><br><span class="line">            interruptMode = REINTERRUPT;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">if</span> (interruptMode != <span class="number">0</span>) &#123;</span><br><span class="line">            reportInterruptAfterWait(interruptMode);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// </span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">// 获取节点的前驱节点</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="comment">// 前驱节点为 head，尝试获取锁，并获取成功</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 获取锁失败执行 park 操作。</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) &#123;</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed) &#123;</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// signal 方法分析</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 拥有锁的线程非当前线程，直接抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 获取到条件队列的第一个节点，对其执行 doSignal 操作。</span></span><br><span class="line">        Node first = firstWaiter;</span><br><span class="line">        <span class="keyword">if</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">            doSignal(first);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// signalAll 方法分析</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 同 signal</span></span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取都条件队列的第一个节点，对其执行 doSignall 操作</span></span><br><span class="line">        Node first = firstWaiter;</span><br><span class="line">        <span class="keyword">if</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">            doSignalAll(first);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 操作是将给定的节点从条件队列转移至同步队列。若是操作失败，会去尝试给定节点的下一个节点，直到条件队列中已经没有节点了。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 总会执行的操作: firstWaiter 指向 first 节点的 nextWaiter 节点。</span></span><br><span class="line">            <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 若是 firstWaiter 为 null 了，则 lastWaiter 也将指向 null。</span></span><br><span class="line">                lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 下面的操作是将 first 节点添加到 同步队列，故将其 nextWaiter 属性值指向为 null。</span></span><br><span class="line">            first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 若是将 first 节点从条件队列转移至同步队列失败并且 firstWaiter 不为 null。    </span></span><br><span class="line">        &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp; (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Node 节点 waitStatus 属性的几个状态值。</span></span><br><span class="line">    <span class="comment">// static final int CANCELLED =  1; 表示节点已经被取消</span></span><br><span class="line">    <span class="comment">// static final int SIGNAL    = -1; 表示后面节点的线程需要被唤醒。</span></span><br><span class="line">    <span class="comment">// static final int CONDITION = -2; 表示节点在条件队列上</span></span><br><span class="line">    <span class="comment">// static final int PROPAGATE = -3; 关于共享锁的状态</span></span><br><span class="line">    <span class="comment">// 0; 非以上值，取0  </span></span><br><span class="line">    <span class="comment">// Node 节点 nextWaiter 属性的几个状态值</span></span><br><span class="line">    <span class="comment">// static final Node SHARED = new Node(); 标记节点在共享模式下等待</span></span><br><span class="line"><span class="comment">// static final Node EXCLUSIVE = null; 标记节点在排他模式下等待</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 操作: 将节点从条件队列转移至同步队列，操作成功返回 true。</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// case 操作尝试，失败返回 false。</span></span><br><span class="line">        <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 将该节点添加到同步队列的尾部，并返回该节点的前一个节点</span></span><br><span class="line">        Node p = enq(node);</span><br><span class="line">        <span class="comment">// 获取返回节点的 waitStatus 状态值</span></span><br><span class="line">        <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">        <span class="comment">// ws 节点被取消</span></span><br><span class="line">        <span class="comment">// ws 未被取消，尝试将其waitStatus状态值从 ws 设置为 SIGNAL失败</span></span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)) &#123;</span><br><span class="line">            <span class="comment">// 唤醒该节点的线程</span></span><br><span class="line">            LockSupport.unpark(node.thread);</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="comment">// 返回 true。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将节点插入到队列，必要时初始化。 返回值为 node 节点的前一个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">            <span class="comment">// 同步队列为 null，初始化 head 和 tail。</span></span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node())) &#123;</span><br><span class="line">                    tail = head;</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// doSignalAll, 唤醒条件队列上的所有线程</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignalAll</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 清除条件队列</span></span><br><span class="line">        lastWaiter = firstWaiter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 循环操作，从第一个节点开始，将条件队列上的所有节点添加到同步队列</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 保存下一个节点</span></span><br><span class="line">            Node next = first.nextWaiter;</span><br><span class="line">            <span class="comment">// 清除 first 节点的 nextWaiter属性</span></span><br><span class="line">            first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 将 first 节点转移至同不队列</span></span><br><span class="line">            transferForSignal(first);</span><br><span class="line">            <span class="comment">// 更新 first 节点</span></span><br><span class="line">            first = next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (first != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h6 id=&quot;类关系与锁初始化&quot;&gt;&lt;a href=&quot;#类关系与锁初始化&quot; class=&quot;headerlink&quot; title=&quot;类关系与锁初始化&quot;&gt;&lt;/a&gt;&lt;code&gt;类关系与锁初始化&lt;/code&gt;&lt;/h6&gt;&lt;p&gt;在&lt;code&gt;ReentrantLock&lt;/code&gt;类
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="源码" scheme="https://zhilongao.github.io/categories/java/%E6%BA%90%E7%A0%81/"/>
    
    
  </entry>
  
  <entry>
    <title>监听器模式</title>
    <link href="https://zhilongao.github.io/wiki/design-pattern-listener/"/>
    <id>https://zhilongao.github.io/wiki/design-pattern-listener/</id>
    <published>2019-09-13T02:58:12.000Z</published>
    <updated>2019-09-25T11:40:02.799Z</updated>
    
    <content type="html"><![CDATA[<h6 id="监听器模式"><a href="#监听器模式" class="headerlink" title="监听器模式"></a><code>监听器模式</code></h6><p>针对监听器模式，jdk提供了<code>EventListener</code>接口和<code>EventObject</code>类，分别定义事件监听器和事件对象。下面是通过扩展这两个接口实现一个简单的事件监听器模式。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/13 11:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 事件源</span></span><br><span class="line">        MyEventSource eventSource = <span class="keyword">new</span> MyEventSource();</span><br><span class="line">        <span class="comment">// 创建事件监听器-&gt;处理EventObject</span></span><br><span class="line">        StartEventListener startEventListener = <span class="keyword">new</span> StartEventListener();</span><br><span class="line">        ClosedEventListener closedEventListener = <span class="keyword">new</span> ClosedEventListener();</span><br><span class="line">        <span class="comment">// 添加事件监听器</span></span><br><span class="line">        eventSource.addEventListener(startEventListener);</span><br><span class="line">        eventSource.addEventListener(closedEventListener);</span><br><span class="line">        <span class="comment">// 创建事件对象</span></span><br><span class="line">        EventObject startEventObject = <span class="keyword">new</span> EventObject(<span class="string">"start"</span>);</span><br><span class="line">        EventObject closedEventObject = <span class="keyword">new</span> EventObject(<span class="string">"closed"</span>);</span><br><span class="line">        <span class="comment">// 事件源-&gt;通知事件监听者来处理</span></span><br><span class="line">        eventSource.notifyListenerEvents(startEventObject);</span><br><span class="line">        eventSource.notifyListenerEvents(closedEventObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/13 11:00</span></span><br><span class="line"><span class="comment"> * 扩展的监听器接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyEventListener</span> <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理EventObject</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleEvent</span><span class="params">(EventObject event)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/13 11:21</span></span><br><span class="line"><span class="comment"> * 启动事件监听器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartEventListener</span> <span class="keyword">implements</span> <span class="title">MyEventListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleEvent</span><span class="params">(EventObject event)</span> </span>&#123;</span><br><span class="line">        Object source = event.getSource();</span><br><span class="line">        <span class="keyword">if</span> (source.equals(<span class="string">"start"</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"context has start!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/13 11:24</span></span><br><span class="line"><span class="comment"> * 关闭事件监听器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClosedEventListener</span> <span class="keyword">implements</span> <span class="title">MyEventListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleEvent</span><span class="params">(EventObject event)</span> </span>&#123;</span><br><span class="line">        Object source = event.getSource();</span><br><span class="line">        <span class="keyword">if</span> (source.equals(<span class="string">"closed"</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"context has closed!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/13 11:03</span></span><br><span class="line"><span class="comment"> * 事件源-&gt;添加 删除 通知</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEventSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听器列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Vector&lt;EventListener&gt; listeners = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册监听器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> eventListener</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEventListener</span><span class="params">(EventListener eventListener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!listeners.contains(eventListener)) &#123;</span><br><span class="line">            listeners.add(eventListener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除监听器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> eventListener</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeEventListener</span><span class="params">(EventListener eventListener)</span> </span>&#123;</span><br><span class="line">        listeners.remove(eventListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收外部的事件-&gt;将事件交给事件监听者来处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyListenerEvents</span><span class="params">(EventObject event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (EventListener eventListener : listeners) &#123;</span><br><span class="line">            ((MyEventListener)eventListener).handleEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="jdk中监听器模式的实现"><a href="#jdk中监听器模式的实现" class="headerlink" title="jdk中监听器模式的实现"></a><code>jdk中监听器模式的实现</code></h6><p>jdk针对监听器模式并未定义太多的实现，只是定义了一个<code>EventListener</code>接口和一个<code>EventObject</code>类，我们可以扩展<code>EventListener</code>接口来定义处理<code>EventObject</code>的方法。在<code>EventObject</code>中有一个属性<code>Object:source</code>，该属性可以在定义<code>EventObject</code>的时候，传入一些参数值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventObject</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">transient</span> Object  source;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EventObject</span><span class="params">(Object source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (source == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"null source"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.source = source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> source;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">"[source="</span> + source + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="spring中监听器模式的实现"><a href="#spring中监听器模式的实现" class="headerlink" title="spring中监听器模式的实现"></a><code>spring中监听器模式的实现</code></h6><p>在spring中定义了<code>ApplicationListener</code>接口和<code>ApplicationEvent</code>类，其中<code>ApplicationListener</code>接口实现了jdk中定义的<code>EventListener</code>接口，并定义了<code>onApplicationEvent</code>方法来处理事件，并且每个<code>ApplicationListener</code>只会处理特定的事件。<code>ApplicationEvent</code>类继承了jdk中定义的<code>EventObject</code>类，用以定义事件对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 扩展的事件监听器接口-&gt;采用泛型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationListener</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span>&gt; <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(E event)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展的EventObject</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationEvent</span> <span class="keyword">extends</span> <span class="title">EventObject</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7099057708183571937L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timestamp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ApplicationEvent</span><span class="params">(Object source)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(source);</span><br><span class="line"><span class="keyword">this</span>.timestamp = System.currentTimeMillis();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getTimestamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.timestamp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="spring中监听器模式的使用"><a href="#spring中监听器模式的使用" class="headerlink" title="spring中监听器模式的使用"></a><code>spring中监听器模式的使用</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/13 11:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        <span class="comment">// 注册监听器</span></span><br><span class="line">        context.addApplicationListener(<span class="keyword">new</span> ApplicationListener&lt;MyApplicationEvent&gt;() &#123;</span><br><span class="line">            <span class="comment">// 接收到事件</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(MyApplicationEvent event)</span> </span>&#123;</span><br><span class="line">                System.out.println(event.getSource());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        context.refresh();</span><br><span class="line">        <span class="comment">// 发布事件</span></span><br><span class="line">        context.publishEvent(<span class="keyword">new</span> MyApplicationEvent(<span class="string">"study spring！"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApplicationEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span></span>&#123;</span><br><span class="line">    MyApplicationEvent(Object source) &#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;监听器模式&quot;&gt;&lt;a href=&quot;#监听器模式&quot; class=&quot;headerlink&quot; title=&quot;监听器模式&quot;&gt;&lt;/a&gt;&lt;code&gt;监听器模式&lt;/code&gt;&lt;/h6&gt;&lt;p&gt;针对监听器模式，jdk提供了&lt;code&gt;EventListener&lt;/code&gt;接口和&lt;c
      
    
    </summary>
    
      <category term="设计模式" scheme="https://zhilongao.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>观察者模式</title>
    <link href="https://zhilongao.github.io/wiki/design-pattern-observer/"/>
    <id>https://zhilongao.github.io/wiki/design-pattern-observer/</id>
    <published>2019-09-13T01:54:53.000Z</published>
    <updated>2019-09-25T11:40:26.715Z</updated>
    
    <content type="html"><![CDATA[<h6 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a><code>观察者模式</code></h6><p>可以通过jdk中提供的<code>Observable</code>类和<code>Observer</code>接口来实现观察者模式。下面通过简单的会员订阅频道，然后频道定期的去给订阅的会员推送消息，展示jdk中观察者模式的使用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/13 9:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 科技频道</span></span><br><span class="line">        TechnologyChannel technologyChannel = <span class="keyword">new</span> TechnologyChannel();</span><br><span class="line">        technologyChannel.setTitle(<span class="string">"科技频道"</span>);</span><br><span class="line">        <span class="comment">// 用户</span></span><br><span class="line">        Members member1 = <span class="keyword">new</span> Members();</span><br><span class="line">        Members member2 = <span class="keyword">new</span> Members();</span><br><span class="line">        <span class="comment">// 用户订阅该科技频道</span></span><br><span class="line">        technologyChannel.addObserver(member1);</span><br><span class="line">        technologyChannel.addObserver(member2);</span><br><span class="line">        <span class="comment">// 给会员定时推送消息</span></span><br><span class="line">        String[] messages = &#123;<span class="string">"华为"</span>, <span class="string">"小米"</span>, <span class="string">"苹果"</span>&#125;;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) &#123;</span><br><span class="line">            <span class="comment">// 创建消息</span></span><br><span class="line">            NotifyMessage message = <span class="keyword">new</span> NotifyMessage();</span><br><span class="line">            String id = UUID.randomUUID().toString();</span><br><span class="line">            message.setId(id);</span><br><span class="line">            message.setCreateTime(System.currentTimeMillis());</span><br><span class="line">            message.setTitle(<span class="string">"手机"</span>);</span><br><span class="line">            message.setContent(messages[random.nextInt(<span class="number">3</span>)] + <span class="string">"又出新机，赶快来订购吧!"</span>);</span><br><span class="line">            <span class="comment">// 评到发送消息给订阅的会员</span></span><br><span class="line">            technologyChannel.setChanged();</span><br><span class="line">            technologyChannel.notifyObservers(message);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/13 9:14</span></span><br><span class="line"><span class="comment"> * 频道</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TechnologyChannel</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setChanged();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/13 9:13</span></span><br><span class="line"><span class="comment"> * 会员</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Members</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> TechnologyChannel) &#123;</span><br><span class="line">            TechnologyChannel channel = (TechnologyChannel)o;</span><br><span class="line">            String title = channel.getTitle();</span><br><span class="line">            NotifyMessage message = (NotifyMessage)arg;</span><br><span class="line">            System.out.println(<span class="string">"channel:"</span> + title);</span><br><span class="line">            System.out.println(<span class="string">"message:"</span> + message);</span><br><span class="line">            System.out.println(<span class="string">"======================="</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/13 9:28</span></span><br><span class="line"><span class="comment"> * 消息通知</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotifyMessage</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> Long createTime;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="jdk中观察者模式的实现"><a href="#jdk中观察者模式的实现" class="headerlink" title="jdk中观察者模式的实现"></a><code>jdk中观察者模式的实现</code></h6><ol><li>观察者（类似订阅模式中的订阅者）。jdk中定义了一个公共的接口<code>Observer</code>，里面定义了一个<code>update</code>方法，该方法可以接收被观察者对象和一个参数对象。我们可以通过实现该接口，重写<code>update</code>方法来实现观察者的逻辑。</li><li>被观察者（类似订阅模式中的被订阅者）。jdk中定义了一个类<code>Observable</code>，可以实现添加，移除，通知观察者。该类里面有两个属性<code>boolean:changed</code>和<code>Vector:obs</code>。当我们执行<code>addObserver</code>方法来添加观察者时，若是该观察者还未被加入到<code>Vector:obs</code>中，会将观察者加入到该集合。当我们执行<code>notifyObservers</code>方法来通知观察者时，只有<code>changed</code>属性为<code>true</code>时，才会依次调用观察者的<code>update</code>方法。若是该值为<code>true</code>，在调用观察者的<code>update</code>方法之前，又会将该值设置为<code>false</code>。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> Vector&lt;Observer&gt; obs;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Observable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obs = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!obs.contains(o)) &#123;</span><br><span class="line">            obs.addElement(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知所有的观察者，可以传递一个参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">        Object[] arrLocal;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 若是状态未变化，不做任何事情</span></span><br><span class="line">            <span class="keyword">if</span> (!changed) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将Vector转化为一个数组</span></span><br><span class="line">            arrLocal = obs.toArray();</span><br><span class="line">            <span class="comment">// 将changed设置为false</span></span><br><span class="line">            clearChanged();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 循环遍历Observer数组，调用其update方法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arrLocal.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">            ((Observer)arrLocal[i]).update(<span class="keyword">this</span>, arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;观察者模式&quot;&gt;&lt;a href=&quot;#观察者模式&quot; class=&quot;headerlink&quot; title=&quot;观察者模式&quot;&gt;&lt;/a&gt;&lt;code&gt;观察者模式&lt;/code&gt;&lt;/h6&gt;&lt;p&gt;可以通过jdk中提供的&lt;code&gt;Observable&lt;/code&gt;类和&lt;code&gt;Obs
      
    
    </summary>
    
      <category term="设计模式" scheme="https://zhilongao.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>分布式配置</title>
    <link href="https://zhilongao.github.io/wiki/spring-cloud-config/"/>
    <id>https://zhilongao.github.io/wiki/spring-cloud-config/</id>
    <published>2019-09-12T03:55:17.000Z</published>
    <updated>2019-09-15T07:48:44.405Z</updated>
    
    <content type="html"><![CDATA[<h6 id="分布式配置"><a href="#分布式配置" class="headerlink" title="分布式配置"></a><code>分布式配置</code></h6><hr><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">相关产品</span><br><span class="line">国内：Disconf(百度)Apollo(携程)Nacos(阿里)</span><br><span class="line">国外: Spring-Cloud-Config  Netfix Archaius</span><br></pre></td></tr></table></figure><hr><h6 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a><code>客户端</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关于配置项的刷新-&gt;主动刷新(拉的模式)</span></span><br><span class="line"><span class="number">1</span>. 客户端可以通过接口 http:<span class="comment">//127.0.0.1:8082/actuator/refresh 来主动刷新配置(post方法) ，但是该接口的调用需要修改配置文件里面的值。</span></span><br><span class="line">management.endpoint.refresh.enabled=<span class="keyword">true</span></span><br><span class="line"><span class="number">2</span>. 当配置项发生变化时，bean里面引用的配置项并未发生变化。需要使用 <span class="meta">@RefreshScope</span> 注解来标记，只有使用该注解标记的类，当配置项发生变化时，引用的配置项才会发生变化。</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span><span class="comment">// (开关 阈值  文案等配置，其它配置可以重启服务器)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;my.name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String myName = <span class="string">"jack-1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/myName"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMyName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">3</span>. 可以配置定时器来每隔指定的时间去主动刷新配置</span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableScheduling</span> <span class="comment">// 开启定时任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigClientApp.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定时刷新配置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ContextRefresher contextRefresher;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Environment environment;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConfigClientApp</span><span class="params">(ContextRefresher contextRefresher, Environment environment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.contextRefresher = contextRefresher;</span><br><span class="line">        <span class="keyword">this</span>.environment = environment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置定时器每隔5秒刷新一次配置项</span></span><br><span class="line">    <span class="meta">@Scheduled</span>(fixedRate = <span class="number">5</span> * <span class="number">1000</span>, initialDelay = <span class="number">3</span> * <span class="number">1000</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">autoRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; updatedPropertyNames = contextRefresher.refresh();</span><br><span class="line">        updatedPropertyNames.forEach( propertyName -&gt;</span><br><span class="line">            System.err.printf(</span><br><span class="line">                    <span class="string">"[Thread :%s] 当前配置已更新，具体 Key：%s , Value : %s \n"</span>,</span><br><span class="line">                    Thread.currentThread().getName(),</span><br><span class="line">                    propertyName,</span><br><span class="line">                    environment.getProperty(propertyName)</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a><code>服务端</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="comment">// 激活配置管理服务器</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServerApp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigServerApp.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义配置实现,绕过git实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EnvironmentRepository <span class="title">environmentRepository</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (String application, String profile, String label) -&gt; &#123;</span><br><span class="line">            Environment environment = <span class="keyword">new</span> Environment(<span class="string">"default"</span>, profile);</span><br><span class="line">            List&lt;PropertySource&gt; propertySources = environment.getPropertySources();</span><br><span class="line">            Map&lt;String, Object&gt; source = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">            source.put(<span class="string">"name"</span>, <span class="string">"微服务-&gt;long"</span>);</span><br><span class="line">            PropertySource propertySource = <span class="keyword">new</span> PropertySource(<span class="string">"map"</span>, source);</span><br><span class="line">            propertySources.add(propertySource);</span><br><span class="line">            <span class="keyword">return</span> environment;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="客户端流程分析"><a href="#客户端流程分析" class="headerlink" title="客户端流程分析"></a><code>客户端流程分析</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 在客户端，我们可以配置形如: localhost:8080/&#123;name&#125;/&#123;profiles&#125;/&#123;label&#125; 去从服务端获取配置。</span></span><br><span class="line"><span class="comment">2. 在服务端是通过 EnvironmentController 类来对外提供服务的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(method = RequestMethod.GET, path = <span class="string">"$&#123;spring.cloud.config.server.prefix:&#125;"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnvironmentController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/&#123;name&#125;/&#123;profiles&#125;/&#123;label:.*&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Environment <span class="title">labelled</span><span class="params">(@PathVariable String name, @PathVariable String profiles,</span></span></span><br><span class="line"><span class="function"><span class="params">@PathVariable String label)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (name != <span class="keyword">null</span> &amp;&amp; name.contains(<span class="string">"(_)"</span>)) &#123;</span><br><span class="line"><span class="comment">// "(_)" is uncommon in a git repo name, but "/" cannot be matched</span></span><br><span class="line"><span class="comment">// by Spring MVC</span></span><br><span class="line">name = name.replace(<span class="string">"(_)"</span>, <span class="string">"/"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (label != <span class="keyword">null</span> &amp;&amp; label.contains(<span class="string">"(_)"</span>)) &#123;</span><br><span class="line"><span class="comment">// "(_)" is uncommon in a git branch name, but "/" cannot be matched</span></span><br><span class="line"><span class="comment">// by Spring MVC</span></span><br><span class="line">label = label.replace(<span class="string">"(_)"</span>, <span class="string">"/"</span>);</span><br><span class="line">&#125;</span><br><span class="line">Environment environment = <span class="keyword">this</span>.repository.findOne(name, profiles, label);</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.acceptEmpty</span><br><span class="line">&amp;&amp; (environment == <span class="keyword">null</span> || environment.getPropertySources().isEmpty())) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> EnvironmentNotFoundException(<span class="string">"Profile Not found"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> environment;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="服务端流程分析"><a href="#服务端流程分析" class="headerlink" title="服务端流程分析"></a><code>服务端流程分析</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 在 @EnableConfigServer 注解中使用了 @Import 注解导入了配置类 ConfigServerConfiguration。</span></span><br><span class="line"><span class="comment">2. 在配置类 ConfigServerConfiguration 上面使用 @Configuration 注解表明该类是一个配置类，该配置类</span></span><br><span class="line"><span class="comment">会在上下文中创建一个类型为 ConfigServerConfiguration.Marker 的bean。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(ConfigServerConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableConfigServer &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServerConfiguration</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Marker <span class="title">enableConfigServerMarker</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Marker();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Marker</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. ConfigServerAutoConfiguration 类上面使用了 @ConditionalOnBean 注解，只有当上下文中存在类型</span></span><br><span class="line"><span class="comment">为 ConfigServerConfiguration.Marker 的bean时，才会执行该配置类的流程（条件装配）。</span></span><br><span class="line"><span class="comment">2. 在该类中导入了一些配置类，EnvironmentRepositoryConfiguration 等这些类会根据条件判断创建相关的</span></span><br><span class="line"><span class="comment">bean。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 配置类</span></span><br><span class="line"><span class="meta">@ConditionalOnBean</span>(ConfigServerConfiguration.Marker.class) <span class="comment">// 条件装配</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(ConfigServerProperties.class)</span><br><span class="line"><span class="meta">@Import</span>(&#123; EnvironmentRepositoryConfiguration.class, CompositeConfiguration.class,</span><br><span class="line">ResourceRepositoryConfiguration.class, ConfigServerEncryptionConfiguration.class,</span><br><span class="line">ConfigServerMvcConfiguration.class &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServerAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. EnvironmentRepositoryConfiguration 通过 @Import 注解导入了一些相关的配置类。</span></span><br><span class="line"><span class="comment">JdbcRepositoryConfiguration GitRepositoryConfiguration 分别时基于jdbc和git实现配置</span></span><br><span class="line"><span class="comment">的仓储。</span></span><br><span class="line"><span class="comment">2. GitRepositoryConfiguration 继承啦 DefaultRepositoryConfiguration 类，属于默认实现。</span></span><br><span class="line"><span class="comment">3. 在 DefaultRepositoryConfiguration 类中 通过 @ConditionalOnMissingBean 注解表明当前</span></span><br><span class="line"><span class="comment">上下文中若是没有 EnvironmentRepository 类型的bean存在时，会创建一个类型为 </span></span><br><span class="line"><span class="comment">MultipleJGitEnvironmentRepository 的bean</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// EnvironmentRepositoryConfiguration 配置</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(&#123; SvnKitEnvironmentProperties.class,</span><br><span class="line">CredhubEnvironmentProperties.class, JdbcEnvironmentProperties.class,</span><br><span class="line">NativeEnvironmentProperties.class, VaultEnvironmentProperties.class &#125;)</span><br><span class="line"><span class="meta">@Import</span>(&#123; CompositeRepositoryConfiguration.class, JdbcRepositoryConfiguration.class,</span><br><span class="line">VaultConfiguration.class, VaultRepositoryConfiguration.class,</span><br><span class="line">CredhubConfiguration.class, CredhubRepositoryConfiguration.class,</span><br><span class="line">SvnRepositoryConfiguration.class, NativeRepositoryConfiguration.class,</span><br><span class="line">GitRepositoryConfiguration.class, DefaultRepositoryConfiguration.class &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnvironmentRepositoryConfiguration</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GitRepositoryConfiguration git实现的配置，继承了 DefaultRepositoryConfiguration 默认实现</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Profile</span>(<span class="string">"git"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GitRepositoryConfiguration</span> <span class="keyword">extends</span> <span class="title">DefaultRepositoryConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// JdbcRepositoryConfiguration jdbc实现的配置</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Profile</span>(<span class="string">"jdbc"</span>)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(JdbcTemplate.class)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JdbcRepositoryConfiguration</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnBean</span>(JdbcTemplate.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> JdbcEnvironmentRepository <span class="title">jdbcEnvironmentRepository</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">JdbcEnvironmentRepositoryFactory factory,</span></span></span><br><span class="line"><span class="function"><span class="params">JdbcEnvironmentProperties environmentProperties)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> factory.build(environmentProperties);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(value = EnvironmentRepository.class, search = SearchStrategy.CURRENT)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultRepositoryConfiguration</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MultipleJGitEnvironmentRepository <span class="title">defaultEnvironmentRepository</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">MultipleJGitEnvironmentRepositoryFactory gitEnvironmentRepositoryFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">MultipleJGitEnvironmentProperties environmentProperties)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">return</span> gitEnvironmentRepositoryFactory.build(environmentProperties);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">到此，还有一个问题，那就是 ConfigServerAutoConfiguration 时如何加载的，通过相关jar包里面的</span></span><br><span class="line"><span class="comment">spring.factories 文件可以看到 ConfigServerAutoConfiguration 被 EnableAutoConfiguration</span></span><br><span class="line"><span class="comment">通过spring的spi加载。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"># Autoconfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.cloud.config.server.config.ConfigServerAutoConfiguration,\</span><br><span class="line">org.springframework.cloud.config.server.config.EncryptionAutoConfiguration</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;分布式配置&quot;&gt;&lt;a href=&quot;#分布式配置&quot; class=&quot;headerlink&quot; title=&quot;分布式配置&quot;&gt;&lt;/a&gt;&lt;code&gt;分布式配置&lt;/code&gt;&lt;/h6&gt;&lt;hr&gt;
&lt;figure class=&quot;highlight tex&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="框架" scheme="https://zhilongao.github.io/categories/java/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="spring-cloud" scheme="https://zhilongao.github.io/categories/java/%E6%A1%86%E6%9E%B6/spring-cloud/"/>
    
    
  </entry>
  
  <entry>
    <title>questions</title>
    <link href="https://zhilongao.github.io/wiki/questions/"/>
    <id>https://zhilongao.github.io/wiki/questions/</id>
    <published>2019-09-12T02:40:03.000Z</published>
    <updated>2019-09-12T02:46:20.517Z</updated>
    
    <content type="html"><![CDATA[<ol><li>说说dubbo服务上下线时你们是如何处理的?</li><li>dubbo的协议有哪些,哪些使用场景?</li><li>dubbo使用的系列化框架是什么?</li><li>dubbo服务容错机制?</li><li>socket协议的几种状态,socket协议的三次握手,为什么是三次握手?</li><li>说说nio和io有什么不同,nio有哪些场景?</li><li>http请求有哪些方法?</li><li>jdk1.8有哪些新特性,使用过哪些?</li><li>谈谈对GC的理解，对G1有了解吗?</li><li>Collection.sort底层默认使用哪种排序算法，说说你熟悉的排序算法有哪些?</li><li>基本数据类型,占用字节,包装类,为什么会有包装类?</li><li>多线程你们在项目中怎么用的?</li><li>jdk1.8中Stream在并行处理时，适合哪些情景，不适合哪些情景?(第一次遇到这样问的,没回答上来)<br>适合计算密集型,不适合IO密集型。因为Stream被分配到的是核心线程池，IO密集型会造成线程阻塞。</li><li>你们reids在使用中，过期时间是怎么设置的，分两步设置不能保证原子性，怎么解决的?</li><li>写一下二分查找算法？</li><li>写一个单例?(DCL)？</li><li>说说dubbo和spring cloud有什么区别?</li><li>你们数据库是怎么优化的,说说实例?</li><li>了解redis吗，说说redis基本数据结构，有哪些常用的指令？</li></ol><hr><p>1、说说 dubbo 的执行流程<br>2、redis 基本数据结构，你们是怎么用的（讲了下 5 分钟发帖 10 次）<br>3、数据库连接池了解吗？<br>4、生产环境项目打印日志出现了时间长的现象，你怎么排查<br>5、接口出现频繁 GC ，怎么排查</p><hr><p>1 线程池用过哪些，在项目中是怎么使用的</p><p>2 sql优化怎么做的，哪些情况触发不了索引 , sql优化除了索引还要看哪些指标</p><p>3 redis有没有遇到数据库满了的情况</p><p>4  说说redis cluster</p><p>5 springmvc  springboot springcloud的区别</p><p>6 对restful有了解吗，弹弹restful</p><p>7 说说对spring的理解</p><p>8 @Autowired和@Resource的区别</p><p>9 设计模式有哪些了解，说说设计模式遵循的原则</p><p>10 交给你一个项目，怎么推进</p><p>11 通过哪些途径学习，看些什么书</p><p>12 总结下自己</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;说说dubbo服务上下线时你们是如何处理的?&lt;/li&gt;
&lt;li&gt;dubbo的协议有哪些,哪些使用场景?&lt;/li&gt;
&lt;li&gt;dubbo使用的系列化框架是什么?&lt;/li&gt;
&lt;li&gt;dubbo服务容错机制?&lt;/li&gt;
&lt;li&gt;socket协议的几种状态,socket协
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="面试题" scheme="https://zhilongao.github.io/categories/java/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>linux系统</title>
    <link href="https://zhilongao.github.io/wiki/linux-system-problem/"/>
    <id>https://zhilongao.github.io/wiki/linux-system-problem/</id>
    <published>2019-09-09T12:19:57.000Z</published>
    <updated>2019-09-10T06:35:55.531Z</updated>
    
    <content type="html"><![CDATA[<h6 id="linux三种网络模式"><a href="#linux三种网络模式" class="headerlink" title="linux三种网络模式"></a><code>linux三种网络模式</code></h6><p>在我们安装vmware的时候，vmware会为三种网络模式各自创建一个虚拟机网络, 其中 VMnet0(表示桥接模式) VMnet8(NAT模式) VMnet1(仅主机模式) </p><hr><p>桥接模式<br>    和主机一样，也会占用一个局域网中的ip。信息的发送和接受，虚拟网络适配器和主机的物理网络适配器进行交换，虚拟网络适配器可以通过主机的物理网络适配器访问外部网络。在局域网中的其它主机能够识别到发送信息的ip为该虚拟机的ip。 </p><p>NAT模式<br>    虚拟机发送数据时，NAT虚拟机网络适配器会以主机的名义将数据包裹发送出去，接收时通过特殊的标识识别。在外部网络中并不知道当前虚拟机的存在。</p><p>主机模式<br>    仅可以和主机通信，无法访问外部网络。</p><hr><p>​    <a href="https://www.cnblogs.com/xuan52rock/p/5295069.html" target="_blank" rel="noopener">一篇介绍的很形象的文章</a></p><hr><h6 id="centos7之动态ip与静态ip"><a href="#centos7之动态ip与静态ip" class="headerlink" title="centos7之动态ip与静态ip"></a><code>centos7之动态ip与静态ip</code></h6><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">centos7获取ip地址的方法主要有两种 1:动态获取  2:设置静态ip</span><br><span class="line"></span><br><span class="line">我们一般通过VMWare安装完centos7后，可以使用命令ip addr查看虚拟机的ip地址。但是刚安装完的centos7有些没有设置ip地址，我们可以通过下面两种方式来设置ip地址。</span><br><span class="line"></span><br><span class="line">1. 动态获取ip(前提是路由器已经开启了DHCP(动态主机设置协议))</span><br><span class="line">  a: 需要修改网卡的配置文件 /etc/sysconfig/network-scripts/ifcfg-ens33 其中ifcfg-ens33为网卡名。修改该文件的两处地方既可。</span><br><span class="line">   (1) bootproto=dhcp</span><br><span class="line">   (2) onboot=yes</span><br><span class="line">  b: 重启下网络服务</span><br><span class="line">   [root@mini ~]# systemctl restart network</span><br><span class="line">  c: 通过 ip addr 命令可以看到ens33的网卡已经有相应的ip地址啦</span><br><span class="line">  d: 通过 ping www.baidu.com 查看网络是否通畅</span><br><span class="line">  </span><br><span class="line">在VMware里，点击'编辑'-'虚拟网络编辑器'  </span><br><span class="line">2. 配置静态ip地址(网络模式在nat模式下)</span><br><span class="line">  a: 也是需要修改网卡配置文件 /etc/sysconfig/network-srcipts/ifcfg-ens33 其中ifcfg-ens33为网卡名。修改该文件的两处地方既可。</span><br><span class="line">   (1) bootproto=static</span><br><span class="line">   (2) onboot=yes </span><br><span class="line">  b: 还需要在该网卡配置文件的后面加上几行，分别是ip地址，子网掩码，网关，dns服务器</span><br><span class="line">    IPADDR=192.168.25.156 #静态ip</span><br><span class="line">    NETMASK=255.255.255.0 #子网掩码</span><br><span class="line">    GATEWAY=192.168.1.1 #网关</span><br><span class="line">    DNS1=192.168.25.2</span><br><span class="line">    DNS2=8.8.8.8 #谷歌的dns服务器</span><br><span class="line">  c: 重启下网络服务</span><br><span class="line">  [root@mini ~]# systemctl restart network</span><br><span class="line">  d: 通过 ip addr 命令可以看到ens33的网卡已经有新的ip地址啦</span><br><span class="line">  e: 通过 ping www.baidu.com 查看网络是否通畅</span><br><span class="line"></span><br><span class="line">3. 在 /etc/resolv.conf文件里面保存了dns地址，可以通过cat命令查看</span><br></pre></td></tr></table></figure><p><code>在设置静态ip时,子网掩码和网关地址可以在vmware的-&gt;编辑-&gt;虚拟网络编辑器-&gt;NAT设置 中查看，如下图所示</code></p><p><img src="https://raw.githubusercontent.com/zhilongao/images-repository/master/46f916fdc305a268fe584b8ba809ed3.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;linux三种网络模式&quot;&gt;&lt;a href=&quot;#linux三种网络模式&quot; class=&quot;headerlink&quot; title=&quot;linux三种网络模式&quot;&gt;&lt;/a&gt;&lt;code&gt;linux三种网络模式&lt;/code&gt;&lt;/h6&gt;&lt;p&gt;在我们安装vmware的时候，vmware
      
    
    </summary>
    
      <category term="系统" scheme="https://zhilongao.github.io/categories/%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="linux" scheme="https://zhilongao.github.io/categories/%E7%B3%BB%E7%BB%9F/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>字符串</title>
    <link href="https://zhilongao.github.io/wiki/alg-string-simple1/"/>
    <id>https://zhilongao.github.io/wiki/alg-string-simple1/</id>
    <published>2019-09-06T02:25:40.000Z</published>
    <updated>2019-09-29T08:26:16.315Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problemset/algorithms/" target="_blank" rel="noopener">题目来自leetcode</a></p><h6 id="字符串反转1-344"><a href="#字符串反转1-344" class="headerlink" title="字符串反转1(344)"></a><code>字符串反转1(344)</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目要求：编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组char[]的形式给出。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = s.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">char</span> temp = s[low];</span><br><span class="line">        s[low++] = s[high];</span><br><span class="line">        s[high--] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="字符串反转2-541"><a href="#字符串反转2-541" class="headerlink" title="字符串反转2(541)"></a><code>字符串反转2(541)</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目要求:给定一个字符串和一个整数 k，你需要对从字符串开头算起的每个 2k 个字符的前k个字符进行反转。如果剩余少于 k 个字符，则将剩余的所有全部反转。如果有小于 2k 但大于或等于 k 个字符，则反转前 k 个字符，并将剩余的字符保持原样。</span></span><br><span class="line"><span class="comment">示例：输入: s = "abcdefg", k = 2 输出: "bacdfeg"</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseStr</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算长度 整数遍历次数 剩余元素个数</span></span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">int</span> lastNum = len % (<span class="number">2</span> * k);</span><br><span class="line">    <span class="keyword">int</span> num = len / (<span class="number">2</span> * k);</span><br><span class="line">    <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">    <span class="comment">// 先将前2*k*num个元素做反转</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">2</span> * num; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> low = (i - <span class="number">1</span>) * k;</span><br><span class="line">        <span class="keyword">int</span> high = i * k - <span class="number">1</span>;</span><br><span class="line">        reverseChar(chars, low, high);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将剩余的不到2*k个元素反转</span></span><br><span class="line">    <span class="keyword">if</span> (lastNum &gt; k) &#123;</span><br><span class="line">        reverseChar(chars, <span class="number">2</span>*k*num, <span class="number">2</span>*k*num+k-<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reverseChar(chars, <span class="number">2</span>*k*num, len-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符数组反转函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseChar</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">char</span> temp = chars[low];</span><br><span class="line">        chars[low ++] = chars[high];</span><br><span class="line">        chars[high --] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="字符串反转3-557"><a href="#字符串反转3-557" class="headerlink" title="字符串反转3(557)"></a><code>字符串反转3(557)</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目要求: 给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</span></span><br><span class="line"><span class="comment">注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。</span></span><br><span class="line"><span class="comment">示例 1:</span></span><br><span class="line"><span class="comment">输入: "Let's take LeetCode contest"</span></span><br><span class="line"><span class="comment">输出: "s'teL ekat edoCteeL tsetnoc" </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 解法：将字符串按照空格拆分成为字符串数组，然后将每一个字符串翻转，最后将反转的字符串拼接到一起。</span></span><br><span class="line"><span class="comment">// 其中字符串的反转采用的方式为先转换为字符数组，然后反转字符数组。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    String[] split = s.split(<span class="string">"\\s+"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; split.length ; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars = split[i].toCharArray();</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> hig = chars.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; hig) &#123;</span><br><span class="line">            <span class="keyword">char</span> temp = chars[low];</span><br><span class="line">            chars[low ++] = chars[hig];</span><br><span class="line">            chars[hig --] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(chars);</span><br><span class="line">        <span class="keyword">if</span> (i != split.length - <span class="number">1</span>) &#123;</span><br><span class="line">            sb.append(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="字符串反转4-917"><a href="#字符串反转4-917" class="headerlink" title="字符串反转4(917)"></a><code>字符串反转4(917)</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目要求:给定一个字符串 S，返回 “反转后的” 字符串，其中不是字母的字符都保留在原地，而所有字母的位置发生反转。</span></span><br><span class="line"><span class="comment">示例 1：输入："ab-cd"  输出："dc-ba"</span></span><br><span class="line"><span class="comment">示例 2：输入："a-bC-dEf-ghIj" 输出："j-Ih-gfE-dCba"</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseOnlyLetters</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 双指针</span></span><br><span class="line">    StringBuffer buf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">int</span> j = S.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); i ++) &#123;</span><br><span class="line">        <span class="comment">// 位置i上的字符为字母时，可以做交换</span></span><br><span class="line">        <span class="keyword">if</span> (Character.isLetter(S.charAt(i))) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!Character.isLetter(S.charAt(j))) &#123;</span><br><span class="line">                j --;</span><br><span class="line">            &#125;</span><br><span class="line">            buf.append(S.charAt(j --));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            buf.append(S.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buf.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="字符串反转5-345"><a href="#字符串反转5-345" class="headerlink" title="字符串反转5(345)"></a><code>字符串反转5(345)</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目要求:编写一个函数，以字符串作为输入，反转该字符串中的元音字母。</span></span><br><span class="line"><span class="comment">示例 1: 输入: "hello" 输出: "holle"</span></span><br><span class="line"><span class="comment">示例 2: 输入: "leetcode" 输出: "leotcede"</span></span><br><span class="line"><span class="comment">说明: 元音字母不包含字母"y"。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 元音字母集合</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> Set&lt;Character&gt; sets = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="string">'a'</span>, <span class="string">'e'</span>, <span class="string">'i'</span>, <span class="string">'o'</span>, <span class="string">'u'</span>, <span class="string">'A'</span>, <span class="string">'E'</span>, <span class="string">'I'</span>, <span class="string">'O'</span>, <span class="string">'U'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用双指针,当两端同时为元音字母时,交换两个位置的字符。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseVowels</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = s.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!judgeVowel(chars[left])) &#123;</span><br><span class="line">            left ++;</span><br><span class="line">            <span class="keyword">if</span> (left &gt; s.length() -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!judgeVowel(chars[right])) &#123;</span><br><span class="line">            right --;</span><br><span class="line">            <span class="keyword">if</span> (right &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> temp = chars[left];</span><br><span class="line">        chars[left++] = chars[right];</span><br><span class="line">        chars[right--] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="报数问题-38"><a href="#报数问题-38" class="headerlink" title="报数问题(38)"></a><code>报数问题(38)</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目要求：</span></span><br><span class="line"><span class="comment">报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：</span></span><br><span class="line"><span class="comment">1.     1</span></span><br><span class="line"><span class="comment">2.     11</span></span><br><span class="line"><span class="comment">3.     21</span></span><br><span class="line"><span class="comment">4.     1211</span></span><br><span class="line"><span class="comment">5.     111221</span></span><br><span class="line"><span class="comment">说明：上一项报前一项，报数时是按照各数+数字报的。比如：给1报数的是2，报数时时1个1，即为11。给2报数的是3，报的数是11，2个1，即为21。报21时，1个2，1个1，即为1211</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 解法：就是按照规律统计前一项的数字，直到第n项统计出n-1为止。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    String res = <span class="string">"1"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        StringBuffer buf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">char</span> ch = res.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; res.length(); j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == res.charAt(j)) &#123;</span><br><span class="line">                num ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                buf.append(num).append(ch);</span><br><span class="line">                ch = res.charAt(j);</span><br><span class="line">                num = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        buf.append(num).append(ch);</span><br><span class="line">        res = buf.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="二进制求和-67"><a href="#二进制求和-67" class="headerlink" title="二进制求和(67)"></a><code>二进制求和(67)</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目要求：</span></span><br><span class="line"><span class="comment">    给定两个二进制字符串，返回他们的和（用二进制表示）。</span></span><br><span class="line"><span class="comment">    输入为非空字符串且只包含数字 1 和 0。</span></span><br><span class="line"><span class="comment">示例:</span></span><br><span class="line"><span class="comment">   输入: a = "11", b = "1"    输出: "100"</span></span><br><span class="line"><span class="comment">   输入: a = "1010", b = "1011"    输出: "10101"</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 从后往前遍历计算，将计算结果拼接到字符串后面，最后将字符串反转</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addBinaryA</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">    StringBuffer buf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.length() - <span class="number">1</span>, j  = b.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = ans;</span><br><span class="line">        <span class="comment">// 两个字符串长度可能不同，故先遍历完毕的字符串计算值用0代替</span></span><br><span class="line">        sum += (i &gt;= <span class="number">0</span> ? a.charAt(i) - <span class="string">'0'</span> : <span class="number">0</span>);</span><br><span class="line">        sum += (j &gt;= <span class="number">0</span> ? b.charAt(j) - <span class="string">'0'</span> : <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 拼接</span></span><br><span class="line">        buf.append(sum % <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 进位</span></span><br><span class="line">        ans = sum / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buf.append(ans == <span class="number">1</span> ? ans : <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> buf.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="验证回文串-125"><a href="#验证回文串-125" class="headerlink" title="验证回文串(125)"></a><code>验证回文串(125)</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目要求： 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</span></span><br><span class="line"><span class="comment">说明：本题中，我们将空字符串定义为有效的回文串。</span></span><br><span class="line"><span class="comment">示例：</span></span><br><span class="line"><span class="comment">  输入: "A man, a plan, a canal: Panama"    输出: true</span></span><br><span class="line"><span class="comment">  输入: "race a car"    输出: false</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindromeA</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.trim().length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将字符串转小写</span></span><br><span class="line">    String param = s.toLowerCase();</span><br><span class="line">    <span class="keyword">int</span> length = param.length();</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 左右两个指针遍历，相遇结束</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 从左起，定位到第一个字母或是数字</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; !isSuitable(param.charAt(left))) &#123;</span><br><span class="line">            left ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从右起，定位到第一个字母或是数字</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; !isSuitable(param.charAt(right))) &#123;</span><br><span class="line">            right --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不符合条件，返回false</span></span><br><span class="line">        <span class="keyword">if</span> (param.charAt(left ++) != param.charAt(right --)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判定给定的字符是否为字母或数字</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSuitable</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Character.isLetter(c) || Character.isDigit(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="有效括号-20"><a href="#有效括号-20" class="headerlink" title="有效括号(20)"></a><code>有效括号(20)</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目要求：</span></span><br><span class="line"><span class="comment">给定一个只包括 '('，')'，'&#123;'，'&#125;'，'['，']' 的字符串，判断字符串是否有效。</span></span><br><span class="line"><span class="comment">有效字符串需满足：</span></span><br><span class="line"><span class="comment">  左括号必须用相同类型的右括号闭合。</span></span><br><span class="line"><span class="comment">  左括号必须以正确的顺序闭合。</span></span><br><span class="line"><span class="comment">  注意空字符串可被认为是有效字符串。</span></span><br><span class="line"><span class="comment">示例:  输入: "()"  输出: true</span></span><br><span class="line"><span class="comment">      输入: "()[]&#123;&#125;" 输出: true</span></span><br><span class="line"><span class="comment">      输入: "(]"   输出: false</span></span><br><span class="line"><span class="comment">      输入: "([)]"  输出: false</span></span><br><span class="line"><span class="comment">      输入: "&#123;[]&#125;"  输出: true </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 解法：使用栈来操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 规律：对应的括号只有可能在紧邻的一位或者对称的位置找到</span></span><br><span class="line">    <span class="comment">// 空字符串直接返回 true</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.trim().length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> length = s.length();</span><br><span class="line">    <span class="comment">// 非2的偶数倍，直接返回false</span></span><br><span class="line">    <span class="keyword">if</span> (length % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过定义stack来实现，遇到左括号放入到stack中，遇到右括号从stack中弹出元素与之对比</span></span><br><span class="line">    <span class="comment">// 这种的扩展性较好，但是要引入HashMap,并且要匹配key,所以时间复杂度和空间复杂度都没下面的好</span></span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;Character&gt;();</span><br><span class="line">    Map&lt;Character, Character&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Character&gt;();</span><br><span class="line">    map.put(<span class="string">'('</span>, <span class="string">')'</span>);</span><br><span class="line">    map.put(<span class="string">'&#123;'</span>, <span class="string">'&#125;'</span>);</span><br><span class="line">    map.put(<span class="string">'['</span>, <span class="string">']'</span>);</span><br><span class="line">    Set&lt;Character&gt; keys = map.keySet();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length; j ++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(j);</span><br><span class="line">        <span class="keyword">if</span> (keys.contains(c)) &#123;</span><br><span class="line">            stack.push(c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty() ||  map.get(stack.pop()) != c) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下面这种时间复杂度和空间复杂度都要由于上面的，但是扩展性不好</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; length; i ++) &#123;</span></span><br><span class="line"><span class="comment">            char c = s.charAt(i);</span></span><br><span class="line"><span class="comment">            switch(c) &#123;</span></span><br><span class="line"><span class="comment">                case '(':</span></span><br><span class="line"><span class="comment">                case '&#123;':</span></span><br><span class="line"><span class="comment">                case '[':</span></span><br><span class="line"><span class="comment">                    stack.push(c);</span></span><br><span class="line"><span class="comment">                    break;</span></span><br><span class="line"><span class="comment">                case ')':</span></span><br><span class="line"><span class="comment">                    if (stack.isEmpty() || stack.pop() != '(') &#123;</span></span><br><span class="line"><span class="comment">                        return false;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                    continue;</span></span><br><span class="line"><span class="comment">                case '&#125;':</span></span><br><span class="line"><span class="comment">                    if (stack.isEmpty() || stack.pop() != '&#123;') &#123;</span></span><br><span class="line"><span class="comment">                        return false;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                    continue;</span></span><br><span class="line"><span class="comment">                case ']':</span></span><br><span class="line"><span class="comment">                    if (stack.isEmpty() || stack.pop() != '[') &#123;</span></span><br><span class="line"><span class="comment">                        return false;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                    continue;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            &#125; </span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="无重复字符的最长子串-3"><a href="#无重复字符的最长子串-3" class="headerlink" title="无重复字符的最长子串(3)"></a><code>无重复字符的最长子串(3)</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 滑动窗口解法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = s.length();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">    Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">    <span class="keyword">while</span>(left &lt; length &amp;&amp; right &lt; length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!set.contains(s.charAt(right))) &#123;</span><br><span class="line">            set.add(s.charAt(right ++));</span><br><span class="line">            ans = Math.max(ans, right - left);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            set.remove(s.charAt(left ++));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="最长回文子串-5"><a href="#最长回文子串-5" class="headerlink" title="最长回文子串(5)"></a><code>最长回文子串(5)</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 题目要求:给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</span></span><br><span class="line"><span class="comment">// 1.要判断一个字符串是否为回文字符串，可以通过下面几种方式来实现</span></span><br><span class="line"><span class="comment">// 第一种:通过栈的后进先出原理，将字符串翻转来对比前后两个字符串是否一致</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isHuiWen1</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        stack.push(str.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuffer buf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        buf.append(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (str.equals(buf.toString())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二种: 取消栈的引入，直接通过逆序输出拼接字符串(减少了额外的空间Stack)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isHuiWen2</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    StringBuffer buf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = str.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">        buf.append(str.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (buf.toString().equals(str)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第三中: 基于回文串左右两边两个字符相等的规律，定义两个变量做对比(优势是减少了字符串str的遍历次数，时间复杂度降低)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isHuiWen3</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = str.length();</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(str.charAt(left) == str.charAt(right))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        left ++;</span><br><span class="line">        right --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前这道题如何实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 给定一个字符串s,找到s中最长的回文子串。你可以假设s的最大长度为1000。</span></span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> resultLen = <span class="number">1</span>;</span><br><span class="line">    String resultStr = s.substring(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">        <span class="comment">// 从中间向两边查找对称的回文串</span></span><br><span class="line">        String oddStr = spread(s, len, i, i);</span><br><span class="line">        String evenStr = spread(s, len, i, i+<span class="number">1</span>);</span><br><span class="line">        String myStr = oddStr.length() &gt;= evenStr.length() ? oddStr : evenStr;</span><br><span class="line">        <span class="keyword">if</span> (myStr.length() &gt; resultLen) &#123;</span><br><span class="line">            resultStr = myStr;</span><br><span class="line">            resultLen = resultStr.length();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultStr;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">spread</span><span class="params">(String s, <span class="keyword">int</span> len, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = left;</span><br><span class="line">    <span class="keyword">int</span> r = right;</span><br><span class="line">    <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; len &amp;&amp; (s.charAt(l) == s.charAt(r))) &#123;</span><br><span class="line">        l --;</span><br><span class="line">        r ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(l+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="压缩字符串-443"><a href="#压缩字符串-443" class="headerlink" title="压缩字符串(443)"></a><code>压缩字符串(443)</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 题目要求: 给定一组字符串，使用原地算法将其压缩。</span></span><br><span class="line"><span class="comment">// 题目解法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compress</span><span class="params">(<span class="keyword">char</span>[] chars)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> anchor = <span class="number">0</span>; <span class="comment">// 描点，定位可以元素</span></span><br><span class="line">    <span class="keyword">int</span> write = <span class="number">0</span>; <span class="comment">// 写下标，定位写的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> read = <span class="number">0</span>; read &lt; chars.length; read ++) &#123;</span><br><span class="line">        <span class="comment">// 若是当前元素为最后一个元素或者是后一个元素与当前元素不相等，执行写入与统计写入操作</span></span><br><span class="line">        <span class="keyword">if</span> ((read == chars.length - <span class="number">1</span>) || (chars[read + <span class="number">1</span>] != chars[read])) &#123;</span><br><span class="line">            <span class="comment">// 将anchor位置处的元素写入到write位置处</span></span><br><span class="line">            chars[write ++] = chars[anchor];</span><br><span class="line">            <span class="comment">// 判断该元素是否需要压缩</span></span><br><span class="line">            <span class="keyword">if</span> (read &gt; anchor) &#123;</span><br><span class="line">                String numStr = read - anchor + <span class="number">1</span> + <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">char</span>[] numArr = numStr.toCharArray();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> num : numArr) &#123;</span><br><span class="line">                    chars[write ++] = num;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将锚点移动到下一个元素</span></span><br><span class="line">            anchor = read + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回覆盖的个数</span></span><br><span class="line">    <span class="keyword">return</span> write;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="字符串中的第一个唯一字符-387"><a href="#字符串中的第一个唯一字符-387" class="headerlink" title="字符串中的第一个唯一字符(387)"></a><code>字符串中的第一个唯一字符(387)</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目要求: 给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</span></span><br><span class="line"><span class="comment">说明: 你可以假设字符串只含有小写字母。</span></span><br><span class="line"><span class="comment">示例: s = "leetcode" 返回 0.s = "loveleetcode" 返回 2.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 第一中解法，遍历两次字符串，哈希表存储每个字符和其出现的个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstUniqCharA</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(s.charAt(i))) &#123;</span><br><span class="line">            map.put(s.charAt(i), <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(s.charAt(i), map.get(s.charAt(i)) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s.length(); j ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.get(s.charAt(j)) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种解法: 仅遍历26个字母，唯一的特征：第一个字符和最后一个字符的index相同</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstUniqCharB</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] originalChar = <span class="string">"abcdefghijklmnopqrstuvwxyz"</span>.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> index = s.length();</span><br><span class="line">    <span class="comment">// 此处循环26次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : originalChar) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = s.indexOf(c);</span><br><span class="line">        <span class="keyword">if</span> (left != -<span class="number">1</span> &amp;&amp; left == s.lastIndexOf(c)) &#123;</span><br><span class="line">            index = Math.min(index, left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(index != s.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="赎金信-383"><a href="#赎金信-383" class="headerlink" title="赎金信(383)"></a><code>赎金信(383)</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目要求: 给出两个字符串，用第二个字符串中的字符拼接成为第一个字符串，每个字符只能使用一次。可以返回true，否则返回false。</span></span><br><span class="line"><span class="comment">说明: 你可以假设两个字符串均只含有小写字母。</span></span><br><span class="line"><span class="comment">实例：</span></span><br><span class="line"><span class="comment">canConstruct("a", "b") -&gt; false  </span></span><br><span class="line"><span class="comment">canConstruct("aa", "ab") -&gt; false</span></span><br><span class="line"><span class="comment">canConstruct("aa", "aab") -&gt; true</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一个字符串里面的字符能不能由第二个字符串里面的字符构成，若可以，返回true。否则返回false。</span></span><br><span class="line">    <span class="comment">// 将26 个字母个数映射到一个26大小的数组上</span></span><br><span class="line">    <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; magazine.length(); i ++) &#123;</span><br><span class="line">        bucket[magazine.charAt(i) - <span class="string">'a'</span>] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ransomNote.length(); j ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (-- bucket[ransomNote.charAt(j) - <span class="string">'a'</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problemset/algorithms/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目来自leetcode&lt;/a&gt;&lt;/p&gt;
&lt;h6 id=&quot;字符串反转1-344&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="算法" scheme="https://zhilongao.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串" scheme="https://zhilongao.github.io/categories/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
  </entry>
  
  <entry>
    <title>array-ask</title>
    <link href="https://zhilongao.github.io/wiki/alg-array-simple1/"/>
    <id>https://zhilongao.github.io/wiki/alg-array-simple1/</id>
    <published>2019-09-05T01:52:30.000Z</published>
    <updated>2019-09-25T11:41:41.275Z</updated>
    
    <content type="html"><![CDATA[<h6 id="寻找递增序列"><a href="#寻找递增序列" class="headerlink" title="寻找递增序列"></a><code>寻找递增序列</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给定一个未经过排序的数组，找到最长且连续的递增序列(在美团面试题中出现过-leetcode674题)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> curr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            curr ++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            max = Math.max(max, curr);</span><br><span class="line">        curr = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(max, curr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;寻找递增序列&quot;&gt;&lt;a href=&quot;#寻找递增序列&quot; class=&quot;headerlink&quot; title=&quot;寻找递增序列&quot;&gt;&lt;/a&gt;&lt;code&gt;寻找递增序列&lt;/code&gt;&lt;/h6&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t
      
    
    </summary>
    
      <category term="算法" scheme="https://zhilongao.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数组" scheme="https://zhilongao.github.io/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/"/>
    
    
  </entry>
  
  <entry>
    <title>mongodb-base</title>
    <link href="https://zhilongao.github.io/wiki/mongodb-base/"/>
    <id>https://zhilongao.github.io/wiki/mongodb-base/</id>
    <published>2019-09-03T03:45:03.000Z</published>
    <updated>2019-09-24T11:49:12.228Z</updated>
    
    <content type="html"><![CDATA[<h6 id="安装步骤-centos7"><a href="#安装步骤-centos7" class="headerlink" title="安装步骤(centos7)"></a><code>安装步骤(centos7)</code></h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1.下载安装包</span><br><span class="line">wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel62-3.2.10.tgz</span><br><span class="line">2.解压安装包</span><br><span class="line">tar -zxvf mongodb-linux-x86_64-rhel62-3.2.10.tgz </span><br><span class="line">3.将解压目录移动到(/usr/local/mongodb)</span><br><span class="line">mv mongodb-linux-x86_64-rhel62-3.2.10 /usr/local/mongodb</span><br><span class="line">4.在/usr/local/mongodb目录下创建/data/db目录和/logs目录</span><br><span class="line">mkdir -p /usr/local/mongodb/data/db </span><br><span class="line">mkdir -p /usr/local/mongodb/logs</span><br><span class="line">5.在/usr/local/mongodb/logs目录下创建mongodb.log文件</span><br><span class="line">touch mongodb.log</span><br><span class="line">6.在/usr/local/mongodb/bin目录下创建mongodb的配置文件</span><br><span class="line">touch mongodb.conf</span><br><span class="line">7.编辑mongodb.conf文件</span><br><span class="line">vi mongodb.conf</span><br><span class="line">编辑内容</span><br><span class="line">dbpath = /usr/local/mongodb/data/db #数据文件存放目录</span><br><span class="line">logpath = /usr/local/mongodb/logs/mongodb.log #日志文件存放目录</span><br><span class="line">port = 27017  #端口</span><br><span class="line">fork = true  #以守护程序的方式启用，即在后台运行</span><br><span class="line">nohttpinterface = true</span><br><span class="line">auth=true</span><br><span class="line">bind_ip=0.0.0.0</span><br><span class="line">8.修改环境变量</span><br><span class="line">vi /etc/profile</span><br><span class="line">添加的内容</span><br><span class="line">export MONGODB_HOME=/usr/local/mongodb</span><br><span class="line">export PATH=$PATH:$MONGODB_HOME/bin</span><br><span class="line">9.编辑完成之后重启系统配置</span><br><span class="line">source /etc/profile</span><br><span class="line">10.在/usr/local/mongodb/bin目录下启动mongodb</span><br><span class="line">./mongod -f mongodb.conf</span><br><span class="line">11.关闭mongodb服务</span><br><span class="line">./mongod -f ./mongodb.conf --shutdown</span><br><span class="line">12.开启27017端口</span><br><span class="line"></span><br><span class="line">13.使用shell登录到mongodb</span><br><span class="line">./mongodb</span><br><span class="line"></span><br><span class="line">14.登录到相关数据库</span><br><span class="line">use test</span><br><span class="line"></span><br><span class="line">15.创建用户</span><br><span class="line">db.createUser(</span><br><span class="line">&#123;</span><br><span class="line">user: "test", </span><br><span class="line">pwd: "test", </span><br><span class="line">roles: [&#123; role: "readWrite", db: "test" &#125;]</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line">16.修改配置，开启验证</span><br><span class="line">auth=true</span><br><span class="line">17.重启服务</span><br><span class="line">停止服务，然后启动</span><br><span class="line">18.登录</span><br><span class="line">./mongodb</span><br><span class="line">19.验证</span><br><span class="line">auth('test', 'test')(返回1代表成功)</span><br><span class="line">20.操作</span><br><span class="line">db.user.find()</span><br><span class="line">db.user.insert(&#123;"name":'jack',"age": 12&#125;)</span><br></pre></td></tr></table></figure><h6 id="基本操作-gt-java-api的crud"><a href="#基本操作-gt-java-api的crud" class="headerlink" title="基本操作-&gt;java api的crud"></a><code>基本操作-&gt;java api的crud</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 引入依赖</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.mongodb&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mongo-java-driver&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.9.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.java代码</span><br><span class="line"><span class="comment">// 工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MongoUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String baseUrl = <span class="string">"192.168.25.147:27017"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String userName = <span class="string">"test"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String passWord = <span class="string">"test"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String url = <span class="string">"mongodb://"</span>+ userName +<span class="string">":"</span>+ passWord + <span class="string">"@"</span>+ baseUrl + <span class="string">"/"</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 获取MongoDatabase</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MongoDatabase <span class="title">getConnection</span><span class="params">(String dataName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取MongoClient</span></span><br><span class="line">        com.mongodb.client.MongoClient mongoClient = MongoClients.create(url + dataName);</span><br><span class="line">        <span class="comment">// 获取MongoDatabase</span></span><br><span class="line">        MongoDatabase db = mongoClient.getDatabase(dataName);</span><br><span class="line">        <span class="keyword">return</span> db;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本操作 -&gt; 获取所有</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findAll</span><span class="params">(String databaseName, String collectionName)</span> </span>&#123;</span><br><span class="line">MongoDatabase database = MongoUtil.getConnection(databaseName);</span><br><span class="line">    MongoCollection&lt;Document&gt; collection = database.getCollection(collectionName);</span><br><span class="line">    FindIterable&lt;Document&gt; documents = collection.find();</span><br><span class="line">    print(documents);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本操作 -&gt; 插入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String databaseName, String collectionName)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取database</span></span><br><span class="line">MongoDatabase database = MongoUtil.getConnection(databaseName);</span><br><span class="line"><span class="comment">// 获取Clooection</span></span><br><span class="line">MongoCollection&lt;Document&gt; collection = database.getCollection(collectionName);</span><br><span class="line"><span class="comment">// 创建Document</span></span><br><span class="line">Document document = <span class="keyword">new</span> Document()</span><br><span class="line">                    .append(<span class="string">"name"</span>, <span class="string">"mick11"</span>)</span><br><span class="line">                    .append(<span class="string">"age"</span>, <span class="string">"33"</span>)</span><br><span class="line">                    .append(<span class="string">"address"</span>, <span class="string">"长沙"</span>)</span><br><span class="line">                    .append(<span class="string">"sex"</span>, <span class="string">"男"</span>);</span><br><span class="line">    <span class="comment">// 插入document                </span></span><br><span class="line">collection.insertOne(document);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印所有</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(FindIterable&lt;Document&gt; documents)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (Document document : documents) &#123;</span><br><span class="line">System.out.println(document.toJson());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;安装步骤-centos7&quot;&gt;&lt;a href=&quot;#安装步骤-centos7&quot; class=&quot;headerlink&quot; title=&quot;安装步骤(centos7)&quot;&gt;&lt;/a&gt;&lt;code&gt;安装步骤(centos7)&lt;/code&gt;&lt;/h6&gt;&lt;figure class=&quot;hig
      
    
    </summary>
    
      <category term="数据库" scheme="https://zhilongao.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mongodb" scheme="https://zhilongao.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb/"/>
    
    
      <category term="mongo" scheme="https://zhilongao.github.io/tags/mongo/"/>
    
  </entry>
  
  <entry>
    <title>实际应用</title>
    <link href="https://zhilongao.github.io/wiki/redis-advance/"/>
    <id>https://zhilongao.github.io/wiki/redis-advance/</id>
    <published>2019-09-02T00:47:25.000Z</published>
    <updated>2019-09-24T11:51:45.844Z</updated>
    
    <content type="html"><![CDATA[<h6 id="list实现分布式队列"><a href="#list实现分布式队列" class="headerlink" title="list实现分布式队列"></a><code>list实现分布式队列</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需要的依赖jedis fastjson</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.9.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line"> &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.2.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/8 15:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String url = <span class="string">"192.168.25.150"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> port = <span class="number">6379</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构建queue</span></span><br><span class="line">        String queueKey = <span class="string">"message_queue"</span>;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(url, port);</span><br><span class="line">        <span class="comment">// 消息转换器</span></span><br><span class="line">        MessageConvert&lt;TaskItem&gt; convert = <span class="keyword">new</span> MessageConvert&lt;&gt;();</span><br><span class="line">        <span class="comment">// 消息队列</span></span><br><span class="line">        RedisQueue queue = <span class="keyword">new</span> RedisQueue(jedis, queueKey, convert);</span><br><span class="line">        <span class="comment">// 生产者</span></span><br><span class="line">        MessageProducer producer = <span class="keyword">new</span> MessageProducer(queue);</span><br><span class="line">        <span class="comment">// 消费者</span></span><br><span class="line">        MessageConsumer consumer = <span class="keyword">new</span> MessageConsumer(queue);</span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息队列</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/8 14:34</span></span><br><span class="line"><span class="comment"> * 分布式消息队列-list实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line">    <span class="keyword">private</span> String queueKey;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisQueue</span><span class="params">(Jedis jedis, String queueKey, MessageConvert messageConvert)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jedis = jedis;</span><br><span class="line">        <span class="keyword">this</span>.queueKey = queueKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.jedis.lpush(queueKey, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费消息-&gt;可重试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">poll</span><span class="params">(<span class="keyword">boolean</span> isRetry)</span> </span>&#123;</span><br><span class="line">        String message = jedis.rpop(queueKey);</span><br><span class="line">        <span class="keyword">if</span> (message == <span class="keyword">null</span> &amp;&amp; isRetry) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            message = jedis.rpop(queueKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/8 15:47</span></span><br><span class="line"><span class="comment"> * 消息生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageProducer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 队列</span></span><br><span class="line">    <span class="keyword">private</span> RedisQueue queue;</span><br><span class="line">    <span class="comment">// 消息转换器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MessageConvert&lt;TaskItem&gt; convert = <span class="keyword">new</span> MessageConvert&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageProducer</span><span class="params">(RedisQueue queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            send(<span class="string">"message:"</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">30</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并发送消息</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一条消息</span></span><br><span class="line">        TaskItem item = <span class="keyword">new</span> TaskItem();</span><br><span class="line">        item.id = UUID.randomUUID().toString();</span><br><span class="line">        item.msg = message;</span><br><span class="line">        <span class="comment">// 转换为字符串发送</span></span><br><span class="line">        String sendMess = convert.messageToString(item);</span><br><span class="line">        queue.push(sendMess);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/8 15:48</span></span><br><span class="line"><span class="comment"> * 消息消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageConsumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RedisQueue queue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageConsumer</span><span class="params">(RedisQueue queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(random.nextInt(<span class="number">10</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            receive();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object object = queue.poll(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (object != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/8 15:45</span></span><br><span class="line"><span class="comment"> * 消息转换器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageConvert</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Type taskType = <span class="keyword">new</span> TypeReference&lt;T&gt;() &#123;&#125;.getType();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将给定的消息转换为string类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">messageToString</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JSON.toJSONString(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将string类型的消息转换为T类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">stringToObject</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JSON.parseObject(message, taskType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="zset实现延时队列"><a href="#zset实现延时队列" class="headerlink" title="zset实现延时队列"></a><code>zset实现延时队列</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delayQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(url, port);</span><br><span class="line">    <span class="comment">// 延时队列</span></span><br><span class="line">    RedisDelayingQueue queue = <span class="keyword">new</span> RedisDelayingQueue(jedis, <span class="string">"q-demo"</span>);</span><br><span class="line">    DelayMessageConsumer consumer = <span class="keyword">new</span> DelayMessageConsumer(queue);</span><br><span class="line">    DelayMessageProducer producer = <span class="keyword">new</span> DelayMessageProducer(queue);</span><br><span class="line">    producer.start();</span><br><span class="line">    consumer.start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 首先让producer线程执行完成</span></span><br><span class="line">        producer.join();</span><br><span class="line">        <span class="comment">// 主线程睡眠6秒，等待consumer将消息消费完成</span></span><br><span class="line">        Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">        consumer.interrupt();</span><br><span class="line">        consumer.join();</span><br><span class="line">    &#125;  <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/7 16:56</span></span><br><span class="line"><span class="comment"> * 延时队列-&gt; 通过zset实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisDelayingQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line">    <span class="keyword">private</span> String queueKey;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisDelayingQueue</span><span class="params">(Jedis jedis, String queueKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jedis = jedis;</span><br><span class="line">        <span class="keyword">this</span>.queueKey = queueKey;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 执行消息的发送</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delay</span><span class="params">(String msg, <span class="keyword">long</span> score)</span> </span>&#123;</span><br><span class="line">        jedis.zadd(queueKey, score, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行消息的处理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">(MessageHandle handle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">            <span class="comment">// fixme 此处需要优化，保证操作的原子性</span></span><br><span class="line">            <span class="comment">// 获取一条数据(score最小的那条数据)</span></span><br><span class="line">            Set values = jedis.zrangeByScore(queueKey, <span class="number">0</span>, System.currentTimeMillis(), <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 若是队列中没有任务，线程睡眠500毫秒</span></span><br><span class="line">            <span class="keyword">if</span> (values.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String value = (String) values.iterator().next();</span><br><span class="line">            <span class="comment">// 从queueKey中移除该元素</span></span><br><span class="line">            <span class="keyword">if</span> (jedis.zrem(queueKey, value) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 将消息交给回调接口来处理</span></span><br><span class="line">                handle.handle(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/8 17:13</span></span><br><span class="line"><span class="comment"> * 延时队列-生产者线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayMessageProducer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    RedisDelayingQueue queue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelayMessageProducer</span><span class="params">(RedisDelayingQueue queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) &#123;</span><br><span class="line">            String message = <span class="string">"message:"</span>+ i;</span><br><span class="line">            <span class="keyword">long</span> score = random.nextInt(<span class="number">10</span>);</span><br><span class="line">            send(message, score);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String msg, <span class="keyword">long</span> delay)</span> </span>&#123;</span><br><span class="line">        TaskItem task = <span class="keyword">new</span> TaskItem();</span><br><span class="line">        task.id = UUID.randomUUID().toString();</span><br><span class="line">        task.msg = msg;</span><br><span class="line">        String message = JSON.toJSONString(task);</span><br><span class="line">        queue.delay(message, delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/8 17:11</span></span><br><span class="line"><span class="comment"> * 延时队列消费者线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayMessageConsumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    RedisDelayingQueue queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> MessageHandle handle = <span class="keyword">new</span> MessageHandle() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">            System.out.println(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelayMessageConsumer</span><span class="params">(RedisDelayingQueue queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue.loop(handle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/8 17:21</span></span><br><span class="line"><span class="comment"> * 消息处理回调接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageHandle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(String item)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;list实现分布式队列&quot;&gt;&lt;a href=&quot;#list实现分布式队列&quot; class=&quot;headerlink&quot; title=&quot;list实现分布式队列&quot;&gt;&lt;/a&gt;&lt;code&gt;list实现分布式队列&lt;/code&gt;&lt;/h6&gt;&lt;figure class=&quot;highlight
      
    
    </summary>
    
      <category term="数据库" scheme="https://zhilongao.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="redis" scheme="https://zhilongao.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/"/>
    
    
  </entry>
  
  <entry>
    <title>单链表</title>
    <link href="https://zhilongao.github.io/wiki/alg-linkedlist-simple1/"/>
    <id>https://zhilongao.github.io/wiki/alg-linkedlist-simple1/</id>
    <published>2019-08-31T03:56:40.000Z</published>
    <updated>2019-09-25T11:42:36.482Z</updated>
    
    <content type="html"><![CDATA[<p><code>单链表常见操作</code></p><p><code>1.如何实现一个单链表的逆序输出-&gt;反转单链表</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">    ListNode next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span> &amp;&amp; (next = head.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    head.next = prev;</span><br><span class="line">        prev = head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    head.next = prev;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;单链表常见操作&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1.如何实现一个单链表的逆序输出-&amp;gt;反转单链表&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;
      
    
    </summary>
    
      <category term="算法" scheme="https://zhilongao.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="https://zhilongao.github.io/categories/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="https://zhilongao.github.io/wiki/alg-sort-simple/"/>
    <id>https://zhilongao.github.io/wiki/alg-sort-simple/</id>
    <published>2019-08-31T01:19:15.000Z</published>
    <updated>2019-09-25T11:41:18.975Z</updated>
    
    <content type="html"><![CDATA[<p><code>常见的排序算法</code></p><p><code>1.插入排序</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入排序算法</span></span><br><span class="line"><span class="comment">// 时间复杂度：平均情况:o(n^2)  最好情况:o(n) 最坏情况:o(n^2) </span></span><br><span class="line"><span class="comment">// 空间复杂度: o(1)</span></span><br><span class="line"><span class="comment">// 特点: 稳定</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; array.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = array[i];</span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;=<span class="number">0</span> &amp;&amp; array[j] &gt; temp; j --) &#123;</span><br><span class="line">            <span class="comment">// 将数组中的元素后移一位</span></span><br><span class="line">            array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">        &#125;</span><br><span class="line">        array[j + <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>2.选择排序</code></p><p><code>原理</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 选择排序算法</span></span><br><span class="line"><span class="comment">// 时间复杂度: 平均情况:o(n^2)  最好情况:o(n^2) 最坏情况:o(n^2)  </span></span><br><span class="line"><span class="comment">// 空间复杂度: o(1)</span></span><br><span class="line"><span class="comment">// 特点: 不稳定</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; array.length; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &gt; array[j]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = array[i];</span><br><span class="line">                array[i] = array[j];</span><br><span class="line">                array[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>3.交换排序-&gt;冒泡排序</code></p><p><code>原理</code></p><p><img src="https://raw.githubusercontent.com/zhilongao/images-repository/master/006y8mN6ly1g6mbx8snqyg30my075wqv.gif" alt="冒泡排序"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序算法</span></span><br><span class="line"><span class="comment">// 时间复杂度: 平均情况:o(n^2)  最好情况:o(n) 最坏情况:o(n^2)</span></span><br><span class="line"><span class="comment">// 空间复杂度: o(1)</span></span><br><span class="line"><span class="comment">// 特点：稳定</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - i - <span class="number">1</span>; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = array[j];</span><br><span class="line">                array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">                array[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>4.交换排序-&gt;快速排序</code></p><p><code>原理</code></p><p><img src="https://raw.githubusercontent.com/zhilongao/images-repository/master/7789414-007520d3d4a7610c.gif" alt="快速排序"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快速排序算法</span></span><br><span class="line"><span class="comment">// 时间复杂度: 平均情况:o(nlog2^n) 最好情况:o(nlog2^n) 最坏情况:o(n^2)</span></span><br><span class="line"><span class="comment">// 空间复杂度: o(nlog2^n)</span></span><br><span class="line"><span class="comment">// 特点：不稳定</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fastSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &gt; high) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = low;</span><br><span class="line">    <span class="keyword">int</span> j = fast;</span><br><span class="line">    <span class="keyword">int</span> temp = array[low];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="comment">// 从右向左找到第一个小于temp的元素,保存其下标</span></span><br><span class="line">        <span class="keyword">while</span> (array[j] &gt; temp &amp;&amp; i &lt; j) &#123;</span><br><span class="line">            j --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从左向右找到第一个大于temp的元素，保存其下标</span></span><br><span class="line">        <span class="keyword">while</span> (array[i] &lt;= temp &amp;&amp; i &lt; j) &#123;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换这两个元素</span></span><br><span class="line">        <span class="keyword">int</span> swap = array[i];</span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        array[j] = swap;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 交换temp</span></span><br><span class="line">    array[low] = array[i];</span><br><span class="line">    array[i] = temp;</span><br><span class="line">    <span class="comment">// 快排temp左半边</span></span><br><span class="line">    fastSort(array, low, j - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 快排temp右半边</span></span><br><span class="line">    fastSort(array, j + <span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>5.归并排序</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 归并排序算法</span></span><br><span class="line"><span class="comment">// 时间复杂度: 平均情况:o(nlog2^n) 最好情况:o(nlog2^n) 最坏情况:o(nlog2^n)</span></span><br><span class="line"><span class="comment">// 空间复杂度：o(1)</span></span><br><span class="line"><span class="comment">// 特点: 稳定</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">sortMerge</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    sort(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> array[], <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (R + L) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 排序左半部分</span></span><br><span class="line">    sort(array, L, mid);</span><br><span class="line">    <span class="comment">// 排序右半部分</span></span><br><span class="line">    sort(array, mid + <span class="number">1</span>, R);</span><br><span class="line">    <span class="comment">// 合并 </span></span><br><span class="line">    merge(array, L, mid, R);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> L, <span class="keyword">int</span> mid, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[R - L + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = L;</span><br><span class="line">    <span class="keyword">int</span> p2 = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 将数组排序后放入到临时数组temp中</span></span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= R) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[p1] &lt; array[p2]) &#123;</span><br><span class="line">            temp[i++] = array[p1++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[i++] = array[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p1 &lt;= mid) &#123;</span><br><span class="line">        temp[i++] = array[p1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p2 &lt;= R) &#123;</span><br><span class="line">        temp[i++] = array[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将临时数组中的元素移动到array中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; temp.length; k ++) &#123;</span><br><span class="line">        array[L + k] = temp[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;常见的排序算法&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1.插入排序&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;s
      
    
    </summary>
    
      <category term="算法" scheme="https://zhilongao.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="https://zhilongao.github.io/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>jvm-command</title>
    <link href="https://zhilongao.github.io/wiki/jvm-command/"/>
    <id>https://zhilongao.github.io/wiki/jvm-command/</id>
    <published>2019-08-29T09:01:23.000Z</published>
    <updated>2019-08-31T04:00:56.547Z</updated>
    
    <content type="html"><![CDATA[<hr><p><code>jvm基本指令</code></p><table><thead><tr><th>基本指令</th><th>指令说明</th></tr></thead><tbody><tr><td>iconst_1</td><td>int型常量值1进栈</td></tr><tr><td>bipush</td><td>将一个byte型常量值推送至栈顶</td></tr><tr><td>iload_1</td><td>第二个int型局部变量进栈，从0开始计数</td></tr><tr><td>istore_1</td><td><em>将栈顶int型数值存入第二个局部变量，从<strong>0</strong>开始计数</em></td></tr><tr><td></td><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;&lt;code&gt;jvm基本指令&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;基本指令&lt;/th&gt;
&lt;th&gt;指令说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;iconst_1&lt;/td&gt;
&lt;td&gt;int型常量值1进
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="基础" scheme="https://zhilongao.github.io/categories/java/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="jvm" scheme="https://zhilongao.github.io/categories/java/%E5%9F%BA%E7%A1%80/jvm/"/>
    
    
  </entry>
  
  <entry>
    <title>dubbo</title>
    <link href="https://zhilongao.github.io/wiki/dubbo-ask/"/>
    <id>https://zhilongao.github.io/wiki/dubbo-ask/</id>
    <published>2019-08-28T11:57:42.000Z</published>
    <updated>2019-08-28T12:21:39.474Z</updated>
    
    <content type="html"><![CDATA[<p><code>协议</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;协议&lt;/code&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="分布式" scheme="https://zhilongao.github.io/categories/java/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>博客</title>
    <link href="https://zhilongao.github.io/wiki/share-articles/"/>
    <id>https://zhilongao.github.io/wiki/share-articles/</id>
    <published>2019-08-27T13:38:52.000Z</published>
    <updated>2019-09-10T06:31:34.768Z</updated>
    
    <content type="html"><![CDATA[<p><code>友情链接</code></p><p><a href="https://yapengren.github.io/" target="_blank" rel="noopener">任亚鹏的博客</a></p><p><code>技术大牛</code></p><p><a href="https://mercyblitz.github.io" target="_blank" rel="noopener">小马哥</a></p><p><code>精彩社区</code></p><p><a href="https://tech.meituan.com/" target="_blank" rel="noopener">美团技术团队</a></p><hr><p><a href="https://www.v2ex.com/" target="_blank" rel="noopener">v2ex</a></p><hr><p><a href="https://juejin.im/timeline" target="_blank" rel="noopener">掘金</a></p><hr><p><a href="http://cmsblogs.com/" target="_blank" rel="noopener">java技术驿站</a></p><hr><p><a href="https://www.infoq.cn/" target="_blank" rel="noopener">infoq</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;友情链接&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://yapengren.github.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;任亚鹏的博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;技术大牛&lt;/code&gt;&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>分库分表</title>
    <link href="https://zhilongao.github.io/wiki/mysql-split/"/>
    <id>https://zhilongao.github.io/wiki/mysql-split/</id>
    <published>2019-08-27T09:08:54.000Z</published>
    <updated>2019-09-24T11:51:06.311Z</updated>
    
    <content type="html"><![CDATA[<hr><p><code>数据库优化之分库分表</code></p><hr><p>针对数据库的优化有两点，第一是从整体层面优化，设计到读写分离和分库分表。第二是从sql层面优化，主要是涉及到索引相关的一些东西。</p><hr><p><code>读写分离</code></p><p>​    <code>需求</code>: 读写分离的目的是做数据冗余备份，同时将读写分离，提升数据库的服务性能（IO性能瓶颈）。</p><p>​    <code>搭建过程</code>: 在基本操作里面-&gt;mysql配置主从同步的步骤 。</p><p>​    <code>实现原理</code>:  首先是master数据库会先将数据库的变化存储在binlog文件中。在slave数据库上，会有一个IO Thread负责将binlog文件读取到内部的relaylog文件中。同时，slave数据库上的另外一个线程SQL Thread读取relaylog，将数据写入到slave数据库里面。</p><p>​    <code>细节</code>: mysql的binlog文件存储在 /var/lib/mysql文件夹下；使用命令-&gt; mysqlbinlog –base64-output=decode-rows -v  mysql-bin.000001 查看binlog的内容；binlog的格式：statement（默认，基于sql语句模式，针对数据更新的一些函数now()等，数据延迟造成的不一致），row：基于行模式，记录修改后每一条数据变化的值，mixed：混合模式，由mysql自动判断处理。</p><p>​    <code>问题</code>：同步延迟，master tps较高时出现同步延迟； 网络延迟；磁盘IO</p><hr><p><code>分库分表</code></p><p>​    <code>垂直拆分</code></p><p>​        <code>概念</code>:垂直拆分主要是通过业务层面，将各个业务模块所使用到的表放到各自不同的数据库里面，做到各个业务模块库相互隔离的目的。</p><p>​        <code>问题</code>:若是各个业务模块的表之间存在一些关联查询，需要将这些查询改为服务调用的方式。  针对一些全局表，可以改为服务调用的方式，对外提供服务。</p><p>​    <code>水平拆分</code></p><p>​        <code>概念</code>:将一张大的表拆分成n多张小表。实现方式，第一种是通过一致性hash（若是新增表的话，会涉及到数据迁移的问题）。第二种是可以按照id的范围来拆分。第三种是通过日期来拆分。</p><p>​        <code>问题</code>:唯一主键问题，可以使用zk自增id  可以使用redis的自增id  可以使用代理的id</p><hr><p><code>Mycat</code></p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1. 从github上面clone项目 https://github.com/MyCATApache/Mycat-Server.git</span><br><span class="line">2. 修改项目中schema.xml配置文件中的dataHost数据库配置节点信息，修改为可用的数据库</span><br><span class="line">3. MycatStartup类运行main函数启动</span><br><span class="line">idea启动前需要在配置参数VM options: -DMYCAT_HOME=D:<span class="tag">\<span class="name">code</span></span><span class="tag">\<span class="name">Mycat</span></span>-Server<span class="tag">\<span class="name">src</span></span><span class="tag">\<span class="name">main</span></span></span><br><span class="line">4. 通过数据库连接工具可以连接到MyCat,数据库相关配置在server.xml配置文件里面</span><br><span class="line">默认的用户名: root 密码: 123456 port: 8066</span><br><span class="line">5. mycat里面有三个比较重要的配置文件 </span><br><span class="line">server.xml配置数据库连接相关的一些信息</span><br><span class="line">schema.xml  配置数据库的一些节点信息</span><br><span class="line">rule.xml    配置一些路由规则</span><br><span class="line">6. 支持单库分表   支持跨库分表    支持配置读写分离(writeHost和readHost节点)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;&lt;code&gt;数据库优化之分库分表&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;针对数据库的优化有两点，第一是从整体层面优化，设计到读写分离和分库分表。第二是从sql层面优化，主要是涉及到索引相关的一些东西。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;code&gt;读写分离&lt;/code&gt;&lt;/
      
    
    </summary>
    
      <category term="数据库" scheme="https://zhilongao.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mysql" scheme="https://zhilongao.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"/>
    
    
  </entry>
  
</feed>
