<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>gzl Blog</title>
  
  <subtitle>志龙的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhilongao.github.io/"/>
  <updated>2019-09-06T06:07:12.027Z</updated>
  <id>https://zhilongao.github.io/</id>
  
  <author>
    <name>gaozhilong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>字符串</title>
    <link href="https://zhilongao.github.io/wiki/string-ask/"/>
    <id>https://zhilongao.github.io/wiki/string-ask/</id>
    <published>2019-09-06T02:25:40.000Z</published>
    <updated>2019-09-06T06:07:12.027Z</updated>
    
    <content type="html"><![CDATA[<h6 id="无重复字符的最长子串-leetcode第三题"><a href="#无重复字符的最长子串-leetcode第三题" class="headerlink" title="无重复字符的最长子串(leetcode第三题)"></a><code>无重复字符的最长子串(leetcode第三题)</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 滑动窗口解法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = s.length();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">    Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">    <span class="keyword">while</span>(left &lt; length &amp;&amp; right &lt; length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!set.contains(s.charAt(right))) &#123;</span><br><span class="line">            set.add(s.charAt(right ++));</span><br><span class="line">            ans = Math.max(ans, right - left);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            set.remove(s.charAt(left ++));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="最长回文子串-leetcode第五题"><a href="#最长回文子串-leetcode第五题" class="headerlink" title="最长回文子串(leetcode第五题)"></a><code>最长回文子串(leetcode第五题)</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 题目要求:给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</span></span><br><span class="line"><span class="comment">// 1.要判断一个字符串是否为回文字符串，可以通过下面几种方式来实现</span></span><br><span class="line"><span class="comment">// 第一种:通过栈的后进先出原理，将字符串翻转来对比前后两个字符串是否一致</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isHuiWen1</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        stack.push(str.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuffer buf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        buf.append(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (str.equals(buf.toString())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二种: 取消栈的引入，直接通过逆序输出拼接字符串(减少了额外的空间Stack)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isHuiWen2</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    StringBuffer buf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = str.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">        buf.append(str.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (buf.toString().equals(str)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第三中: 基于回文串左右两边两个字符相等的规律，定义两个变量做对比(优势是减少了字符串str的遍历次数，时间复杂度降低)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isHuiWen3</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = str.length();</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(str.charAt(left) == str.charAt(right))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        left ++;</span><br><span class="line">        right --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前这道题如何实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 给定一个字符串s,找到s中最长的回文子串。你可以假设s的最大长度为1000。</span></span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> resultLen = <span class="number">1</span>;</span><br><span class="line">    String resultStr = s.substring(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">        <span class="comment">// 从中间向两边查找对称的回文串</span></span><br><span class="line">        String oddStr = spread(s, len, i, i);</span><br><span class="line">        String evenStr = spread(s, len, i, i+<span class="number">1</span>);</span><br><span class="line">        String myStr = oddStr.length() &gt;= evenStr.length() ? oddStr : evenStr;</span><br><span class="line">        <span class="keyword">if</span> (myStr.length() &gt; resultLen) &#123;</span><br><span class="line">            resultStr = myStr;</span><br><span class="line">            resultLen = resultStr.length();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultStr;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">spread</span><span class="params">(String s, <span class="keyword">int</span> len, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = left;</span><br><span class="line">    <span class="keyword">int</span> r = right;</span><br><span class="line">    <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; len &amp;&amp; (s.charAt(l) == s.charAt(r))) &#123;</span><br><span class="line">        l --;</span><br><span class="line">        r ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(l+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;无重复字符的最长子串-leetcode第三题&quot;&gt;&lt;a href=&quot;#无重复字符的最长子串-leetcode第三题&quot; class=&quot;headerlink&quot; title=&quot;无重复字符的最长子串(leetcode第三题)&quot;&gt;&lt;/a&gt;&lt;code&gt;无重复字符的最长子串(le
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="算法" scheme="https://zhilongao.github.io/categories/java/%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串" scheme="https://zhilongao.github.io/categories/java/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
  </entry>
  
  <entry>
    <title>array-ask</title>
    <link href="https://zhilongao.github.io/wiki/array-ask/"/>
    <id>https://zhilongao.github.io/wiki/array-ask/</id>
    <published>2019-09-05T01:52:30.000Z</published>
    <updated>2019-09-05T12:23:51.735Z</updated>
    
    <content type="html"><![CDATA[<h6 id="寻找递增序列"><a href="#寻找递增序列" class="headerlink" title="寻找递增序列"></a><code>寻找递增序列</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给定一个未经过排序的数组，找到最长且连续的递增序列(在美团面试题中出现过-leetcode674题)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> curr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            curr ++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            max = Math.max(max, curr);</span><br><span class="line">        curr = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(max, curr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;寻找递增序列&quot;&gt;&lt;a href=&quot;#寻找递增序列&quot; class=&quot;headerlink&quot; title=&quot;寻找递增序列&quot;&gt;&lt;/a&gt;&lt;code&gt;寻找递增序列&lt;/code&gt;&lt;/h6&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="算法" scheme="https://zhilongao.github.io/categories/java/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数组" scheme="https://zhilongao.github.io/categories/java/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/"/>
    
    
  </entry>
  
  <entry>
    <title>mongodb-base</title>
    <link href="https://zhilongao.github.io/wiki/mongodb-base/"/>
    <id>https://zhilongao.github.io/wiki/mongodb-base/</id>
    <published>2019-09-03T03:45:03.000Z</published>
    <updated>2019-09-05T11:05:41.293Z</updated>
    
    <content type="html"><![CDATA[<h6 id="安装步骤-centos7"><a href="#安装步骤-centos7" class="headerlink" title="安装步骤(centos7)"></a><code>安装步骤(centos7)</code></h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1.下载安装包</span><br><span class="line">wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel62-3.2.10.tgz</span><br><span class="line">2.解压安装包</span><br><span class="line">tar -zxvf mongodb-linux-x86_64-rhel62-3.2.10.tgz </span><br><span class="line">3.将解压目录移动到(/usr/local/mongodb)</span><br><span class="line">mv mongodb-linux-x86_64-rhel62-3.2.10 /usr/local/mongodb</span><br><span class="line">4.在/usr/local/mongodb目录下创建/data/db目录和/logs目录</span><br><span class="line">mkdir -p /usr/local/mongodb/data/db </span><br><span class="line">mkdir -p /usr/local/mongodb/logs</span><br><span class="line">5.在/usr/local/mongodb/logs目录下创建mongodb.log文件</span><br><span class="line">touch mongodb.log</span><br><span class="line">6.在/usr/local/mongodb/bin目录下创建mongodb的配置文件</span><br><span class="line">touch mongodb.conf</span><br><span class="line">7.编辑mongodb.conf文件</span><br><span class="line">vi mongodb.conf</span><br><span class="line">编辑内容</span><br><span class="line">dbpath = /usr/local/mongodb/data/db #数据文件存放目录</span><br><span class="line">logpath = /usr/local/mongodb/logs/mongodb.log #日志文件存放目录</span><br><span class="line">port = 27017  #端口</span><br><span class="line">fork = true  #以守护程序的方式启用，即在后台运行</span><br><span class="line">nohttpinterface = true</span><br><span class="line">auth=true</span><br><span class="line">bind_ip=0.0.0.0</span><br><span class="line">8.修改环境变量</span><br><span class="line">vi /etc/profile</span><br><span class="line">添加的内容</span><br><span class="line">export MONGODB_HOME=/usr/local/mongodb</span><br><span class="line">export PATH=$PATH:$MONGODB_HOME/bin</span><br><span class="line">9.编辑完成之后重启系统配置</span><br><span class="line">source /etc/profile</span><br><span class="line">10.在/usr/local/mongodb/bin目录下启动mongodb</span><br><span class="line">./mongod -f mongodb.conf</span><br><span class="line">11.关闭mongodb服务</span><br><span class="line">./mongod -f ./mongodb.conf --shutdown</span><br><span class="line">12.开启27017端口</span><br><span class="line"></span><br><span class="line">13.使用shell登录到mongodb</span><br><span class="line">./mongodb</span><br><span class="line"></span><br><span class="line">14.登录到相关数据库</span><br><span class="line">use test</span><br><span class="line"></span><br><span class="line">15.创建用户</span><br><span class="line">db.createUser(</span><br><span class="line">&#123;</span><br><span class="line">user: "test", </span><br><span class="line">pwd: "test", </span><br><span class="line">roles: [&#123; role: "readWrite", db: "test" &#125;]</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line">16.修改配置，开启验证</span><br><span class="line">auth=true</span><br><span class="line">17.重启服务</span><br><span class="line">停止服务，然后启动</span><br><span class="line">18.登录</span><br><span class="line">./mongodb</span><br><span class="line">19.验证</span><br><span class="line">auth('test', 'test')(返回1代表成功)</span><br><span class="line">20.操作</span><br><span class="line">db.user.find()</span><br><span class="line">db.user.insert(&#123;"name":'jack',"age": 12&#125;)</span><br></pre></td></tr></table></figure><h6 id="基本操作-gt-java-api的crud"><a href="#基本操作-gt-java-api的crud" class="headerlink" title="基本操作-&gt;java api的crud"></a><code>基本操作-&gt;java api的crud</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 引入依赖</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.mongodb&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mongo-java-driver&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.9.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.java代码</span><br><span class="line"><span class="comment">// 工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MongoUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String baseUrl = <span class="string">"192.168.25.147:27017"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String userName = <span class="string">"test"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String passWord = <span class="string">"test"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String url = <span class="string">"mongodb://"</span>+ userName +<span class="string">":"</span>+ passWord + <span class="string">"@"</span>+ baseUrl + <span class="string">"/"</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 获取MongoDatabase</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MongoDatabase <span class="title">getConnection</span><span class="params">(String dataName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取MongoClient</span></span><br><span class="line">        com.mongodb.client.MongoClient mongoClient = MongoClients.create(url + dataName);</span><br><span class="line">        <span class="comment">// 获取MongoDatabase</span></span><br><span class="line">        MongoDatabase db = mongoClient.getDatabase(dataName);</span><br><span class="line">        <span class="keyword">return</span> db;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本操作 -&gt; 获取所有</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findAll</span><span class="params">(String databaseName, String collectionName)</span> </span>&#123;</span><br><span class="line">MongoDatabase database = MongoUtil.getConnection(databaseName);</span><br><span class="line">    MongoCollection&lt;Document&gt; collection = database.getCollection(collectionName);</span><br><span class="line">    FindIterable&lt;Document&gt; documents = collection.find();</span><br><span class="line">    print(documents);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本操作 -&gt; 插入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String databaseName, String collectionName)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取database</span></span><br><span class="line">MongoDatabase database = MongoUtil.getConnection(databaseName);</span><br><span class="line"><span class="comment">// 获取Clooection</span></span><br><span class="line">MongoCollection&lt;Document&gt; collection = database.getCollection(collectionName);</span><br><span class="line"><span class="comment">// 创建Document</span></span><br><span class="line">Document document = <span class="keyword">new</span> Document()</span><br><span class="line">                    .append(<span class="string">"name"</span>, <span class="string">"mick11"</span>)</span><br><span class="line">                    .append(<span class="string">"age"</span>, <span class="string">"33"</span>)</span><br><span class="line">                    .append(<span class="string">"address"</span>, <span class="string">"长沙"</span>)</span><br><span class="line">                    .append(<span class="string">"sex"</span>, <span class="string">"男"</span>);</span><br><span class="line">    <span class="comment">// 插入document                </span></span><br><span class="line">collection.insertOne(document);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印所有</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(FindIterable&lt;Document&gt; documents)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (Document document : documents) &#123;</span><br><span class="line">System.out.println(document.toJson());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;安装步骤-centos7&quot;&gt;&lt;a href=&quot;#安装步骤-centos7&quot; class=&quot;headerlink&quot; title=&quot;安装步骤(centos7)&quot;&gt;&lt;/a&gt;&lt;code&gt;安装步骤(centos7)&lt;/code&gt;&lt;/h6&gt;&lt;figure class=&quot;hig
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="数据库" scheme="https://zhilongao.github.io/categories/java/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mongodb" scheme="https://zhilongao.github.io/categories/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb/"/>
    
    
      <category term="mongo" scheme="https://zhilongao.github.io/tags/mongo/"/>
    
  </entry>
  
  <entry>
    <title>基础知识</title>
    <link href="https://zhilongao.github.io/wiki/redis-advance/"/>
    <id>https://zhilongao.github.io/wiki/redis-advance/</id>
    <published>2019-09-02T00:47:25.000Z</published>
    <updated>2019-09-07T06:59:09.080Z</updated>
    
    <content type="html"><![CDATA[<h6 id="string基本操作"><a href="#string基本操作" class="headerlink" title="string基本操作"></a><code>string基本操作</code></h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>单个操作   </span><br><span class="line">set name value(设置某个key-value)</span><br><span class="line">get name(获取某个key)</span><br><span class="line">exists name(判断某个key是否存在)</span><br><span class="line">del name(删除某个key)</span><br><span class="line">expire name seconds(给某个key设置expire)</span><br><span class="line">setex name seconds value(设置key的时候同时设置expire)</span><br><span class="line">setnx name value(不存在存储,存在不存储)</span><br><span class="line"><span class="meta">#</span>批量操作</span><br><span class="line">mset name1 value1 name2 value2(批量插入)</span><br><span class="line">mget name1 name2(批量获取)</span><br><span class="line"><span class="meta">#</span>特殊操作</span><br><span class="line">incr key(针对值为整数的情况,value加1)</span><br><span class="line">incrby key 5(针对值为整数的情况,value加5)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 使用场景</span><br><span class="line">保存一些JSON序列化的用户对象信息，使用时通过JSON反序列化，一次性的获取一整个用户对象，消耗网络流量。优点是存储消耗低于hash。</span><br></pre></td></tr></table></figure><h6 id="list基本操作"><a href="#list基本操作" class="headerlink" title="list基本操作"></a><code>list基本操作</code></h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>基本操作(普通操作)</span><br><span class="line">rpush key value1 value2 value3(存储元素)</span><br><span class="line">llen key(获取列表元素个数)</span><br><span class="line">lpop key(从左边弹出，非阻塞)</span><br><span class="line">rpop key(从右边弹出，非阻塞)</span><br><span class="line">blpop key timeout(从左边弹出，阻塞，timeout单位为秒)</span><br><span class="line">brpop key timeout(从右边弹出，阻塞，timeout单位为秒)</span><br><span class="line"><span class="meta">#</span> 基本操作(慢操作)</span><br><span class="line">lindex key index(获取某个位置上的value)</span><br><span class="line">ltrim key start_index end_index(保留start_index到end_index区间内的值,index可为负数,-1表示最后一个)</span><br><span class="line">lrange key start_index end_index(返回start_index到end_index区间内的值)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 使用场景</span><br><span class="line">异步队列(rpush lpop) </span><br><span class="line">栈(rpush rpop)</span><br></pre></td></tr></table></figure><h6 id="hash基本操作"><a href="#hash基本操作" class="headerlink" title="hash基本操作"></a><code>hash基本操作</code></h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>基本操作</span><br><span class="line">hset key filed value(给某个key的字典中存储一个key-value)</span><br><span class="line">hgetall key(查看key-value,key和value间隔出现)</span><br><span class="line">hlen books(查看key中存储的key-value个数)</span><br><span class="line">hget key filed(获取某个key下filed的value值)</span><br><span class="line">hmset key filed1 value1 filed2 value2(批量设置key-value)</span><br><span class="line">hincrby key filed 1(给某个key的field字段的value加1)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>使用场景</span><br><span class="line">存储用户信息-&gt;针对用户信息中的每个字段单独存储，获取用户信息时可以对部分字段单独获取,节省网络流量。但是缺点是存储消耗要高于字符串。</span><br></pre></td></tr></table></figure><h6 id="set基本操作"><a href="#set基本操作" class="headerlink" title="set基本操作"></a><code>set基本操作</code></h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>基本操作</span><br><span class="line">sadd key value(集合中添加一个元素)</span><br><span class="line">sadd key value1 value2(集合中添加多个元素)</span><br><span class="line">smembers key(列出key下面的value列表)</span><br><span class="line">sismember key value(查询key下面是否存在value)</span><br><span class="line">scard key(获取key的长度)</span><br><span class="line">spop key(弹出一个元素)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>使用场景</span><br><span class="line">可以用来存储中将用户的id,因为有去重功能，所以可以保证同一个用户不会中将两次。</span><br></pre></td></tr></table></figure><h6 id="zset基本操作"><a href="#zset基本操作" class="headerlink" title="zset基本操作"></a><code>zset基本操作</code></h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>基本操作</span><br><span class="line">zadd key score value(添加一个value)</span><br><span class="line">zrange key 0 -1(获取key元素列表，按照score排序列出)</span><br><span class="line">zrevrange key 0 -1(获取key元素列表，按照score逆序列出)</span><br><span class="line">zcard key(返回key中元素个数)</span><br><span class="line">zscore key value(返回某个key的score)</span><br><span class="line">zrangebyscore key score1 score2(根据分值区间遍历zset)</span><br><span class="line">zrangebyscore key -inf score withscore (根据分值区间 (-∞, score] 遍历 zset，同时返回分值。inf 代表 infinite，无穷大的意思。)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>使用场景</span><br><span class="line">可以用来存储粉丝列表，value值是粉丝的用户id，score是关注时间。可以对粉丝列表按照关注时间进行排序。</span><br><span class="line">可以用来存储学生的成绩，value值是学生的id, score是考试成绩。可以对成绩按照分数进行排序，就可以获取到它的名次。</span><br></pre></td></tr></table></figure><h6 id="sort排序操作"><a href="#sort排序操作" class="headerlink" title="sort排序操作"></a><code>sort排序操作</code></h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> redis的sort命令可以对列表键 集合键或者有序集合键的值进行排序</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>############# 最简单的排序 sort #########</span><br><span class="line"><span class="meta">#</span> 插入元素</span><br><span class="line"><span class="meta">redis&gt;</span> rpush numbers 5 3 1 4 2</span><br><span class="line">(integer) 5</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 按照插入顺序排列的列表元素</span><br><span class="line"><span class="meta">redis&gt;</span>lrange numbers 0 -1</span><br><span class="line"><span class="meta">#</span> 元素的输出顺序为 "5" "3" "1" "4" "2"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 按值从小到大有序排列的列表元素(默认升序排列asc)</span><br><span class="line"><span class="meta">redis&gt;</span> sort numbers</span><br><span class="line"><span class="meta">#</span> 元素的输出顺序为 "1" "2" "3" "4" "5"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 按值从大到小有序排列的列表元素</span><br><span class="line"><span class="meta">redis&gt;</span> sort numbers desc</span><br><span class="line"><span class="meta">#</span> 元素的输出顺序为 "5" "4" "3" "2" "1"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>########### 使用 sort和alpha选项对字符串进行排序########</span><br><span class="line"><span class="meta">#</span> 插入元素</span><br><span class="line"><span class="meta">reids&gt;</span> sadd alphabet a b c d e f g</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 乱序排列的集合元素</span><br><span class="line"><span class="meta">redis&gt;</span> smembers alphabet</span><br><span class="line"><span class="meta">#</span> 输出顺序为 "d" "a" "c" "b" "g" "e" "f"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 集合元素排序，使用alpha，asc升序排列</span><br><span class="line"><span class="meta">redis&gt;</span> sort alphabet alpha</span><br><span class="line"><span class="meta">#</span> 输出顺序为 "a" "b" "c" "d" "e" "f" "g"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 集合元素排序，使用alpha，desc降序排列</span><br><span class="line"><span class="meta">redis&gt;</span> sort alphabet alpha desc</span><br><span class="line"><span class="meta">#</span> 输出顺序为 "g" "f" "e" "d" "c" "b" "a"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>########### 使用sort和by选项对元素排序 ############</span><br><span class="line"><span class="meta">#</span> 插入元素</span><br><span class="line"><span class="meta">redis&gt;</span> zadd test-result 3.0 jack 3.5 peter 4.0 tom</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 普通输出，按照元素的分值排序</span><br><span class="line"><span class="meta">redis&gt;</span> zrange test-result 0 -1</span><br><span class="line"><span class="meta">#</span> 输出顺序为 "jack" "peter" "tom"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 为各个元素设置序号</span><br><span class="line"><span class="meta">redis&gt;</span> mset peter_number 1 tom_number 2 jack_number 3</span><br><span class="line">ok</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 以序号为权重，对集合中的元素进行排序</span><br><span class="line"><span class="meta">redis&gt;</span> sort test-result by *_number</span><br><span class="line"><span class="meta">#</span> 输出顺序为 "peter" "tom" "jack"</span><br></pre></td></tr></table></figure><h6 id="scan命令的使用"><a href="#scan命令的使用" class="headerlink" title="scan命令的使用"></a><code>scan命令的使用</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// scan命令的使用</span></span><br><span class="line"><span class="comment">// scan命令提供了三个参数,第一个参数是cursor整数值，第二个是key的正则模式，第三个是遍历的limit hint。第一次遍历时，cursor值为0，然后将返回结果中第一个整数值作为下一次遍历的cursor。一直遍历到返回的cursor值为0时结束。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以同过java的jedis客户端插入一些key</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">10000</span>;</span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"192.168.25.150"</span>, <span class="number">6379</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    jedis.set(<span class="string">"key"</span> + i, i + <span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是redis-cli操作</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; scan <span class="number">0</span> match key99* count <span class="number">1000</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"10904"</span></span><br><span class="line"><span class="number">2</span>) <span class="number">1</span>) <span class="string">"key9987"</span></span><br><span class="line">   <span class="number">2</span>) <span class="string">"key9924"</span></span><br><span class="line">   <span class="number">3</span>) <span class="string">"key9992"</span></span><br><span class="line">   <span class="number">4</span>) <span class="string">"key9941"</span></span><br><span class="line">   <span class="number">5</span>) <span class="string">"key9901"</span></span><br><span class="line">   <span class="number">6</span>) <span class="string">"key9945"</span></span><br><span class="line">   <span class="number">7</span>) <span class="string">"key9984"</span></span><br><span class="line">   <span class="number">8</span>) <span class="string">"key9903"</span>    </span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; scan <span class="number">10904</span> match key99* count <span class="number">1000</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"14028"</span></span><br><span class="line"><span class="number">2</span>) <span class="number">1</span>) <span class="string">"key9989"</span></span><br><span class="line">   <span class="number">2</span>) <span class="string">"key992"</span></span><br><span class="line">   <span class="number">3</span>) <span class="string">"key9997"</span></span><br><span class="line">   <span class="number">4</span>) <span class="string">"key9968"</span></span><br><span class="line">   <span class="number">5</span>) <span class="string">"key996"</span></span><br><span class="line">   <span class="number">6</span>) <span class="string">"key9958"</span>    </span><br><span class="line">        </span><br><span class="line"><span class="comment">//下面是java客户端操作代码段</span></span><br><span class="line">String cursor = <span class="string">"0"</span>;</span><br><span class="line">ScanParams scanParams = <span class="keyword">new</span> ScanParams();</span><br><span class="line">scanParams.match(<span class="string">"key99*"</span>);</span><br><span class="line">scanParams.count(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    ScanResult&lt;String&gt; result = jedis.scan(cursor, scanParams);</span><br><span class="line">    List&lt;String&gt; resultList = result.getResult();</span><br><span class="line">    <span class="keyword">for</span> (String resultStr : resultList) &#123;</span><br><span class="line">    System.out.print(resultStr + <span class="string">"\t"</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"\n--------------"</span>);</span><br><span class="line">String stringCursor = result.getStringCursor();</span><br><span class="line"><span class="comment">// 当游标为再次为0时,表示已经遍历完毕,直接跳出循环</span></span><br><span class="line"><span class="keyword">if</span> (stringCursor.equals(<span class="string">"0"</span>)) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cursor = stringCursor;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;string基本操作&quot;&gt;&lt;a href=&quot;#string基本操作&quot; class=&quot;headerlink&quot; title=&quot;string基本操作&quot;&gt;&lt;/a&gt;&lt;code&gt;string基本操作&lt;/code&gt;&lt;/h6&gt;&lt;figure class=&quot;highlight she
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="数据库" scheme="https://zhilongao.github.io/categories/java/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="redis" scheme="https://zhilongao.github.io/categories/java/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/"/>
    
    
  </entry>
  
  <entry>
    <title>单链表</title>
    <link href="https://zhilongao.github.io/wiki/linked-list-ask/"/>
    <id>https://zhilongao.github.io/wiki/linked-list-ask/</id>
    <published>2019-08-31T03:56:40.000Z</published>
    <updated>2019-09-03T07:38:54.888Z</updated>
    
    <content type="html"><![CDATA[<p><code>单链表常见操作</code></p><p><code>1.如何实现一个单链表的逆序输出-&gt;反转单链表</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">    ListNode next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span> &amp;&amp; (next = head.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    head.next = prev;</span><br><span class="line">        prev = head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    head.next = prev;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;单链表常见操作&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1.如何实现一个单链表的逆序输出-&amp;gt;反转单链表&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="算法" scheme="https://zhilongao.github.io/categories/java/%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="https://zhilongao.github.io/categories/java/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="https://zhilongao.github.io/wiki/arithmetic-sort/"/>
    <id>https://zhilongao.github.io/wiki/arithmetic-sort/</id>
    <published>2019-08-31T01:19:15.000Z</published>
    <updated>2019-09-06T06:27:43.174Z</updated>
    
    <content type="html"><![CDATA[<p><code>常见的排序算法</code></p><p><code>1.插入排序</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入排序算法</span></span><br><span class="line"><span class="comment">// 时间复杂度：平均情况:o(n^2)  最好情况:o(n) 最坏情况:o(n^2) </span></span><br><span class="line"><span class="comment">// 空间复杂度: o(1)</span></span><br><span class="line"><span class="comment">// 特点: 稳定</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; array.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = array[i];</span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;=<span class="number">0</span> &amp;&amp; array[j] &gt; temp; j --) &#123;</span><br><span class="line">            <span class="comment">// 将数组中的元素后移一位</span></span><br><span class="line">            array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">        &#125;</span><br><span class="line">        array[j + <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>2.选择排序</code></p><p><code>原理</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 选择排序算法</span></span><br><span class="line"><span class="comment">// 时间复杂度: 平均情况:o(n^2)  最好情况:o(n^2) 最坏情况:o(n^2)  </span></span><br><span class="line"><span class="comment">// 空间复杂度: o(1)</span></span><br><span class="line"><span class="comment">// 特点: 不稳定</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; array.length; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &gt; array[j]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = array[i];</span><br><span class="line">                array[i] = array[j];</span><br><span class="line">                array[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>3.交换排序-&gt;冒泡排序</code></p><p><code>原理</code></p><p><img src="https://raw.githubusercontent.com/zhilongao/images-repository/master/006y8mN6ly1g6mbx8snqyg30my075wqv.gif" alt="冒泡排序"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序算法</span></span><br><span class="line"><span class="comment">// 时间复杂度: 平均情况:o(n^2)  最好情况:o(n) 最坏情况:o(n^2)</span></span><br><span class="line"><span class="comment">// 空间复杂度: o(1)</span></span><br><span class="line"><span class="comment">// 特点：稳定</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - i - <span class="number">1</span>; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = array[j];</span><br><span class="line">                array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">                array[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>4.交换排序-&gt;快速排序</code></p><p><code>原理</code></p><p><img src="https://raw.githubusercontent.com/zhilongao/images-repository/master/7789414-007520d3d4a7610c.gif" alt="快速排序"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快速排序算法</span></span><br><span class="line"><span class="comment">// 时间复杂度: 平均情况:o(nlog2^n) 最好情况:o(nlog2^n) 最坏情况:o(n^2)</span></span><br><span class="line"><span class="comment">// 空间复杂度: o(nlog2^n)</span></span><br><span class="line"><span class="comment">// 特点：不稳定</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fastSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &gt; high) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = low;</span><br><span class="line">    <span class="keyword">int</span> j = fast;</span><br><span class="line">    <span class="keyword">int</span> temp = array[low];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="comment">// 从右向左找到第一个小于temp的元素,保存其下标</span></span><br><span class="line">        <span class="keyword">while</span> (array[j] &gt; temp &amp;&amp; i &lt; j) &#123;</span><br><span class="line">            j --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从左向右找到第一个大于temp的元素，保存其下标</span></span><br><span class="line">        <span class="keyword">while</span> (array[i] &lt;= temp &amp;&amp; i &lt; j) &#123;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换这两个元素</span></span><br><span class="line">        <span class="keyword">int</span> swap = array[i];</span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        array[j] = swap;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 交换temp</span></span><br><span class="line">    array[low] = array[i];</span><br><span class="line">    array[i] = temp;</span><br><span class="line">    <span class="comment">// 快排temp左半边</span></span><br><span class="line">    fastSort(array, low, j - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 快排temp右半边</span></span><br><span class="line">    fastSort(array, j + <span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>5.归并排序</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 归并排序算法</span></span><br><span class="line"><span class="comment">// 时间复杂度: 平均情况:o(nlog2^n) 最好情况:o(nlog2^n) 最坏情况:o(nlog2^n)</span></span><br><span class="line"><span class="comment">// 空间复杂度：o(1)</span></span><br><span class="line"><span class="comment">// 特点: 稳定</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">sortMerge</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    sort(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> array[], <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (R + L) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 排序左半部分</span></span><br><span class="line">    sort(array, L, mid);</span><br><span class="line">    <span class="comment">// 排序右半部分</span></span><br><span class="line">    sort(array, mid + <span class="number">1</span>, R);</span><br><span class="line">    <span class="comment">// 合并 </span></span><br><span class="line">    merge(array, L, mid, R);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> L, <span class="keyword">int</span> mid, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[R - L + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = L;</span><br><span class="line">    <span class="keyword">int</span> p2 = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 将数组排序后放入到临时数组temp中</span></span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= R) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[p1] &lt; array[p2]) &#123;</span><br><span class="line">            temp[i++] = array[p1++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[i++] = array[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p1 &lt;= mid) &#123;</span><br><span class="line">        temp[i++] = array[p1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p2 &lt;= R) &#123;</span><br><span class="line">        temp[i++] = array[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将临时数组中的元素移动到array中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; temp.length; k ++) &#123;</span><br><span class="line">        array[L + k] = temp[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;常见的排序算法&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1.插入排序&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;s
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="算法" scheme="https://zhilongao.github.io/categories/java/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="https://zhilongao.github.io/categories/java/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>jvm-command</title>
    <link href="https://zhilongao.github.io/wiki/jvm-command/"/>
    <id>https://zhilongao.github.io/wiki/jvm-command/</id>
    <published>2019-08-29T09:01:23.000Z</published>
    <updated>2019-08-31T04:00:56.547Z</updated>
    
    <content type="html"><![CDATA[<hr><p><code>jvm基本指令</code></p><table><thead><tr><th>基本指令</th><th>指令说明</th></tr></thead><tbody><tr><td>iconst_1</td><td>int型常量值1进栈</td></tr><tr><td>bipush</td><td>将一个byte型常量值推送至栈顶</td></tr><tr><td>iload_1</td><td>第二个int型局部变量进栈，从0开始计数</td></tr><tr><td>istore_1</td><td><em>将栈顶int型数值存入第二个局部变量，从<strong>0</strong>开始计数</em></td></tr><tr><td></td><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;&lt;code&gt;jvm基本指令&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;基本指令&lt;/th&gt;
&lt;th&gt;指令说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;iconst_1&lt;/td&gt;
&lt;td&gt;int型常量值1进
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="基础" scheme="https://zhilongao.github.io/categories/java/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="jvm" scheme="https://zhilongao.github.io/categories/java/%E5%9F%BA%E7%A1%80/jvm/"/>
    
    
  </entry>
  
  <entry>
    <title>dubbo</title>
    <link href="https://zhilongao.github.io/wiki/dubbo-ask/"/>
    <id>https://zhilongao.github.io/wiki/dubbo-ask/</id>
    <published>2019-08-28T11:57:42.000Z</published>
    <updated>2019-08-28T12:21:39.474Z</updated>
    
    <content type="html"><![CDATA[<p><code>协议</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;协议&lt;/code&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="分布式" scheme="https://zhilongao.github.io/categories/java/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>博客</title>
    <link href="https://zhilongao.github.io/wiki/share-articles/"/>
    <id>https://zhilongao.github.io/wiki/share-articles/</id>
    <published>2019-08-27T13:38:52.000Z</published>
    <updated>2019-09-06T06:32:28.552Z</updated>
    
    <content type="html"><![CDATA[<p><code>友情链接</code></p><p><a href="https://yapengren.github.io/" target="_blank" rel="noopener">任亚鹏的博客</a></p><p><code>给力博客</code></p><p><a href="https://tech.meituan.com/" target="_blank" rel="noopener">美团技术团队</a></p><hr><p><a href="https://www.v2ex.com/" target="_blank" rel="noopener">v2ex</a></p><hr><p><a href="https://juejin.im/timeline" target="_blank" rel="noopener">掘金</a></p><hr><p><a href="http://cmsblogs.com/" target="_blank" rel="noopener">java技术驿站</a></p><hr><p><a href="https://www.infoq.cn/" target="_blank" rel="noopener">infoq</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;友情链接&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://yapengren.github.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;任亚鹏的博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;给力博客&lt;/code&gt;&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>分库分表</title>
    <link href="https://zhilongao.github.io/wiki/mysql-split/"/>
    <id>https://zhilongao.github.io/wiki/mysql-split/</id>
    <published>2019-08-27T09:08:54.000Z</published>
    <updated>2019-08-28T03:14:43.225Z</updated>
    
    <content type="html"><![CDATA[<hr><p><code>数据库优化之分库分表</code></p><hr><p>针对数据库的优化有两点，第一是从整体层面优化，设计到读写分离和分库分表。第二是从sql层面优化，主要是涉及到索引相关的一些东西。</p><hr><p><code>读写分离</code></p><p>​    <code>需求</code>: 读写分离的目的是做数据冗余备份，同时将读写分离，提升数据库的服务性能（IO性能瓶颈）。</p><p>​    <code>搭建过程</code>: 在基本操作里面-&gt;mysql配置主从同步的步骤 。</p><p>​    <code>实现原理</code>:  首先是master数据库会先将数据库的变化存储在binlog文件中。在slave数据库上，会有一个IO Thread负责将binlog文件读取到内部的relaylog文件中。同时，slave数据库上的另外一个线程SQL Thread读取relaylog，将数据写入到slave数据库里面。</p><p>​    <code>细节</code>: mysql的binlog文件存储在 /var/lib/mysql文件夹下；使用命令-&gt; mysqlbinlog –base64-output=decode-rows -v  mysql-bin.000001 查看binlog的内容；binlog的格式：statement（默认，基于sql语句模式，针对数据更新的一些函数now()等，数据延迟造成的不一致），row：基于行模式，记录修改后每一条数据变化的值，mixed：混合模式，由mysql自动判断处理。</p><p>​    <code>问题</code>：同步延迟，master tps较高时出现同步延迟； 网络延迟；磁盘IO</p><hr><p><code>分库分表</code></p><p>​    <code>垂直拆分</code></p><p>​        <code>概念</code>:垂直拆分主要是通过业务层面，将各个业务模块所使用到的表放到各自不同的数据库里面，做到各个业务模块库相互隔离的目的。</p><p>​        <code>问题</code>:若是各个业务模块的表之间存在一些关联查询，需要将这些查询改为服务调用的方式。  针对一些全局表，可以改为服务调用的方式，对外提供服务。</p><p>​    <code>水平拆分</code></p><p>​        <code>概念</code>:将一张大的表拆分成n多张小表。实现方式，第一种是通过一致性hash（若是新增表的话，会涉及到数据迁移的问题）。第二种是可以按照id的范围来拆分。第三种是通过日期来拆分。</p><p>​        <code>问题</code>:唯一主键问题，可以使用zk自增id  可以使用redis的自增id  可以使用代理的id</p><hr><p><code>Mycat</code></p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1. 从github上面clone项目 https://github.com/MyCATApache/Mycat-Server.git</span><br><span class="line">2. 修改项目中schema.xml配置文件中的dataHost数据库配置节点信息，修改为可用的数据库</span><br><span class="line">3. MycatStartup类运行main函数启动</span><br><span class="line">idea启动前需要在配置参数VM options: -DMYCAT_HOME=D:<span class="tag">\<span class="name">code</span></span><span class="tag">\<span class="name">Mycat</span></span>-Server<span class="tag">\<span class="name">src</span></span><span class="tag">\<span class="name">main</span></span></span><br><span class="line">4. 通过数据库连接工具可以连接到MyCat,数据库相关配置在server.xml配置文件里面</span><br><span class="line">默认的用户名: root 密码: 123456 port: 8066</span><br><span class="line">5. mycat里面有三个比较重要的配置文件 </span><br><span class="line">server.xml配置数据库连接相关的一些信息</span><br><span class="line">schema.xml  配置数据库的一些节点信息</span><br><span class="line">rule.xml    配置一些路由规则</span><br><span class="line">6. 支持单库分表   支持跨库分表    支持配置读写分离(writeHost和readHost节点)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;&lt;code&gt;数据库优化之分库分表&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;针对数据库的优化有两点，第一是从整体层面优化，设计到读写分离和分库分表。第二是从sql层面优化，主要是涉及到索引相关的一些东西。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;code&gt;读写分离&lt;/code&gt;&lt;/
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="数据库" scheme="https://zhilongao.github.io/categories/java/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mysql" scheme="https://zhilongao.github.io/categories/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>基本操作</title>
    <link href="https://zhilongao.github.io/wiki/mysql-base/"/>
    <id>https://zhilongao.github.io/wiki/mysql-base/</id>
    <published>2019-08-27T09:08:25.000Z</published>
    <updated>2019-08-27T12:58:54.756Z</updated>
    
    <content type="html"><![CDATA[<hr><p><code>centos7上mysql的安装步骤</code></p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.下载mysql的repo源  &gt; wget http://repo.mysql.com/mysql57-community-release-el7-8.noarch.rpm</span><br><span class="line">2.安装源&gt; rpm -ivh mysql57-community-release-el7-8.noarch.rpm</span><br><span class="line">3.安装数据库-&gt;yum install mysql-server</span><br><span class="line">4.启动数据库&gt; systemctl start mysqld</span><br><span class="line">5.查看mysql为root账号生成的随机密码&gt;grep "password" /var/log/mysqld.log</span><br><span class="line">  说明root@localhost:此处为随机密码</span><br><span class="line">6.运行mysql -uroot -p回车</span><br><span class="line">7.粘贴随机密码-&gt;此时已经登录到mysql数据库，需要为root账号设置密码</span><br><span class="line">8.由于mysql5.7有对密码设置的验证，简单密码设置不了，需要运行下面两条命令关闭验证</span><br><span class="line">&gt; set global validate_password_length=1;</span><br><span class="line">&gt; set global validate_password_policy=0;</span><br><span class="line">9.修改root账号的密码</span><br><span class="line">&gt; set password = password('123456');</span><br><span class="line">10.修改root账号的权限</span><br><span class="line">    &gt; GRANT ALL PRIVILEGES ON *.* TO 'root'@'<span class="comment">%' IDENTIFIED BY 'root' WITH GRANT OPTION;</span></span><br><span class="line">11.可以创建一个其它的用户</span><br><span class="line">&gt; create user repl identified by 'repl';</span><br><span class="line">12.为该用户授权</span><br><span class="line">    &gt; grant replication slave on *.* to 'repl'@'<span class="comment">%' identified by 'repl';(数据同步的权限)</span></span><br><span class="line">    &gt; GRANT ALL ON *.* TO 'pig'@'<span class="comment">%';(为用户pig授予所有权限)</span></span><br></pre></td></tr></table></figure><p><code>mysql配置主从同步的步骤</code></p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.在master服务器上创建一个可以进行数据同步的账户。</span><br><span class="line">&gt; create user repl identified by 'repl';</span><br><span class="line">2.在master服务器上为该用户授权。</span><br><span class="line">&gt; grant replication slave on *.* to 'repl'@'<span class="comment">%' identified by 'repl';</span></span><br><span class="line">3.在master服务器上修改/etc/my.cnf文件。</span><br><span class="line">[mysqld]</span><br><span class="line">log-bin=mysql-bin</span><br><span class="line">server-id=147</span><br><span class="line">4.在master上面重启mysql</span><br><span class="line">&gt; systemctl restart mysqld</span><br><span class="line">5.在master上登录数据库，使用下面命令查看二进制文件。</span><br><span class="line">&gt; show master status;</span><br><span class="line">6.在slave服务器上修改/etc/my.cnf文件</span><br><span class="line">[mysqld]</span><br><span class="line">server-id=149</span><br><span class="line">relay-log=slave-relay-bin</span><br><span class="line">relay-log-index=slave-relay-bin.index</span><br><span class="line">read-only=1</span><br><span class="line">7.在slave服务器上重启mysql</span><br><span class="line">&gt; systemctl restart mysqld</span><br><span class="line">8.在slave上登录数据库,执行下列命令，设置master相关参数。</span><br><span class="line">&gt; change master to master_host='192.168.25.147',master_port=3306,master_user='repl',master_password='repl',master_log_file='mysql-bin.000003', master_log_pos=154;</span><br><span class="line">9.在slave上运行命令，启动服务</span><br><span class="line">&gt; start slave;</span><br><span class="line">10.查看状态，查看主从同步设置是否成功</span><br><span class="line">&gt; show slave status<span class="tag">\<span class="name">G</span></span>;</span><br><span class="line">11.搭建完成，现在就可以玩啦，尝试在master上面创建数据库和表，在slave上会看到相应的数据库和表。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;&lt;code&gt;centos7上mysql的安装步骤&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight tex&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1.下载mysql的repo
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="数据库" scheme="https://zhilongao.github.io/categories/java/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mysql" scheme="https://zhilongao.github.io/categories/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>索引</title>
    <link href="https://zhilongao.github.io/wiki/mysql-index/"/>
    <id>https://zhilongao.github.io/wiki/mysql-index/</id>
    <published>2019-08-27T09:08:17.000Z</published>
    <updated>2019-08-27T09:51:54.005Z</updated>
    
    <content type="html"><![CDATA[<p><code>1.数据库四大特性</code></p><p>​    A( Atomicity 原子性):  数据库最小的工作单元，整个工作单元要么一起提交成功,要么一起失败回滚。<br>​    C( Consistency 一致性):  事物中操作的数据的状态是一致的。即写入数据的结果必须完全符合预设的规则，不会因为出现系统意外等原因导致状态的不一致。<br>​    I( Isolation 隔离性):  一个事务所操作的数据在提交之前，对其他事务的可见性设定（一般设定为不可见）。<br>​    D( Durability 持久性):  数据库的数据一旦提交,无法更改。</p><p><code>2.多个事物并发引起的数据读取问题</code></p><p>​    脏读:  是指一个事物读取到了另外一个事物未提交的数据。<br>​    不可重复读:  是指在一个事物未结束之前, 前后两次读取到的数据不一致现象。原因在于该事物在前后两次读取数据之间，另外一个事物修改了该数据。(不可重复读的重点在于修改)。<br>​    幻读:  是指当一个事物修改了数据库表中某一个范围内的数据的某一个字段，但是另外一个事物在此期间又在该范围内插入了一条新的数据，造成前一个事物出现幻觉(没有完全修改)。(幻读的重点在于新增或删除) 。</p><p><code>3.数据库事物的隔离级别</code></p><p>  Read Uncommited 读未提交:  事物未提交对其它的事物也是可见的。<br>  Read Commited 读已提交:  一个事物只能够读取到已提交的数据。(解决脏读, 未解决不可重复读)。<br>  Repeatable Read 可重复读:  一个事物对数据的前后读取结果是一致的。(解决了不可重复读, 未解决幻读)。<br>  Serializable 串行化:  数据库最高的隔离级别,  强制所有事物串行执行,解决了所有并发问题。</p><p><code>4.聚集索引和非聚集索引的区别</code><br>    聚集索引:  表中的数据是按照索引的顺序来存储的。索引的叶子节点上存储了真实的数据,不会有另外单独的数据页。<br>    非聚集索引:  表中的数据存储不依赖于索引的顺序。索引的叶子节点上存储了索引的关键字和指向真实数据的指针。   </p><p><code>5.sql调优</code></p><p>​    a. 创建索引  b.使用临时表存储中间结果-&gt;(避免多次扫描主表)。c. 避免在索引上使用计算。4.少使用select *，只返回需要的字段。</p><p><code>6.如何理解MVCC</code>   </p><p>​    a. 数据库每张表会单独维护两个字段，数据行版本号和删除版本号。   </p><p>​    b. 当执行insert操作时，我们开启了一个事物，执行数据插入操作时，会将这个事物的事物id设置到数据行版本号这个字段中（这个事物的事物id属于数据库一个全局属性，自增）。</p><p>​    c. 当执行delete操作时，我们开启了一个事物，执行数据删除操作时，会将这个事物的事物id设置到删除版本号这个字段中。</p><p>​    d. 当执行update操作时，我们开启了一个事物，指定数据更新操作时，会将这行数据copy一份，copy的这份数据数据行版本号为当前事物id，删除版本号为Null，并更新相关字段。原先那行的删除版本号会被设置为当前的事物id。</p><p>​    e.  当我们执行数据库查询时，满足以下两点要求：</p><p>​        e1：查找数据的数据行版本号小于或等于当前事物id。(保证该条数据在当前事物开启之前就已经存在或者为该事物添加的数据。</p><p>​        e2：查找数据的删除版本号为Null或者删除版本号大于当前事物id。（该条规则可以确保当前事物在开始之前数据还未被删除。</p><p><code>7.MVCC解决的问题与未解决的问题</code></p><p>   若是一个查询先于一行的数据更新，不会出现问题。若是一个查询后于一行的数据更新，会产生脏读的问题。</p><p><code>8.Innodb数据库的四种隔离级别是如何实现的</code></p><p>​    读未提交：对select操作不会加锁，并发性能是最好的，但是容易造成脏读。</p><p>​    读已提交（互联网上默认的隔离级别）：普通的数据读取是会直接读取数据快照，加锁的select，update等操作会使用记录锁。注意：读已提交读取快照时，一个事物读取了数据，但是当第二次读取的时候，另外一个事物已经将该快照刷新了，所以会造成不可重复读的问题。</p><p>​    可重复读（Innodb默认的事物隔离级别）：对于普通的数据库查询，使用读取快照的方式。对于加锁的select,update等语句，他们加锁的力度取决于查询条件是使用了唯一索引还是使用了范围查询。若是使用了唯一索引，会使用记录锁的方式。若是使用了范围查询，会使用间隙锁，避免发生不可重复读。注意:当一个事物开启读取数据时，前后两次读取的都是同一个快照，这样就可以实现了可重复读。</p><p>​    串行化：针对所有的操作都会去加锁，普通的select操作会去加共享锁-&gt;select * from table in share mode。对于 update 等操作会加排他锁。若是一个事物查询操作时，正好有一个事物对改行的数据做修改操作。则该查询操作会阻塞，直到更新操作执行完成。</p><p><code>9.如何理解快照读和当前读</code></p><p>​    快照读：读取的数据是快照。当前读：读取的数据是数据库的最新的数据。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;1.数据库四大特性&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;​    A( Atomicity 原子性):  数据库最小的工作单元，整个工作单元要么一起提交成功,要么一起失败回滚。&lt;br&gt;​    C( Consistency 一致性):  事物中操作的数据的状态是一致的。
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="数据库" scheme="https://zhilongao.github.io/categories/java/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mysql" scheme="https://zhilongao.github.io/categories/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>tcp</title>
    <link href="https://zhilongao.github.io/wiki/tcp/"/>
    <id>https://zhilongao.github.io/wiki/tcp/</id>
    <published>2019-08-26T13:33:14.000Z</published>
    <updated>2019-08-28T12:55:39.134Z</updated>
    
    <content type="html"><![CDATA[<hr><p><code>此时握手</code></p><p><code>四次挥手</code></p><p><code>为什么要三次握手</code></p><p><code>为什么要四次挥手</code></p><p><code>socket的几种状态</code></p><p>​        <code>listen:侦听来自远方tcp端口的连接请求</code></p><p>​        <code>syn-sent:在发送连接请求后，等待匹配的连接请求。</code></p><p>​        <code>syn-receive:在收到和发送一个连接请求后，等待连接请求的确认</code></p><p>​        <code>established:代表一个打开的连接，数据可以传送给用户</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;&lt;code&gt;此时握手&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;四次挥手&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;为什么要三次握手&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;为什么要四次挥手&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;socket的几种状态&lt;/code&gt;
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="分布式" scheme="https://zhilongao.github.io/categories/java/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="协议" scheme="https://zhilongao.github.io/categories/java/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%8D%8F%E8%AE%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>project-ask</title>
    <link href="https://zhilongao.github.io/wiki/project-ask/"/>
    <id>https://zhilongao.github.io/wiki/project-ask/</id>
    <published>2019-08-26T13:26:32.000Z</published>
    <updated>2019-09-05T03:01:01.061Z</updated>
    
    <content type="html"><![CDATA[<p><code>项目专题</code></p><p><code>系统1</code></p><p>​    <code>系统数据流转</code></p><p>​    <img src="https://raw.githubusercontent.com/zhilongao/images-repository/master/3153f3dae0ac8b3014874267ad70cc1.png" alt="任务执行流程"></p><p>​    </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 大体流程</span></span><br><span class="line"><span class="number">1</span>. 从原始借据表bp_collect_loan_src同步数据到bp_collect_loan，同步批次号为batch_no的数据。(同步数据时，每个线程处理数量默认为<span class="number">10000</span>，若是当前批次数据量超过<span class="number">10000</span>，会采用多线程来执行)</span><br><span class="line"><span class="number">2</span>. 针对每一个原始借据，数据库里面只有可能有一条与之对应的借据，所以将bp_collect_loan存入数据库的操作采用的是insertOrUpdate操作(任务执行失败后，不会对数据库中的数据造成影响)。</span><br><span class="line"><span class="number">3</span>. 借据同步完成之后，需要执行归案任务，就是将多个借据加工成为一个案件，以人为维度进行催收。</span><br><span class="line"><span class="number">4</span>. 归案完成之后，需要跑规则引擎来执行分案，通过规则引擎分案之后，会在数据库表bp_collect_divide表里面生成分案记录。</span><br><span class="line"><span class="number">5</span>. 将这些分案记录针对案件进行分案(分案记录里面存储了两类，针对个人的分案，针对组的分案)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用到的技术点(分布式锁 redis队列)</span></span><br><span class="line"><span class="number">1</span>. 由于任务是部署在多台机器上的，多个进程执行任务时，需要获取分布式锁。项目中采用redis来实现了分布式锁，上锁命令采用set命令，外加是否存在，过期时间参数来实现。而释放锁的命令采用lua脚本来实现，因为会有两步骤操作，首先式判断上锁客户端和释放锁的客户端是否一致（存储在value中），其次是删除该锁对应的key，lua脚本保证了该操作的原子性。</span><br><span class="line"><span class="number">2</span>. 在执行归案的过程中，针对每一个案件，需要将该案件分出去，会过规则引擎。而将分案请求交给规则引擎有两种方式，第一种是先将该案件构建成为请求，然后将该请求放到redis的同步队列里面，规则引擎那边从同步队列里面来进行消费。第二种是若同步队列已满，或者放入到同步队列出错，则会将请求直接交给规则引擎来处理。</span><br><span class="line"></span><br><span class="line"><span class="comment">// 技术难点-如何克服</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;项目专题&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;系统1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;​    &lt;code&gt;系统数据流转&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;​    &lt;img src=&quot;https://raw.githubusercontent.com/zhilong
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="项目" scheme="https://zhilongao.github.io/categories/java/%E9%A1%B9%E7%9B%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>threadpool</title>
    <link href="https://zhilongao.github.io/wiki/threadpool/"/>
    <id>https://zhilongao.github.io/wiki/threadpool/</id>
    <published>2019-08-26T13:20:13.000Z</published>
    <updated>2019-08-26T13:23:48.587Z</updated>
    
    <content type="html"><![CDATA[<hr><p><code>线程池</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建线程池的工具类Executors</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Executors</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个只有一个工作线程的线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个固定数目线程的线程池(核心线程数和最大线程数相同)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个cache线程池，核心线程大小为0</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 线程工厂，负责为线程池中的Worker创建线程-》可以创建个性化的线程</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger poolNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">        DefaultThreadFactory() &#123;</span><br><span class="line">            SecurityManager s = System.getSecurityManager();</span><br><span class="line">            group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() :</span><br><span class="line">                                  Thread.currentThread().getThreadGroup();</span><br><span class="line">            namePrefix = <span class="string">"pool-"</span> +</span><br><span class="line">                          poolNumber.getAndIncrement() +</span><br><span class="line">                         <span class="string">"-thread-"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 返回的线程又将Worker做了一层封装,当该线程执行strart方法时,将会调用Worker的run方法</span></span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(group, r,</span><br><span class="line">                                  namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                                  <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">                t.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">                t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// jdk定义的线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 核心线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line">    <span class="comment">// 最大线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maximumPoolSize;</span><br><span class="line">    <span class="comment">// 阻塞队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line">    <span class="comment">// 非工作线程存活时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> keepAliveTime;</span><br><span class="line">    <span class="comment">// 创建线程的工厂</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;</span><br><span class="line">    <span class="comment">// 线程池的拒绝策略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line">    <span class="comment">// 存储创建好的Worker线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br><span class="line">    <span class="comment">// 主锁,对workers进行操作时会上锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义线程池内部的工作线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="comment">// 当前Worker持有的线程</span></span><br><span class="line">        <span class="keyword">final</span> Thread thread;</span><br><span class="line">        <span class="comment">// 当前Worker执行的第一个任务</span></span><br><span class="line">        Runnable firstTask;</span><br><span class="line">        <span class="comment">// 记录当前Worker已经完成的任务数量</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">        Worker(Runnable firstTask) &#123;</span><br><span class="line">            <span class="comment">// 将aqs中的state值由0设置为-1,禁止中断(上锁了)</span></span><br><span class="line">            setState(-<span class="number">1</span>); </span><br><span class="line">            <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">            <span class="comment">// 调用工厂为当前的Worker创建一个Thread—&gt;传入的是当前this对象</span></span><br><span class="line">            <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前Worker线程启动需要执行的方法，该方法会由内部属性thread调用start方法时触发。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            runWorker(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断线程是否被独占</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试获取锁</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Thread t;</span><br><span class="line">            <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// Worker线程执行的真正逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">        Thread wt = Thread.currentThread();</span><br><span class="line">        Runnable task = w.firstTask;</span><br><span class="line">        w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">        w.unlock();<span class="comment">//执行任务之前允许被打断</span></span><br><span class="line">        <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 当前worker的task不为null或者是阻塞队列不为null,worker线程会一直运行</span></span><br><span class="line">            <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 上锁</span></span><br><span class="line">                w.lock();</span><br><span class="line">                <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                     (Thread.interrupted() &amp;&amp;</span><br><span class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                    !wt.isInterrupted())</span><br><span class="line">                    wt.interrupt();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beforeExecute(wt, task);</span><br><span class="line">                    Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 调用worker的run方法</span></span><br><span class="line">                        task.run();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        afterExecute(task, thrown);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="keyword">null</span>;</span><br><span class="line">                    w.completedTasks++;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            processWorkerExit(w, completedAbruptly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化一个线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.若是当前工作线程数小于核心线程数, 会去创建一个核心线程。</span></span><br><span class="line">    <span class="comment">// 2.若是当前工作线程数大于等于核心线程数，将任务放入到阻塞队列。</span></span><br><span class="line">    <span class="comment">// 3.若是阻塞队列已满，会去创建非核心线程。</span></span><br><span class="line">    <span class="comment">// 4.若是创建非核心线程也失败，执行拒绝策略。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.尝试着将工作线程数加1，workers的个数。</span></span><br><span class="line">    <span class="comment">// 2.创建一个Worker线程，并将其加入到workers数组中。</span></span><br><span class="line">    <span class="comment">// 3.若是加入到workers数组成功，调用worker的thread的start方法，启动线程。</span></span><br><span class="line">    <span class="comment">// 4.线程启动之后，会调用worker的run方法，而run方法又是调用runWorker(this)方法来执行的。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">        retry:</span><br><span class="line">        <span class="comment">// 自旋</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">            <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                   ! workQueue.isEmpty()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">                <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                    wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                    <span class="keyword">break</span> retry;</span><br><span class="line">                c = ctl.get();</span><br><span class="line">                <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                    <span class="keyword">continue</span> retry;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">        Worker w = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">            <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">                mainLock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">                    <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                        (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (t.isAlive())</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                        <span class="comment">// 将创建好的Worker加入到workers数组中</span></span><br><span class="line">                        workers.add(w);</span><br><span class="line">                        <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                        <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                            largestPoolSize = s;</span><br><span class="line">                        workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    mainLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                    t.start();</span><br><span class="line">                    workerStarted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">                addWorkerFailed(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> workerStarted;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// spring线程池-&gt;ThreadPoolTaskExecutor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTaskExecutor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object poolSizeMonitor = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="comment">// 核心线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> corePoolSize = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 最大线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxPoolSize = <span class="number">2147483647</span>;</span><br><span class="line">    <span class="comment">// 非核心线程空闲最大存活时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> keepAliveSeconds = <span class="number">60</span>;</span><br><span class="line">    <span class="comment">// 缓存队列容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> queueCapacity = <span class="number">2147483647</span>;</span><br><span class="line">    <span class="comment">// 是否允许核心线程池超时等待(设置为false,当到达一定时间没有任务,线程池会自动关闭)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> allowCoreThreadTimeOut = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> TaskDecorator taskDecorator;</span><br><span class="line">    <span class="keyword">private</span> ThreadPoolExecutor threadPoolExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolTaskExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 因为spring线程池提供了更加灵活的配置，项目中一般使用的是spring的线程池。</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;&lt;code&gt;线程池&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 创建线
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="并发" scheme="https://zhilongao.github.io/categories/java/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="线程池" scheme="https://zhilongao.github.io/categories/java/%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>lock</title>
    <link href="https://zhilongao.github.io/wiki/lock/"/>
    <id>https://zhilongao.github.io/wiki/lock/</id>
    <published>2019-08-25T06:28:41.000Z</published>
    <updated>2019-08-26T13:16:50.804Z</updated>
    
    <content type="html"><![CDATA[<hr><p><code>前戏</code>java里面提供了两种锁机制，基于jvm层面实现的关键字synchronized和基于jdk层面实现的Lock锁。</p><hr><p><code>synchronized关键字</code></p><p><code>基本使用</code>：synchronized关键字可以用来修饰静态方法，普通方法，代码块，获取到的锁对象分别为当前类Class对象，当前实例对象和synchronized括号里面的对象。</p><p><code>加锁原理</code>：synchronized加锁是基于对象监视器Monitor的monitorenter和monitorexit。在java中，每个对象都会有一个对象监视器，当synchronized修饰代码块时，在开始位置会加上monitorenter指令，在方法结束和异常处会插入monitorexit指令。当执行monitorentrt指令时，会去获取锁的Monitor对象，若是获取到，执行，获取不到的话，线程阻塞。</p><p><code>synchronized的锁升级</code></p><p>​    <code>偏向锁</code>：当线程执行时，会去修改对象的对象头（Mark Word）中线程id，若是修改成功，执行。若是修改不成功，需要将偏向锁升级为轻量级锁。锁升级的过程是，该获取锁的线程通知Mark Word中标识的线程，使其进入暂停状态。</p><p>​    <code>轻量级锁</code>：争抢锁的线程会去将对象的对象头（Mark Word）拷贝的线程栈中，并将对象头指向该栈（cas操作），若是执行成功，获取到锁，执行代码。若是执行失败，自旋等待其它线程释放锁。</p><p>​    <code>重量级锁</code>：当自旋超过了一定的时间之后，若是还不能获取到锁，将会升级为重量级锁，线程阻塞。</p><hr><p><code>Lock接口</code></p><table><thead><tr><th>特性</th><th>描述</th></tr></thead><tbody><tr><td>尝试非阻塞的获取锁</td><td>当前线程尝试获取锁，若这一时刻锁没有被其它线程获取到，则成功获取并持有锁。</td></tr><tr><td>能被中断的获取锁</td><td>获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放。</td></tr><tr><td>超时获取锁</td><td>在指定的时间之前获取锁，如果过了指定的时间任然无法获取到锁，则返回。</td></tr></tbody></table><table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td>void lock()</td><td>线程获取锁，当获取到锁后，线程从该方法返回。</td></tr><tr><td>void lockInterruptibly() throws InteruptedExecption</td><td>与lock方法不同之处在于可以在获取锁的过程中中断当前的线程。</td></tr><tr><td>boolean tryLock()</td><td>尝试获取锁，获取到返回true，未获取到返回false。</td></tr><tr><td>boolean tryLock(long time, TimeUnit unit) throws InteruptedException;</td><td>尝试获取锁，下列三种情况下会返回：1.在指定的时间内获取到锁。2.过了超时时间为获取到锁。3.当前线程被中断。</td></tr><tr><td>void unlock()</td><td>释放锁</td></tr><tr><td>Condition newCondition()</td><td>获取等待通知组件，只有成功获取到了锁，才能创建该组件</td></tr></tbody></table><hr><p><code>lock和synchronized的区别</code></p><p>​        <code>关于加锁和释放锁方式和原理的不同</code></p><ul><li><p>synchronized是jvm层面提供的关键字，获取锁和释放锁不需要手工干预。synchronized获取锁时会获取锁定对象(静态方法-&gt;类对象，普通方法-&gt;当前对象，代码块-&gt;提供的对象)的对象监视器Monitor。一旦一个线程获取到这个对象的Monitor,其它线程就无法获取。但是同一个线程对这个Monitor可以多次获取（可重入）。对于锁的释放，当方法正常执行结束或者发生异常时，会释放该锁。</p></li><li><p>lock锁是jdk层面提供的锁，可以基于api执行上锁和解锁操作，操作更加的灵活。Lock接口实现的可重入锁ReentLock，其底层是依赖于AQS实现，AQS内部维护了一个同步队列，获取锁的线程会被加入到这个同步队列上面，等待前一个获取锁的节点释放锁时唤醒。ReentLock提供了多种获取锁的方式，可以在获取锁的时候立即响应中断。</p><p><code>关于等待队列和同步队列的不同</code></p></li><li><p>synchronized基于对象监视器，调用底层的wait方法时，会将线程加入到等待队列中，内部只维护了一个等待队列，而调用notify或者notifyAll时，会将唤醒的线程加入到同步队列。</p></li><li><p>ReentLock内部可以创建多个等待队列，可以调用await方法将获取到锁的线程加入到等待队列，也可以调用singal,singalAll唤醒线程，将其加入到同步队列中。</p></li></ul><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;&lt;code&gt;前戏&lt;/code&gt;java里面提供了两种锁机制，基于jvm层面实现的关键字synchronized和基于jdk层面实现的Lock锁。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;code&gt;synchronized关键字&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;基本使用&lt;
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="并发" scheme="https://zhilongao.github.io/categories/java/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="锁" scheme="https://zhilongao.github.io/categories/java/%E5%B9%B6%E5%8F%91/%E9%94%81/"/>
    
    
  </entry>
  
  <entry>
    <title>http</title>
    <link href="https://zhilongao.github.io/wiki/http/"/>
    <id>https://zhilongao.github.io/wiki/http/</id>
    <published>2019-08-24T01:51:41.000Z</published>
    <updated>2019-08-27T09:55:26.475Z</updated>
    
    <content type="html"><![CDATA[<hr><ol><li><p>对http协议的理解</p><p>​    http协议是一种基于客户端-&gt;服务器模式的协议，客户端发送请求，服务器返回响应。http协议通过uri定位访问的资源。http协议是一种无状态的协议，服务 器无法识别同一浏览器的前后两次请求（为解决无状态,浏览器端引入了cookie机制）。</p></li></ol><hr><ol start="2"><li>http响应状态码</li></ol><table><thead><tr><th>状态码</th><th>类别</th><th>原因短语</th></tr></thead><tbody><tr><td>1XX</td><td>Informational（信息性状态码）</td><td>接收的请求正在处理</td></tr><tr><td>2XX</td><td>Success（成功状态码）</td><td>请求正常处理完毕</td></tr><tr><td>3XX</td><td>Redirection（重定向状态码）</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td>Client Error（客户端错误）</td><td>服务器无法处理请求</td></tr><tr><td>5XX</td><td>Server Error （服务端错误）</td><td>服务器处理请求出错</td></tr></tbody></table><hr><ol start="3"><li><p>http请求首部常用字段</p><p>Accept：用户代理可处理的媒体类型。</p><p>Accept-Encoding：优先的内容编码。</p><p>Accept-Language：优先的语言。</p><p>Content-Type：实体类型。</p></li></ol><hr><ol start="4"><li>跨域问题</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;对http协议的理解&lt;/p&gt;
&lt;p&gt;​    http协议是一种基于客户端-&amp;gt;服务器模式的协议，客户端发送请求，服务器返回响应。http协议通过uri定位访问的资源。http协议是一种无状态的协议，服务 器无法识别同一浏览器的前后两次请求（
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="分布式" scheme="https://zhilongao.github.io/categories/java/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="协议" scheme="https://zhilongao.github.io/categories/java/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%8D%8F%E8%AE%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>io</title>
    <link href="https://zhilongao.github.io/wiki/io/"/>
    <id>https://zhilongao.github.io/wiki/io/</id>
    <published>2019-08-23T09:43:24.000Z</published>
    <updated>2019-08-31T03:59:42.888Z</updated>
    
    <content type="html"><![CDATA[<hr><p>1.在jdk1.4，java引入了nio，nio是一种非阻塞io。</p><hr><ol start="2"><li>在nio中有三个概念</li></ol><ul><li><p>缓冲区(buffer)：java nio中数据的读取和存放需要通过缓冲区。</p></li><li><p>通道(channel)：可以理解为io中流的概念 ，与流不同的是，一个通道中既可以进行数据的读取，也可以进行数据的写入，而在io模型中，数据的读取和写入会有专门的输入和输出流来进行操作。</p></li><li><p>选择器(select)：通道可以在选择器上注册相关的事件，而选择器会有一个专门的线程来负责轮询这些事件，当某个写入事件或是读取事件可写或可读时，会交给相应的线程来处理。</p></li></ul><hr><ol start="3"><li>通过java nio模拟一个服务端-客户端通信的实例</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * NIO Server服务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span></span>&#123;</span><br><span class="line">    <span class="comment">// Selector-&gt;注册channel</span></span><br><span class="line">    Selector selector = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// ServerSocketChannel-&gt;服务端channel,类似ServerSocket</span></span><br><span class="line">    ServerSocketChannel serverSocketChannel;</span><br><span class="line">    <span class="comment">// 处理selector轮询事件</span></span><br><span class="line">    <span class="keyword">private</span> ChannelHandle handle;</span><br><span class="line">    <span class="comment">// NIO服务关闭标识</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    NIOServer(<span class="keyword">int</span> port) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">            <span class="comment">// 设置channel为非阻塞模式</span></span><br><span class="line">            serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 为channel绑定端口</span></span><br><span class="line">            serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">            <span class="comment">// 将channel注册到selector上，监听连接事件</span></span><br><span class="line">            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            handle = <span class="keyword">new</span> ChannelHandle();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动服务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">            <span class="comment">// 获取到等待处理的IO事件数量</span></span><br><span class="line">            <span class="keyword">int</span> readyChannels = selector.select();</span><br><span class="line">            <span class="comment">// 若是等待处理的IO事件数量为0,不处理</span></span><br><span class="line">            <span class="keyword">if</span> (readyChannels == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="comment">// 处理这些SelectionKey</span></span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                <span class="comment">// 获取到该key</span></span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line">                <span class="comment">// 移除该key</span></span><br><span class="line">                iterator.remove();</span><br><span class="line">                <span class="comment">// 分别处理各自事件</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    handle.handleAccept(key);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                    handle.handleRead(key);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">                    handle.handleWrite(key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止该服务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stop = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 针对selector上不同事件的处理类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChannelHandle</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理连接事件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleAccept</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel ssc = (ServerSocketChannel) key.channel();</span><br><span class="line">        SocketChannel sc = ssc.accept();</span><br><span class="line">        sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        sc.register(key.selector(), SelectionKey.OP_READ);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理可读事件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRead</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">        <span class="comment">// fixme 对读取到的数据进行处理-&gt;相关协议解析</span></span><br><span class="line">        sc.register(key.selector(), SelectionKey.OP_WRITE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理可写事件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleWrite</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"处理写数据"</span>);</span><br><span class="line">        <span class="comment">// fixme 对输出结果按照相关协议进行封装</span></span><br><span class="line">        String header = <span class="string">"HTTP/1.1 200 OK\r\n"</span>;</span><br><span class="line">        StringBuffer result = <span class="keyword">new</span> StringBuffer(header);</span><br><span class="line">        result.append(<span class="string">"Content-Type:application/json\n"</span>);</span><br><span class="line">        result.append(<span class="string">"\r\n"</span>);</span><br><span class="line">        result.append(<span class="string">"hello,world"</span>);</span><br><span class="line">        SocketChannel channel = (SocketChannel)key.channel();</span><br><span class="line">        ByteBuffer wrap = ByteBuffer.wrap(result.toString().getBytes());</span><br><span class="line">        channel.write(wrap);</span><br><span class="line">        channel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 启动一个基于NIO的服务</span></span><br><span class="line">        NIOServer nioServer = <span class="keyword">new</span> NIOServer(<span class="number">8070</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            nioServer.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>下面是通过java io的方式来实现的</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IOServer.createServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOServer</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开启服务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService =</span><br><span class="line">                Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8090</span>);</span><br><span class="line">            System.out.println(<span class="string">"服务器在端口8090上启动。。。"</span>);</span><br><span class="line">            <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Socket socket = serverSocket.accept();</span><br><span class="line">                    <span class="comment">// 将任务提交给线程池来处理</span></span><br><span class="line">                    executorService.execute(<span class="keyword">new</span> SocketHandle(socket));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (serverSocket !=  <span class="keyword">null</span>) &#123;</span><br><span class="line">                    serverSocket.close();</span><br><span class="line">                &#125;</span><br><span class="line">                executorService.shutdown();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭服务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stopServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stop = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * socket处理线程类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SocketHandle</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">    SocketHandle(Socket socket) &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理输入</span></span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        InputStreamReader isr = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            is = socket.getInputStream();</span><br><span class="line">            isr = <span class="keyword">new</span> InputStreamReader(is);</span><br><span class="line">            br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">            String s = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> ((s = br.readLine()) != <span class="keyword">null</span> &amp;&amp; s.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">                s = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理输出 \r\n 回车换行</span></span><br><span class="line">        OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            os = socket.getOutputStream();</span><br><span class="line">            os.write(<span class="string">"HTTP/1.1 200 OK\r\n"</span>.getBytes());</span><br><span class="line">            os.write(<span class="string">"Content-Type:application/json\n"</span>.getBytes());</span><br><span class="line">            os.write(<span class="string">"\r\n"</span>.getBytes());</span><br><span class="line">            os.write(<span class="string">"hello,world"</span>.getBytes());</span><br><span class="line">            os.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;1.在jdk1.4，java引入了nio，nio是一种非阻塞io。&lt;/p&gt;
&lt;hr&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;在nio中有三个概念&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;缓冲区(buffer)：java nio中数据的读取和存放需要通过缓冲区
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="基础" scheme="https://zhilongao.github.io/categories/java/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="io" scheme="https://zhilongao.github.io/categories/java/%E5%9F%BA%E7%A1%80/io/"/>
    
    
  </entry>
  
  <entry>
    <title>thread</title>
    <link href="https://zhilongao.github.io/wiki/thread/"/>
    <id>https://zhilongao.github.io/wiki/thread/</id>
    <published>2019-08-21T05:43:50.000Z</published>
    <updated>2019-08-26T13:29:52.496Z</updated>
    
    <content type="html"><![CDATA[<hr><p><code>为什么使用多线程</code></p><p>​    更多的处理器核心    更快的响应时间    更好的编程模型</p><hr><p><code>线程的六种状态</code></p><table><thead><tr><th>状态</th><th>状态说明</th></tr></thead><tbody><tr><td>NEW</td><td>初始状态，线程已经被构建，但是没有调用start()方法。</td></tr><tr><td>RUNNABLE</td><td>线程处于运行状态或者是可运行状态。</td></tr><tr><td>BLOCKED</td><td>阻塞状态，表示当前线程等待获取锁。</td></tr><tr><td>WAITING</td><td>等待状态，需要其他线程唤醒。</td></tr><tr><td>TIME_WAITING</td><td>超时等待状态，需要其他线程唤醒或者过了超时时间自动唤醒。</td></tr><tr><td>TERMINATED</td><td>终止状态，表示当前线程已经运行结束。</td></tr></tbody></table><hr><p><code>如何查看线程信息</code></p><p>​    jps:该命令可以获取进程id。</p><p>​    jstack:使用 jstack 进程id，可以查看线程的一些信息。</p><hr><p><code>线程的初始化</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"name cannot be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="comment">// 创建的这个线程的父线程就是当前的这个线程</span></span><br><span class="line">    Thread parent = currentThread();</span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">            g = security.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">            g = parent.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    g.checkAccess();</span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isCCLOverridden(getClass())) &#123;</span><br><span class="line">            security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    g.addUnstarted();</span><br><span class="line"><span class="comment">// 设置当前线程的线程组信息</span></span><br><span class="line">    <span class="keyword">this</span>.group = g;</span><br><span class="line">    <span class="comment">// 将daemon priority设置为父线程的相关属性</span></span><br><span class="line">    <span class="keyword">this</span>.daemon = parent.isDaemon();</span><br><span class="line">    <span class="keyword">this</span>.priority = parent.getPriority();</span><br><span class="line">    <span class="keyword">if</span> (security == <span class="keyword">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.contextClassLoader;</span><br><span class="line">    <span class="keyword">this</span>.inheritedAccessControlContext =</span><br><span class="line">        acc != <span class="keyword">null</span> ? acc : AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">    setPriority(priority);</span><br><span class="line">    <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">        ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line">    tid = nextThreadID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><code>如何优雅的终止线程</code></p><p>​    使用volidate修饰的变量    中断线程interrupt()方法</p><hr><p>在class所在目录下，使用javap -v HelloWorld.class指令可以查看该class的信息</p><hr><p>管道输入输出流–&gt;用于线程之间数据的传输，传输媒介为内存</p><p>​    PipedInputStream </p><p>​    PipedOutputStram</p><p>​    PipedReader</p><p>​    PipedWriter</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;&lt;code&gt;为什么使用多线程&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;​    更多的处理器核心    更快的响应时间    更好的编程模型&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;code&gt;线程的六种状态&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;状态&lt;/t
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="并发" scheme="https://zhilongao.github.io/categories/java/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="基础" scheme="https://zhilongao.github.io/categories/java/%E5%B9%B6%E5%8F%91/%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>springboot</title>
    <link href="https://zhilongao.github.io/wiki/springboot/"/>
    <id>https://zhilongao.github.io/wiki/springboot/</id>
    <published>2019-08-21T01:58:17.000Z</published>
    <updated>2019-08-31T04:01:53.338Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AutoConfigurationImportSelector</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">    <span class="comment">// 判断自动装配是否开启，读取环境变量中spring.boot.enableautoconfiguration的属性值</span></span><br><span class="line">    <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取到autoConfigurationMetadata</span></span><br><span class="line">    AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader</span><br><span class="line">        .loadMetadata(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">    </span><br><span class="line">    AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(autoConfigurationMetadata,</span><br><span class="line">                                                                              annotationMetadata);</span><br><span class="line">    <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(AutoConfigurationMetadata autoConfigurationMetadata,AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 做了重复判断</span></span><br><span class="line">    <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// 获取到@EnableAutoConfiguration注解上的相关属性值exclude excludeName</span></span><br><span class="line">    AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">    <span class="comment">// 获取到需要自动装配的类的全限定名集合</span></span><br><span class="line">    List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">    <span class="comment">// 将互选名单先进行去重</span></span><br><span class="line">    configurations = removeDuplicates(configurations);</span><br><span class="line">    <span class="comment">// 获取需要排除的自动装配项exclude excludeName或者是环境变量中获取</span></span><br><span class="line">    Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">    checkExcludedClasses(configurations, exclusions);</span><br><span class="line">    <span class="comment">// 将需要排除的自动装配项移除</span></span><br><span class="line">    configurations.removeAll(exclusions);</span><br><span class="line">    <span class="comment">// 过滤掉相关的装配项</span></span><br><span class="line">    configurations = filter(configurations, autoConfigurationMetadata);</span><br><span class="line">    <span class="comment">// 触发自动装配组件的导入事件</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AnnotationAttributes <span class="title">getAttributes</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取到EnableAutoConfiguration注解的全限定名</span></span><br><span class="line">    <span class="comment">// org.springframework.boot.autoconfigure.EnableAutoConfiguration</span></span><br><span class="line">    String name = getAnnotationClass().getName();</span><br><span class="line">    <span class="comment">// 获取该@EnableAutoConfiguration注解上的exclude和excludeName属性</span></span><br><span class="line">    AnnotationAttributes attributes = AnnotationAttributes.fromMap(metadata.getAnnotationAttributes(name, <span class="keyword">true</span>));</span><br><span class="line">    Assert.notNull(attributes, () -&gt; <span class="string">"No auto-configuration attributes found. Is "</span> + metadata.getClassName()</span><br><span class="line">                   + <span class="string">" annotated with "</span> + ClassUtils.getShortName(name) + <span class="string">"?"</span>);</span><br><span class="line">    <span class="keyword">return</span> attributes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过spring的spi机制SpringFactoriedLoader加载需要自动装配的候选组件类全限定名</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),                                                                         getBeanClassLoader());</span><br><span class="line">    <span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取被排除在外的类全限定名</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Set&lt;String&gt; <span class="title">getExclusions</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; excluded = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">    excluded.addAll(asList(attributes, <span class="string">"exclude"</span>));</span><br><span class="line">    excluded.addAll(Arrays.asList(attributes.getStringArray(<span class="string">"excludeName"</span>)));</span><br><span class="line">    excluded.addAll(getExcludeAutoConfigurationsProperty());</span><br><span class="line">    <span class="keyword">return</span> excluded;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从环境变量中获取spring.autoconfigure.exclude属性的值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">getExcludeAutoConfigurationsProperty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getEnvironment() <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">        Binder binder = Binder.get(getEnvironment());</span><br><span class="line">        <span class="keyword">return</span> binder.bind(PROPERTY_NAME_AUTOCONFIGURE_EXCLUDE, String[].class).map(Arrays::asList).orElse(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    String[] excludes = getEnvironment().getProperty(PROPERTY_NAME_AUTOCONFIGURE_EXCLUDE, String[].class);</span><br><span class="line">    <span class="keyword">return</span> (excludes != <span class="keyword">null</span>) ? Arrays.asList(excludes) : Collections.emptyList();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对配置项执行过滤的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">filter</span><span class="params">(List&lt;String&gt; configurations, AutoConfigurationMetadata autoConfigurationMetadata)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line">    String[] candidates = StringUtils.toStringArray(configurations);</span><br><span class="line">    <span class="keyword">boolean</span>[] skip = <span class="keyword">new</span> <span class="keyword">boolean</span>[candidates.length];</span><br><span class="line">    <span class="keyword">boolean</span> skipped = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 关键点-&gt;getAutoConfigurationImportFilters()</span></span><br><span class="line">    <span class="keyword">for</span> (AutoConfigurationImportFilter filter : getAutoConfigurationImportFilters()) &#123;</span><br><span class="line">        invokeAwareMethods(filter);</span><br><span class="line">        <span class="keyword">boolean</span>[] match = filter.match(candidates, autoConfigurationMetadata);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; match.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!match[i]) &#123;</span><br><span class="line">                skip[i] = <span class="keyword">true</span>;</span><br><span class="line">                candidates[i] = <span class="keyword">null</span>;</span><br><span class="line">                skipped = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!skipped) &#123;</span><br><span class="line">        <span class="keyword">return</span> configurations;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(candidates.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; candidates.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!skip[i]) &#123;</span><br><span class="line">            result.add(candidates[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AutoConfigurationImportFilter实现类加载</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;AutoConfigurationImportFilter&gt; <span class="title">getAutoConfigurationImportFilters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SpringFactoriesLoader.loadFactories(AutoConfigurationImportFilter.class, <span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SpringFactoriesLoader</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    String factoryClassName = factoryClass.getName();</span><br><span class="line">    <span class="comment">// 第一步:获取所有列表  第二步:获取指定key的列表</span></span><br><span class="line">    <span class="keyword">return</span> loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// classLoader属性值可以为null</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">loadFactories</span><span class="params">(Class&lt;T&gt; factoryClass, @Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// classLoader未指定,使用默认的classLoader</span></span><br><span class="line">    ClassLoader classLoaderToUse = classLoader;</span><br><span class="line">    <span class="keyword">if</span> (classLoaderToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">        classLoaderToUse = SpringFactoriesLoader.class.getClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用loadFactoryNames加载指定key的扩展</span></span><br><span class="line">    List&lt;String&gt; factoryNames = loadFactoryNames(factoryClass, classLoaderToUse);</span><br><span class="line">    List&lt;T&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(factoryNames.size());</span><br><span class="line">    <span class="keyword">for</span> (String factoryName : factoryNames) &#123;</span><br><span class="line">        result.add(instantiateFactory(factoryName, factoryClass, classLoaderToUse));</span><br><span class="line">    &#125;</span><br><span class="line">    AnnotationAwareOrderComparator.sort(result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// AutoConfigurationImportSelector&lt;
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="框架" scheme="https://zhilongao.github.io/categories/java/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="springboot" scheme="https://zhilongao.github.io/categories/java/%E6%A1%86%E6%9E%B6/springboot/"/>
    
    
  </entry>
  
</feed>
