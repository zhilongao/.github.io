<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zl&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhilongao.github.io/"/>
  <updated>2019-09-12T02:46:20.517Z</updated>
  <id>https://zhilongao.github.io/</id>
  
  <author>
    <name>gaozhilong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>questions</title>
    <link href="https://zhilongao.github.io/wiki/questions/"/>
    <id>https://zhilongao.github.io/wiki/questions/</id>
    <published>2019-09-12T02:40:03.000Z</published>
    <updated>2019-09-12T02:46:20.517Z</updated>
    
    <content type="html"><![CDATA[<ol><li>说说dubbo服务上下线时你们是如何处理的?</li><li>dubbo的协议有哪些,哪些使用场景?</li><li>dubbo使用的系列化框架是什么?</li><li>dubbo服务容错机制?</li><li>socket协议的几种状态,socket协议的三次握手,为什么是三次握手?</li><li>说说nio和io有什么不同,nio有哪些场景?</li><li>http请求有哪些方法?</li><li>jdk1.8有哪些新特性,使用过哪些?</li><li>谈谈对GC的理解，对G1有了解吗?</li><li>Collection.sort底层默认使用哪种排序算法，说说你熟悉的排序算法有哪些?</li><li>基本数据类型,占用字节,包装类,为什么会有包装类?</li><li>多线程你们在项目中怎么用的?</li><li>jdk1.8中Stream在并行处理时，适合哪些情景，不适合哪些情景?(第一次遇到这样问的,没回答上来)<br>适合计算密集型,不适合IO密集型。因为Stream被分配到的是核心线程池，IO密集型会造成线程阻塞。</li><li>你们reids在使用中，过期时间是怎么设置的，分两步设置不能保证原子性，怎么解决的?</li><li>写一下二分查找算法？</li><li>写一个单例?(DCL)？</li><li>说说dubbo和spring cloud有什么区别?</li><li>你们数据库是怎么优化的,说说实例?</li><li>了解redis吗，说说redis基本数据结构，有哪些常用的指令？</li></ol><hr><p>1、说说 dubbo 的执行流程<br>2、redis 基本数据结构，你们是怎么用的（讲了下 5 分钟发帖 10 次）<br>3、数据库连接池了解吗？<br>4、生产环境项目打印日志出现了时间长的现象，你怎么排查<br>5、接口出现频繁 GC ，怎么排查</p><hr><p>1 线程池用过哪些，在项目中是怎么使用的</p><p>2 sql优化怎么做的，哪些情况触发不了索引 , sql优化除了索引还要看哪些指标</p><p>3 redis有没有遇到数据库满了的情况</p><p>4  说说redis cluster</p><p>5 springmvc  springboot springcloud的区别</p><p>6 对restful有了解吗，弹弹restful</p><p>7 说说对spring的理解</p><p>8 @Autowired和@Resource的区别</p><p>9 设计模式有哪些了解，说说设计模式遵循的原则</p><p>10 交给你一个项目，怎么推进</p><p>11 通过哪些途径学习，看些什么书</p><p>12 总结下自己</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;说说dubbo服务上下线时你们是如何处理的?&lt;/li&gt;
&lt;li&gt;dubbo的协议有哪些,哪些使用场景?&lt;/li&gt;
&lt;li&gt;dubbo使用的系列化框架是什么?&lt;/li&gt;
&lt;li&gt;dubbo服务容错机制?&lt;/li&gt;
&lt;li&gt;socket协议的几种状态,socket协
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="面试题" scheme="https://zhilongao.github.io/categories/java/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>linux系统</title>
    <link href="https://zhilongao.github.io/wiki/linux-system-problem/"/>
    <id>https://zhilongao.github.io/wiki/linux-system-problem/</id>
    <published>2019-09-09T12:19:57.000Z</published>
    <updated>2019-09-10T06:35:55.531Z</updated>
    
    <content type="html"><![CDATA[<h6 id="linux三种网络模式"><a href="#linux三种网络模式" class="headerlink" title="linux三种网络模式"></a><code>linux三种网络模式</code></h6><p>在我们安装vmware的时候，vmware会为三种网络模式各自创建一个虚拟机网络, 其中 VMnet0(表示桥接模式) VMnet8(NAT模式) VMnet1(仅主机模式) </p><hr><p>桥接模式<br>    和主机一样，也会占用一个局域网中的ip。信息的发送和接受，虚拟网络适配器和主机的物理网络适配器进行交换，虚拟网络适配器可以通过主机的物理网络适配器访问外部网络。在局域网中的其它主机能够识别到发送信息的ip为该虚拟机的ip。 </p><p>NAT模式<br>    虚拟机发送数据时，NAT虚拟机网络适配器会以主机的名义将数据包裹发送出去，接收时通过特殊的标识识别。在外部网络中并不知道当前虚拟机的存在。</p><p>主机模式<br>    仅可以和主机通信，无法访问外部网络。</p><hr><p>​    <a href="https://www.cnblogs.com/xuan52rock/p/5295069.html" target="_blank" rel="noopener">一篇介绍的很形象的文章</a></p><hr><h6 id="centos7之动态ip与静态ip"><a href="#centos7之动态ip与静态ip" class="headerlink" title="centos7之动态ip与静态ip"></a><code>centos7之动态ip与静态ip</code></h6><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">centos7获取ip地址的方法主要有两种 1:动态获取  2:设置静态ip</span><br><span class="line"></span><br><span class="line">我们一般通过VMWare安装完centos7后，可以使用命令ip addr查看虚拟机的ip地址。但是刚安装完的centos7有些没有设置ip地址，我们可以通过下面两种方式来设置ip地址。</span><br><span class="line"></span><br><span class="line">1. 动态获取ip(前提是路由器已经开启了DHCP(动态主机设置协议))</span><br><span class="line">  a: 需要修改网卡的配置文件 /etc/sysconfig/network-scripts/ifcfg-ens33 其中ifcfg-ens33为网卡名。修改该文件的两处地方既可。</span><br><span class="line">   (1) bootproto=dhcp</span><br><span class="line">   (2) onboot=yes</span><br><span class="line">  b: 重启下网络服务</span><br><span class="line">   [root@mini ~]# systemctl restart network</span><br><span class="line">  c: 通过 ip addr 命令可以看到ens33的网卡已经有相应的ip地址啦</span><br><span class="line">  d: 通过 ping www.baidu.com 查看网络是否通畅</span><br><span class="line">  </span><br><span class="line">在VMware里，点击'编辑'-'虚拟网络编辑器'  </span><br><span class="line">2. 配置静态ip地址(网络模式在nat模式下)</span><br><span class="line">  a: 也是需要修改网卡配置文件 /etc/sysconfig/network-srcipts/ifcfg-ens33 其中ifcfg-ens33为网卡名。修改该文件的两处地方既可。</span><br><span class="line">   (1) bootproto=static</span><br><span class="line">   (2) onboot=yes </span><br><span class="line">  b: 还需要在该网卡配置文件的后面加上几行，分别是ip地址，子网掩码，网关，dns服务器</span><br><span class="line">    IPADDR=192.168.25.156 #静态ip</span><br><span class="line">    NETMASK=255.255.255.0 #子网掩码</span><br><span class="line">    GATEWAY=192.168.1.1 #网关</span><br><span class="line">    DNS1=192.168.25.2</span><br><span class="line">    DNS2=8.8.8.8 #谷歌的dns服务器</span><br><span class="line">  c: 重启下网络服务</span><br><span class="line">  [root@mini ~]# systemctl restart network</span><br><span class="line">  d: 通过 ip addr 命令可以看到ens33的网卡已经有新的ip地址啦</span><br><span class="line">  e: 通过 ping www.baidu.com 查看网络是否通畅</span><br><span class="line"></span><br><span class="line">3. 在 /etc/resolv.conf文件里面保存了dns地址，可以通过cat命令查看</span><br></pre></td></tr></table></figure><p><code>在设置静态ip时,子网掩码和网关地址可以在vmware的-&gt;编辑-&gt;虚拟网络编辑器-&gt;NAT设置 中查看，如下图所示</code></p><p><img src="https://raw.githubusercontent.com/zhilongao/images-repository/master/46f916fdc305a268fe584b8ba809ed3.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;linux三种网络模式&quot;&gt;&lt;a href=&quot;#linux三种网络模式&quot; class=&quot;headerlink&quot; title=&quot;linux三种网络模式&quot;&gt;&lt;/a&gt;&lt;code&gt;linux三种网络模式&lt;/code&gt;&lt;/h6&gt;&lt;p&gt;在我们安装vmware的时候，vmware
      
    
    </summary>
    
      <category term="系统" scheme="https://zhilongao.github.io/categories/%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="linux" scheme="https://zhilongao.github.io/categories/%E7%B3%BB%E7%BB%9F/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>字符串</title>
    <link href="https://zhilongao.github.io/wiki/string-ask/"/>
    <id>https://zhilongao.github.io/wiki/string-ask/</id>
    <published>2019-09-06T02:25:40.000Z</published>
    <updated>2019-09-08T02:16:32.432Z</updated>
    
    <content type="html"><![CDATA[<h6 id="无重复字符的最长子串-leetcode第3题"><a href="#无重复字符的最长子串-leetcode第3题" class="headerlink" title="无重复字符的最长子串(leetcode第3题)"></a><code>无重复字符的最长子串(leetcode第3题)</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 滑动窗口解法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = s.length();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">    Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">    <span class="keyword">while</span>(left &lt; length &amp;&amp; right &lt; length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!set.contains(s.charAt(right))) &#123;</span><br><span class="line">            set.add(s.charAt(right ++));</span><br><span class="line">            ans = Math.max(ans, right - left);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            set.remove(s.charAt(left ++));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="最长回文子串-leetcode第5题"><a href="#最长回文子串-leetcode第5题" class="headerlink" title="最长回文子串(leetcode第5题)"></a><code>最长回文子串(leetcode第5题)</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 题目要求:给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</span></span><br><span class="line"><span class="comment">// 1.要判断一个字符串是否为回文字符串，可以通过下面几种方式来实现</span></span><br><span class="line"><span class="comment">// 第一种:通过栈的后进先出原理，将字符串翻转来对比前后两个字符串是否一致</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isHuiWen1</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        stack.push(str.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuffer buf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        buf.append(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (str.equals(buf.toString())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二种: 取消栈的引入，直接通过逆序输出拼接字符串(减少了额外的空间Stack)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isHuiWen2</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    StringBuffer buf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = str.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">        buf.append(str.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (buf.toString().equals(str)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第三中: 基于回文串左右两边两个字符相等的规律，定义两个变量做对比(优势是减少了字符串str的遍历次数，时间复杂度降低)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isHuiWen3</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = str.length();</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(str.charAt(left) == str.charAt(right))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        left ++;</span><br><span class="line">        right --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前这道题如何实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 给定一个字符串s,找到s中最长的回文子串。你可以假设s的最大长度为1000。</span></span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> resultLen = <span class="number">1</span>;</span><br><span class="line">    String resultStr = s.substring(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">        <span class="comment">// 从中间向两边查找对称的回文串</span></span><br><span class="line">        String oddStr = spread(s, len, i, i);</span><br><span class="line">        String evenStr = spread(s, len, i, i+<span class="number">1</span>);</span><br><span class="line">        String myStr = oddStr.length() &gt;= evenStr.length() ? oddStr : evenStr;</span><br><span class="line">        <span class="keyword">if</span> (myStr.length() &gt; resultLen) &#123;</span><br><span class="line">            resultStr = myStr;</span><br><span class="line">            resultLen = resultStr.length();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultStr;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">spread</span><span class="params">(String s, <span class="keyword">int</span> len, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = left;</span><br><span class="line">    <span class="keyword">int</span> r = right;</span><br><span class="line">    <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; len &amp;&amp; (s.charAt(l) == s.charAt(r))) &#123;</span><br><span class="line">        l --;</span><br><span class="line">        r ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(l+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="压缩字符串-leetcode第443题"><a href="#压缩字符串-leetcode第443题" class="headerlink" title="压缩字符串(leetcode第443题)"></a><code>压缩字符串(leetcode第443题)</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 题目要求: 给定一组字符串，使用原地算法将其压缩。</span></span><br><span class="line"><span class="comment">// 题目解法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compress</span><span class="params">(<span class="keyword">char</span>[] chars)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> anchor = <span class="number">0</span>; <span class="comment">// 描点，定位可以元素</span></span><br><span class="line">    <span class="keyword">int</span> write = <span class="number">0</span>; <span class="comment">// 写下标，定位写的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> read = <span class="number">0</span>; read &lt; chars.length; read ++) &#123;</span><br><span class="line">        <span class="comment">// 若是当前元素为最后一个元素或者是后一个元素与当前元素不相等，执行写入与统计写入操作</span></span><br><span class="line">        <span class="keyword">if</span> ((read == chars.length - <span class="number">1</span>) || (chars[read + <span class="number">1</span>] != chars[read])) &#123;</span><br><span class="line">            <span class="comment">// 将anchor位置处的元素写入到write位置处</span></span><br><span class="line">            chars[write ++] = chars[anchor];</span><br><span class="line">            <span class="comment">// 判断该元素是否需要压缩</span></span><br><span class="line">            <span class="keyword">if</span> (read &gt; anchor) &#123;</span><br><span class="line">                String numStr = read - anchor + <span class="number">1</span> + <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">char</span>[] numArr = numStr.toCharArray();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> num : numArr) &#123;</span><br><span class="line">                    chars[write ++] = num;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将锚点移动到下一个元素</span></span><br><span class="line">            anchor = read + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回覆盖的个数</span></span><br><span class="line">    <span class="keyword">return</span> write;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;无重复字符的最长子串-leetcode第3题&quot;&gt;&lt;a href=&quot;#无重复字符的最长子串-leetcode第3题&quot; class=&quot;headerlink&quot; title=&quot;无重复字符的最长子串(leetcode第3题)&quot;&gt;&lt;/a&gt;&lt;code&gt;无重复字符的最长子串(le
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="算法" scheme="https://zhilongao.github.io/categories/java/%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串" scheme="https://zhilongao.github.io/categories/java/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
  </entry>
  
  <entry>
    <title>array-ask</title>
    <link href="https://zhilongao.github.io/wiki/array-ask/"/>
    <id>https://zhilongao.github.io/wiki/array-ask/</id>
    <published>2019-09-05T01:52:30.000Z</published>
    <updated>2019-09-05T12:23:51.735Z</updated>
    
    <content type="html"><![CDATA[<h6 id="寻找递增序列"><a href="#寻找递增序列" class="headerlink" title="寻找递增序列"></a><code>寻找递增序列</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给定一个未经过排序的数组，找到最长且连续的递增序列(在美团面试题中出现过-leetcode674题)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> curr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            curr ++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            max = Math.max(max, curr);</span><br><span class="line">        curr = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(max, curr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;寻找递增序列&quot;&gt;&lt;a href=&quot;#寻找递增序列&quot; class=&quot;headerlink&quot; title=&quot;寻找递增序列&quot;&gt;&lt;/a&gt;&lt;code&gt;寻找递增序列&lt;/code&gt;&lt;/h6&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="算法" scheme="https://zhilongao.github.io/categories/java/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数组" scheme="https://zhilongao.github.io/categories/java/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/"/>
    
    
  </entry>
  
  <entry>
    <title>mongodb-base</title>
    <link href="https://zhilongao.github.io/wiki/mongodb-base/"/>
    <id>https://zhilongao.github.io/wiki/mongodb-base/</id>
    <published>2019-09-03T03:45:03.000Z</published>
    <updated>2019-09-05T11:05:41.293Z</updated>
    
    <content type="html"><![CDATA[<h6 id="安装步骤-centos7"><a href="#安装步骤-centos7" class="headerlink" title="安装步骤(centos7)"></a><code>安装步骤(centos7)</code></h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1.下载安装包</span><br><span class="line">wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel62-3.2.10.tgz</span><br><span class="line">2.解压安装包</span><br><span class="line">tar -zxvf mongodb-linux-x86_64-rhel62-3.2.10.tgz </span><br><span class="line">3.将解压目录移动到(/usr/local/mongodb)</span><br><span class="line">mv mongodb-linux-x86_64-rhel62-3.2.10 /usr/local/mongodb</span><br><span class="line">4.在/usr/local/mongodb目录下创建/data/db目录和/logs目录</span><br><span class="line">mkdir -p /usr/local/mongodb/data/db </span><br><span class="line">mkdir -p /usr/local/mongodb/logs</span><br><span class="line">5.在/usr/local/mongodb/logs目录下创建mongodb.log文件</span><br><span class="line">touch mongodb.log</span><br><span class="line">6.在/usr/local/mongodb/bin目录下创建mongodb的配置文件</span><br><span class="line">touch mongodb.conf</span><br><span class="line">7.编辑mongodb.conf文件</span><br><span class="line">vi mongodb.conf</span><br><span class="line">编辑内容</span><br><span class="line">dbpath = /usr/local/mongodb/data/db #数据文件存放目录</span><br><span class="line">logpath = /usr/local/mongodb/logs/mongodb.log #日志文件存放目录</span><br><span class="line">port = 27017  #端口</span><br><span class="line">fork = true  #以守护程序的方式启用，即在后台运行</span><br><span class="line">nohttpinterface = true</span><br><span class="line">auth=true</span><br><span class="line">bind_ip=0.0.0.0</span><br><span class="line">8.修改环境变量</span><br><span class="line">vi /etc/profile</span><br><span class="line">添加的内容</span><br><span class="line">export MONGODB_HOME=/usr/local/mongodb</span><br><span class="line">export PATH=$PATH:$MONGODB_HOME/bin</span><br><span class="line">9.编辑完成之后重启系统配置</span><br><span class="line">source /etc/profile</span><br><span class="line">10.在/usr/local/mongodb/bin目录下启动mongodb</span><br><span class="line">./mongod -f mongodb.conf</span><br><span class="line">11.关闭mongodb服务</span><br><span class="line">./mongod -f ./mongodb.conf --shutdown</span><br><span class="line">12.开启27017端口</span><br><span class="line"></span><br><span class="line">13.使用shell登录到mongodb</span><br><span class="line">./mongodb</span><br><span class="line"></span><br><span class="line">14.登录到相关数据库</span><br><span class="line">use test</span><br><span class="line"></span><br><span class="line">15.创建用户</span><br><span class="line">db.createUser(</span><br><span class="line">&#123;</span><br><span class="line">user: "test", </span><br><span class="line">pwd: "test", </span><br><span class="line">roles: [&#123; role: "readWrite", db: "test" &#125;]</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line">16.修改配置，开启验证</span><br><span class="line">auth=true</span><br><span class="line">17.重启服务</span><br><span class="line">停止服务，然后启动</span><br><span class="line">18.登录</span><br><span class="line">./mongodb</span><br><span class="line">19.验证</span><br><span class="line">auth('test', 'test')(返回1代表成功)</span><br><span class="line">20.操作</span><br><span class="line">db.user.find()</span><br><span class="line">db.user.insert(&#123;"name":'jack',"age": 12&#125;)</span><br></pre></td></tr></table></figure><h6 id="基本操作-gt-java-api的crud"><a href="#基本操作-gt-java-api的crud" class="headerlink" title="基本操作-&gt;java api的crud"></a><code>基本操作-&gt;java api的crud</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 引入依赖</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.mongodb&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mongo-java-driver&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.9.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.java代码</span><br><span class="line"><span class="comment">// 工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MongoUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String baseUrl = <span class="string">"192.168.25.147:27017"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String userName = <span class="string">"test"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String passWord = <span class="string">"test"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String url = <span class="string">"mongodb://"</span>+ userName +<span class="string">":"</span>+ passWord + <span class="string">"@"</span>+ baseUrl + <span class="string">"/"</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 获取MongoDatabase</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MongoDatabase <span class="title">getConnection</span><span class="params">(String dataName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取MongoClient</span></span><br><span class="line">        com.mongodb.client.MongoClient mongoClient = MongoClients.create(url + dataName);</span><br><span class="line">        <span class="comment">// 获取MongoDatabase</span></span><br><span class="line">        MongoDatabase db = mongoClient.getDatabase(dataName);</span><br><span class="line">        <span class="keyword">return</span> db;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本操作 -&gt; 获取所有</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findAll</span><span class="params">(String databaseName, String collectionName)</span> </span>&#123;</span><br><span class="line">MongoDatabase database = MongoUtil.getConnection(databaseName);</span><br><span class="line">    MongoCollection&lt;Document&gt; collection = database.getCollection(collectionName);</span><br><span class="line">    FindIterable&lt;Document&gt; documents = collection.find();</span><br><span class="line">    print(documents);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本操作 -&gt; 插入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String databaseName, String collectionName)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取database</span></span><br><span class="line">MongoDatabase database = MongoUtil.getConnection(databaseName);</span><br><span class="line"><span class="comment">// 获取Clooection</span></span><br><span class="line">MongoCollection&lt;Document&gt; collection = database.getCollection(collectionName);</span><br><span class="line"><span class="comment">// 创建Document</span></span><br><span class="line">Document document = <span class="keyword">new</span> Document()</span><br><span class="line">                    .append(<span class="string">"name"</span>, <span class="string">"mick11"</span>)</span><br><span class="line">                    .append(<span class="string">"age"</span>, <span class="string">"33"</span>)</span><br><span class="line">                    .append(<span class="string">"address"</span>, <span class="string">"长沙"</span>)</span><br><span class="line">                    .append(<span class="string">"sex"</span>, <span class="string">"男"</span>);</span><br><span class="line">    <span class="comment">// 插入document                </span></span><br><span class="line">collection.insertOne(document);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印所有</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(FindIterable&lt;Document&gt; documents)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (Document document : documents) &#123;</span><br><span class="line">System.out.println(document.toJson());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;安装步骤-centos7&quot;&gt;&lt;a href=&quot;#安装步骤-centos7&quot; class=&quot;headerlink&quot; title=&quot;安装步骤(centos7)&quot;&gt;&lt;/a&gt;&lt;code&gt;安装步骤(centos7)&lt;/code&gt;&lt;/h6&gt;&lt;figure class=&quot;hig
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="数据库" scheme="https://zhilongao.github.io/categories/java/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mongodb" scheme="https://zhilongao.github.io/categories/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb/"/>
    
    
      <category term="mongo" scheme="https://zhilongao.github.io/tags/mongo/"/>
    
  </entry>
  
  <entry>
    <title>实际应用</title>
    <link href="https://zhilongao.github.io/wiki/redis-advance/"/>
    <id>https://zhilongao.github.io/wiki/redis-advance/</id>
    <published>2019-09-02T00:47:25.000Z</published>
    <updated>2019-09-08T09:33:52.783Z</updated>
    
    <content type="html"><![CDATA[<h6 id="list实现分布式队列"><a href="#list实现分布式队列" class="headerlink" title="list实现分布式队列"></a><code>list实现分布式队列</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需要的依赖jedis fastjson</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.9.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line"> &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.2.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/8 15:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String url = <span class="string">"192.168.25.150"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> port = <span class="number">6379</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构建queue</span></span><br><span class="line">        String queueKey = <span class="string">"message_queue"</span>;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(url, port);</span><br><span class="line">        <span class="comment">// 消息转换器</span></span><br><span class="line">        MessageConvert&lt;TaskItem&gt; convert = <span class="keyword">new</span> MessageConvert&lt;&gt;();</span><br><span class="line">        <span class="comment">// 消息队列</span></span><br><span class="line">        RedisQueue queue = <span class="keyword">new</span> RedisQueue(jedis, queueKey, convert);</span><br><span class="line">        <span class="comment">// 生产者</span></span><br><span class="line">        MessageProducer producer = <span class="keyword">new</span> MessageProducer(queue);</span><br><span class="line">        <span class="comment">// 消费者</span></span><br><span class="line">        MessageConsumer consumer = <span class="keyword">new</span> MessageConsumer(queue);</span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息队列</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/8 14:34</span></span><br><span class="line"><span class="comment"> * 分布式消息队列-list实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line">    <span class="keyword">private</span> String queueKey;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisQueue</span><span class="params">(Jedis jedis, String queueKey, MessageConvert messageConvert)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jedis = jedis;</span><br><span class="line">        <span class="keyword">this</span>.queueKey = queueKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.jedis.lpush(queueKey, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费消息-&gt;可重试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">poll</span><span class="params">(<span class="keyword">boolean</span> isRetry)</span> </span>&#123;</span><br><span class="line">        String message = jedis.rpop(queueKey);</span><br><span class="line">        <span class="keyword">if</span> (message == <span class="keyword">null</span> &amp;&amp; isRetry) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            message = jedis.rpop(queueKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/8 15:47</span></span><br><span class="line"><span class="comment"> * 消息生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageProducer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 队列</span></span><br><span class="line">    <span class="keyword">private</span> RedisQueue queue;</span><br><span class="line">    <span class="comment">// 消息转换器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MessageConvert&lt;TaskItem&gt; convert = <span class="keyword">new</span> MessageConvert&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageProducer</span><span class="params">(RedisQueue queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            send(<span class="string">"message:"</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">30</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并发送消息</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一条消息</span></span><br><span class="line">        TaskItem item = <span class="keyword">new</span> TaskItem();</span><br><span class="line">        item.id = UUID.randomUUID().toString();</span><br><span class="line">        item.msg = message;</span><br><span class="line">        <span class="comment">// 转换为字符串发送</span></span><br><span class="line">        String sendMess = convert.messageToString(item);</span><br><span class="line">        queue.push(sendMess);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/8 15:48</span></span><br><span class="line"><span class="comment"> * 消息消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageConsumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RedisQueue queue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageConsumer</span><span class="params">(RedisQueue queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(random.nextInt(<span class="number">10</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            receive();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object object = queue.poll(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (object != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/8 15:45</span></span><br><span class="line"><span class="comment"> * 消息转换器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageConvert</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Type taskType = <span class="keyword">new</span> TypeReference&lt;T&gt;() &#123;&#125;.getType();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将给定的消息转换为string类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">messageToString</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JSON.toJSONString(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将string类型的消息转换为T类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">stringToObject</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JSON.parseObject(message, taskType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="zset实现延时队列"><a href="#zset实现延时队列" class="headerlink" title="zset实现延时队列"></a><code>zset实现延时队列</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delayQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(url, port);</span><br><span class="line">    <span class="comment">// 延时队列</span></span><br><span class="line">    RedisDelayingQueue queue = <span class="keyword">new</span> RedisDelayingQueue(jedis, <span class="string">"q-demo"</span>);</span><br><span class="line">    DelayMessageConsumer consumer = <span class="keyword">new</span> DelayMessageConsumer(queue);</span><br><span class="line">    DelayMessageProducer producer = <span class="keyword">new</span> DelayMessageProducer(queue);</span><br><span class="line">    producer.start();</span><br><span class="line">    consumer.start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 首先让producer线程执行完成</span></span><br><span class="line">        producer.join();</span><br><span class="line">        <span class="comment">// 主线程睡眠6秒，等待consumer将消息消费完成</span></span><br><span class="line">        Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">        consumer.interrupt();</span><br><span class="line">        consumer.join();</span><br><span class="line">    &#125;  <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/7 16:56</span></span><br><span class="line"><span class="comment"> * 延时队列-&gt; 通过zset实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisDelayingQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line">    <span class="keyword">private</span> String queueKey;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisDelayingQueue</span><span class="params">(Jedis jedis, String queueKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jedis = jedis;</span><br><span class="line">        <span class="keyword">this</span>.queueKey = queueKey;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 执行消息的发送</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delay</span><span class="params">(String msg, <span class="keyword">long</span> score)</span> </span>&#123;</span><br><span class="line">        jedis.zadd(queueKey, score, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行消息的处理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">(MessageHandle handle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">            <span class="comment">// fixme 此处需要优化，保证操作的原子性</span></span><br><span class="line">            <span class="comment">// 获取一条数据(score最小的那条数据)</span></span><br><span class="line">            Set values = jedis.zrangeByScore(queueKey, <span class="number">0</span>, System.currentTimeMillis(), <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 若是队列中没有任务，线程睡眠500毫秒</span></span><br><span class="line">            <span class="keyword">if</span> (values.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String value = (String) values.iterator().next();</span><br><span class="line">            <span class="comment">// 从queueKey中移除该元素</span></span><br><span class="line">            <span class="keyword">if</span> (jedis.zrem(queueKey, value) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 将消息交给回调接口来处理</span></span><br><span class="line">                handle.handle(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/8 17:13</span></span><br><span class="line"><span class="comment"> * 延时队列-生产者线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayMessageProducer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    RedisDelayingQueue queue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelayMessageProducer</span><span class="params">(RedisDelayingQueue queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) &#123;</span><br><span class="line">            String message = <span class="string">"message:"</span>+ i;</span><br><span class="line">            <span class="keyword">long</span> score = random.nextInt(<span class="number">10</span>);</span><br><span class="line">            send(message, score);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String msg, <span class="keyword">long</span> delay)</span> </span>&#123;</span><br><span class="line">        TaskItem task = <span class="keyword">new</span> TaskItem();</span><br><span class="line">        task.id = UUID.randomUUID().toString();</span><br><span class="line">        task.msg = msg;</span><br><span class="line">        String message = JSON.toJSONString(task);</span><br><span class="line">        queue.delay(message, delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/8 17:11</span></span><br><span class="line"><span class="comment"> * 延时队列消费者线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayMessageConsumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    RedisDelayingQueue queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> MessageHandle handle = <span class="keyword">new</span> MessageHandle() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">            System.out.println(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelayMessageConsumer</span><span class="params">(RedisDelayingQueue queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue.loop(handle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/8 17:21</span></span><br><span class="line"><span class="comment"> * 消息处理回调接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageHandle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(String item)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;list实现分布式队列&quot;&gt;&lt;a href=&quot;#list实现分布式队列&quot; class=&quot;headerlink&quot; title=&quot;list实现分布式队列&quot;&gt;&lt;/a&gt;&lt;code&gt;list实现分布式队列&lt;/code&gt;&lt;/h6&gt;&lt;figure class=&quot;highlight
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="数据库" scheme="https://zhilongao.github.io/categories/java/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="redis" scheme="https://zhilongao.github.io/categories/java/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/"/>
    
    
  </entry>
  
  <entry>
    <title>单链表</title>
    <link href="https://zhilongao.github.io/wiki/linked-list-ask/"/>
    <id>https://zhilongao.github.io/wiki/linked-list-ask/</id>
    <published>2019-08-31T03:56:40.000Z</published>
    <updated>2019-09-03T07:38:54.888Z</updated>
    
    <content type="html"><![CDATA[<p><code>单链表常见操作</code></p><p><code>1.如何实现一个单链表的逆序输出-&gt;反转单链表</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">    ListNode next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span> &amp;&amp; (next = head.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    head.next = prev;</span><br><span class="line">        prev = head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    head.next = prev;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;单链表常见操作&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1.如何实现一个单链表的逆序输出-&amp;gt;反转单链表&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="算法" scheme="https://zhilongao.github.io/categories/java/%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="https://zhilongao.github.io/categories/java/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="https://zhilongao.github.io/wiki/arithmetic-sort/"/>
    <id>https://zhilongao.github.io/wiki/arithmetic-sort/</id>
    <published>2019-08-31T01:19:15.000Z</published>
    <updated>2019-09-06T06:27:43.174Z</updated>
    
    <content type="html"><![CDATA[<p><code>常见的排序算法</code></p><p><code>1.插入排序</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入排序算法</span></span><br><span class="line"><span class="comment">// 时间复杂度：平均情况:o(n^2)  最好情况:o(n) 最坏情况:o(n^2) </span></span><br><span class="line"><span class="comment">// 空间复杂度: o(1)</span></span><br><span class="line"><span class="comment">// 特点: 稳定</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; array.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = array[i];</span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;=<span class="number">0</span> &amp;&amp; array[j] &gt; temp; j --) &#123;</span><br><span class="line">            <span class="comment">// 将数组中的元素后移一位</span></span><br><span class="line">            array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">        &#125;</span><br><span class="line">        array[j + <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>2.选择排序</code></p><p><code>原理</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 选择排序算法</span></span><br><span class="line"><span class="comment">// 时间复杂度: 平均情况:o(n^2)  最好情况:o(n^2) 最坏情况:o(n^2)  </span></span><br><span class="line"><span class="comment">// 空间复杂度: o(1)</span></span><br><span class="line"><span class="comment">// 特点: 不稳定</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; array.length; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &gt; array[j]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = array[i];</span><br><span class="line">                array[i] = array[j];</span><br><span class="line">                array[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>3.交换排序-&gt;冒泡排序</code></p><p><code>原理</code></p><p><img src="https://raw.githubusercontent.com/zhilongao/images-repository/master/006y8mN6ly1g6mbx8snqyg30my075wqv.gif" alt="冒泡排序"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序算法</span></span><br><span class="line"><span class="comment">// 时间复杂度: 平均情况:o(n^2)  最好情况:o(n) 最坏情况:o(n^2)</span></span><br><span class="line"><span class="comment">// 空间复杂度: o(1)</span></span><br><span class="line"><span class="comment">// 特点：稳定</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - i - <span class="number">1</span>; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = array[j];</span><br><span class="line">                array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">                array[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>4.交换排序-&gt;快速排序</code></p><p><code>原理</code></p><p><img src="https://raw.githubusercontent.com/zhilongao/images-repository/master/7789414-007520d3d4a7610c.gif" alt="快速排序"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快速排序算法</span></span><br><span class="line"><span class="comment">// 时间复杂度: 平均情况:o(nlog2^n) 最好情况:o(nlog2^n) 最坏情况:o(n^2)</span></span><br><span class="line"><span class="comment">// 空间复杂度: o(nlog2^n)</span></span><br><span class="line"><span class="comment">// 特点：不稳定</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fastSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &gt; high) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = low;</span><br><span class="line">    <span class="keyword">int</span> j = fast;</span><br><span class="line">    <span class="keyword">int</span> temp = array[low];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="comment">// 从右向左找到第一个小于temp的元素,保存其下标</span></span><br><span class="line">        <span class="keyword">while</span> (array[j] &gt; temp &amp;&amp; i &lt; j) &#123;</span><br><span class="line">            j --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从左向右找到第一个大于temp的元素，保存其下标</span></span><br><span class="line">        <span class="keyword">while</span> (array[i] &lt;= temp &amp;&amp; i &lt; j) &#123;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换这两个元素</span></span><br><span class="line">        <span class="keyword">int</span> swap = array[i];</span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        array[j] = swap;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 交换temp</span></span><br><span class="line">    array[low] = array[i];</span><br><span class="line">    array[i] = temp;</span><br><span class="line">    <span class="comment">// 快排temp左半边</span></span><br><span class="line">    fastSort(array, low, j - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 快排temp右半边</span></span><br><span class="line">    fastSort(array, j + <span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>5.归并排序</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 归并排序算法</span></span><br><span class="line"><span class="comment">// 时间复杂度: 平均情况:o(nlog2^n) 最好情况:o(nlog2^n) 最坏情况:o(nlog2^n)</span></span><br><span class="line"><span class="comment">// 空间复杂度：o(1)</span></span><br><span class="line"><span class="comment">// 特点: 稳定</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">sortMerge</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    sort(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> array[], <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (R + L) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 排序左半部分</span></span><br><span class="line">    sort(array, L, mid);</span><br><span class="line">    <span class="comment">// 排序右半部分</span></span><br><span class="line">    sort(array, mid + <span class="number">1</span>, R);</span><br><span class="line">    <span class="comment">// 合并 </span></span><br><span class="line">    merge(array, L, mid, R);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> L, <span class="keyword">int</span> mid, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[R - L + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = L;</span><br><span class="line">    <span class="keyword">int</span> p2 = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 将数组排序后放入到临时数组temp中</span></span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= R) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[p1] &lt; array[p2]) &#123;</span><br><span class="line">            temp[i++] = array[p1++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[i++] = array[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p1 &lt;= mid) &#123;</span><br><span class="line">        temp[i++] = array[p1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p2 &lt;= R) &#123;</span><br><span class="line">        temp[i++] = array[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将临时数组中的元素移动到array中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; temp.length; k ++) &#123;</span><br><span class="line">        array[L + k] = temp[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;常见的排序算法&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1.插入排序&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;s
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="算法" scheme="https://zhilongao.github.io/categories/java/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="https://zhilongao.github.io/categories/java/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>jvm-command</title>
    <link href="https://zhilongao.github.io/wiki/jvm-command/"/>
    <id>https://zhilongao.github.io/wiki/jvm-command/</id>
    <published>2019-08-29T09:01:23.000Z</published>
    <updated>2019-08-31T04:00:56.547Z</updated>
    
    <content type="html"><![CDATA[<hr><p><code>jvm基本指令</code></p><table><thead><tr><th>基本指令</th><th>指令说明</th></tr></thead><tbody><tr><td>iconst_1</td><td>int型常量值1进栈</td></tr><tr><td>bipush</td><td>将一个byte型常量值推送至栈顶</td></tr><tr><td>iload_1</td><td>第二个int型局部变量进栈，从0开始计数</td></tr><tr><td>istore_1</td><td><em>将栈顶int型数值存入第二个局部变量，从<strong>0</strong>开始计数</em></td></tr><tr><td></td><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;&lt;code&gt;jvm基本指令&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;基本指令&lt;/th&gt;
&lt;th&gt;指令说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;iconst_1&lt;/td&gt;
&lt;td&gt;int型常量值1进
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="基础" scheme="https://zhilongao.github.io/categories/java/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="jvm" scheme="https://zhilongao.github.io/categories/java/%E5%9F%BA%E7%A1%80/jvm/"/>
    
    
  </entry>
  
  <entry>
    <title>dubbo</title>
    <link href="https://zhilongao.github.io/wiki/dubbo-ask/"/>
    <id>https://zhilongao.github.io/wiki/dubbo-ask/</id>
    <published>2019-08-28T11:57:42.000Z</published>
    <updated>2019-08-28T12:21:39.474Z</updated>
    
    <content type="html"><![CDATA[<p><code>协议</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;协议&lt;/code&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="分布式" scheme="https://zhilongao.github.io/categories/java/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>博客</title>
    <link href="https://zhilongao.github.io/wiki/share-articles/"/>
    <id>https://zhilongao.github.io/wiki/share-articles/</id>
    <published>2019-08-27T13:38:52.000Z</published>
    <updated>2019-09-10T06:31:34.768Z</updated>
    
    <content type="html"><![CDATA[<p><code>友情链接</code></p><p><a href="https://yapengren.github.io/" target="_blank" rel="noopener">任亚鹏的博客</a></p><p><code>技术大牛</code></p><p><a href="https://mercyblitz.github.io" target="_blank" rel="noopener">小马哥</a></p><p><code>精彩社区</code></p><p><a href="https://tech.meituan.com/" target="_blank" rel="noopener">美团技术团队</a></p><hr><p><a href="https://www.v2ex.com/" target="_blank" rel="noopener">v2ex</a></p><hr><p><a href="https://juejin.im/timeline" target="_blank" rel="noopener">掘金</a></p><hr><p><a href="http://cmsblogs.com/" target="_blank" rel="noopener">java技术驿站</a></p><hr><p><a href="https://www.infoq.cn/" target="_blank" rel="noopener">infoq</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;友情链接&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://yapengren.github.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;任亚鹏的博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;技术大牛&lt;/code&gt;&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>分库分表</title>
    <link href="https://zhilongao.github.io/wiki/mysql-split/"/>
    <id>https://zhilongao.github.io/wiki/mysql-split/</id>
    <published>2019-08-27T09:08:54.000Z</published>
    <updated>2019-08-28T03:14:43.225Z</updated>
    
    <content type="html"><![CDATA[<hr><p><code>数据库优化之分库分表</code></p><hr><p>针对数据库的优化有两点，第一是从整体层面优化，设计到读写分离和分库分表。第二是从sql层面优化，主要是涉及到索引相关的一些东西。</p><hr><p><code>读写分离</code></p><p>​    <code>需求</code>: 读写分离的目的是做数据冗余备份，同时将读写分离，提升数据库的服务性能（IO性能瓶颈）。</p><p>​    <code>搭建过程</code>: 在基本操作里面-&gt;mysql配置主从同步的步骤 。</p><p>​    <code>实现原理</code>:  首先是master数据库会先将数据库的变化存储在binlog文件中。在slave数据库上，会有一个IO Thread负责将binlog文件读取到内部的relaylog文件中。同时，slave数据库上的另外一个线程SQL Thread读取relaylog，将数据写入到slave数据库里面。</p><p>​    <code>细节</code>: mysql的binlog文件存储在 /var/lib/mysql文件夹下；使用命令-&gt; mysqlbinlog –base64-output=decode-rows -v  mysql-bin.000001 查看binlog的内容；binlog的格式：statement（默认，基于sql语句模式，针对数据更新的一些函数now()等，数据延迟造成的不一致），row：基于行模式，记录修改后每一条数据变化的值，mixed：混合模式，由mysql自动判断处理。</p><p>​    <code>问题</code>：同步延迟，master tps较高时出现同步延迟； 网络延迟；磁盘IO</p><hr><p><code>分库分表</code></p><p>​    <code>垂直拆分</code></p><p>​        <code>概念</code>:垂直拆分主要是通过业务层面，将各个业务模块所使用到的表放到各自不同的数据库里面，做到各个业务模块库相互隔离的目的。</p><p>​        <code>问题</code>:若是各个业务模块的表之间存在一些关联查询，需要将这些查询改为服务调用的方式。  针对一些全局表，可以改为服务调用的方式，对外提供服务。</p><p>​    <code>水平拆分</code></p><p>​        <code>概念</code>:将一张大的表拆分成n多张小表。实现方式，第一种是通过一致性hash（若是新增表的话，会涉及到数据迁移的问题）。第二种是可以按照id的范围来拆分。第三种是通过日期来拆分。</p><p>​        <code>问题</code>:唯一主键问题，可以使用zk自增id  可以使用redis的自增id  可以使用代理的id</p><hr><p><code>Mycat</code></p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1. 从github上面clone项目 https://github.com/MyCATApache/Mycat-Server.git</span><br><span class="line">2. 修改项目中schema.xml配置文件中的dataHost数据库配置节点信息，修改为可用的数据库</span><br><span class="line">3. MycatStartup类运行main函数启动</span><br><span class="line">idea启动前需要在配置参数VM options: -DMYCAT_HOME=D:<span class="tag">\<span class="name">code</span></span><span class="tag">\<span class="name">Mycat</span></span>-Server<span class="tag">\<span class="name">src</span></span><span class="tag">\<span class="name">main</span></span></span><br><span class="line">4. 通过数据库连接工具可以连接到MyCat,数据库相关配置在server.xml配置文件里面</span><br><span class="line">默认的用户名: root 密码: 123456 port: 8066</span><br><span class="line">5. mycat里面有三个比较重要的配置文件 </span><br><span class="line">server.xml配置数据库连接相关的一些信息</span><br><span class="line">schema.xml  配置数据库的一些节点信息</span><br><span class="line">rule.xml    配置一些路由规则</span><br><span class="line">6. 支持单库分表   支持跨库分表    支持配置读写分离(writeHost和readHost节点)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;&lt;code&gt;数据库优化之分库分表&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;针对数据库的优化有两点，第一是从整体层面优化，设计到读写分离和分库分表。第二是从sql层面优化，主要是涉及到索引相关的一些东西。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;code&gt;读写分离&lt;/code&gt;&lt;/
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="数据库" scheme="https://zhilongao.github.io/categories/java/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mysql" scheme="https://zhilongao.github.io/categories/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>基本操作</title>
    <link href="https://zhilongao.github.io/wiki/mysql-base/"/>
    <id>https://zhilongao.github.io/wiki/mysql-base/</id>
    <published>2019-08-27T09:08:25.000Z</published>
    <updated>2019-08-27T12:58:54.756Z</updated>
    
    <content type="html"><![CDATA[<hr><p><code>centos7上mysql的安装步骤</code></p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.下载mysql的repo源  &gt; wget http://repo.mysql.com/mysql57-community-release-el7-8.noarch.rpm</span><br><span class="line">2.安装源&gt; rpm -ivh mysql57-community-release-el7-8.noarch.rpm</span><br><span class="line">3.安装数据库-&gt;yum install mysql-server</span><br><span class="line">4.启动数据库&gt; systemctl start mysqld</span><br><span class="line">5.查看mysql为root账号生成的随机密码&gt;grep "password" /var/log/mysqld.log</span><br><span class="line">  说明root@localhost:此处为随机密码</span><br><span class="line">6.运行mysql -uroot -p回车</span><br><span class="line">7.粘贴随机密码-&gt;此时已经登录到mysql数据库，需要为root账号设置密码</span><br><span class="line">8.由于mysql5.7有对密码设置的验证，简单密码设置不了，需要运行下面两条命令关闭验证</span><br><span class="line">&gt; set global validate_password_length=1;</span><br><span class="line">&gt; set global validate_password_policy=0;</span><br><span class="line">9.修改root账号的密码</span><br><span class="line">&gt; set password = password('123456');</span><br><span class="line">10.修改root账号的权限</span><br><span class="line">    &gt; GRANT ALL PRIVILEGES ON *.* TO 'root'@'<span class="comment">%' IDENTIFIED BY 'root' WITH GRANT OPTION;</span></span><br><span class="line">11.可以创建一个其它的用户</span><br><span class="line">&gt; create user repl identified by 'repl';</span><br><span class="line">12.为该用户授权</span><br><span class="line">    &gt; grant replication slave on *.* to 'repl'@'<span class="comment">%' identified by 'repl';(数据同步的权限)</span></span><br><span class="line">    &gt; GRANT ALL ON *.* TO 'pig'@'<span class="comment">%';(为用户pig授予所有权限)</span></span><br></pre></td></tr></table></figure><p><code>mysql配置主从同步的步骤</code></p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.在master服务器上创建一个可以进行数据同步的账户。</span><br><span class="line">&gt; create user repl identified by 'repl';</span><br><span class="line">2.在master服务器上为该用户授权。</span><br><span class="line">&gt; grant replication slave on *.* to 'repl'@'<span class="comment">%' identified by 'repl';</span></span><br><span class="line">3.在master服务器上修改/etc/my.cnf文件。</span><br><span class="line">[mysqld]</span><br><span class="line">log-bin=mysql-bin</span><br><span class="line">server-id=147</span><br><span class="line">4.在master上面重启mysql</span><br><span class="line">&gt; systemctl restart mysqld</span><br><span class="line">5.在master上登录数据库，使用下面命令查看二进制文件。</span><br><span class="line">&gt; show master status;</span><br><span class="line">6.在slave服务器上修改/etc/my.cnf文件</span><br><span class="line">[mysqld]</span><br><span class="line">server-id=149</span><br><span class="line">relay-log=slave-relay-bin</span><br><span class="line">relay-log-index=slave-relay-bin.index</span><br><span class="line">read-only=1</span><br><span class="line">7.在slave服务器上重启mysql</span><br><span class="line">&gt; systemctl restart mysqld</span><br><span class="line">8.在slave上登录数据库,执行下列命令，设置master相关参数。</span><br><span class="line">&gt; change master to master_host='192.168.25.147',master_port=3306,master_user='repl',master_password='repl',master_log_file='mysql-bin.000003', master_log_pos=154;</span><br><span class="line">9.在slave上运行命令，启动服务</span><br><span class="line">&gt; start slave;</span><br><span class="line">10.查看状态，查看主从同步设置是否成功</span><br><span class="line">&gt; show slave status<span class="tag">\<span class="name">G</span></span>;</span><br><span class="line">11.搭建完成，现在就可以玩啦，尝试在master上面创建数据库和表，在slave上会看到相应的数据库和表。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;&lt;code&gt;centos7上mysql的安装步骤&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight tex&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1.下载mysql的repo
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="数据库" scheme="https://zhilongao.github.io/categories/java/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mysql" scheme="https://zhilongao.github.io/categories/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>索引</title>
    <link href="https://zhilongao.github.io/wiki/mysql-index/"/>
    <id>https://zhilongao.github.io/wiki/mysql-index/</id>
    <published>2019-08-27T09:08:17.000Z</published>
    <updated>2019-08-27T09:51:54.005Z</updated>
    
    <content type="html"><![CDATA[<p><code>1.数据库四大特性</code></p><p>​    A( Atomicity 原子性):  数据库最小的工作单元，整个工作单元要么一起提交成功,要么一起失败回滚。<br>​    C( Consistency 一致性):  事物中操作的数据的状态是一致的。即写入数据的结果必须完全符合预设的规则，不会因为出现系统意外等原因导致状态的不一致。<br>​    I( Isolation 隔离性):  一个事务所操作的数据在提交之前，对其他事务的可见性设定（一般设定为不可见）。<br>​    D( Durability 持久性):  数据库的数据一旦提交,无法更改。</p><p><code>2.多个事物并发引起的数据读取问题</code></p><p>​    脏读:  是指一个事物读取到了另外一个事物未提交的数据。<br>​    不可重复读:  是指在一个事物未结束之前, 前后两次读取到的数据不一致现象。原因在于该事物在前后两次读取数据之间，另外一个事物修改了该数据。(不可重复读的重点在于修改)。<br>​    幻读:  是指当一个事物修改了数据库表中某一个范围内的数据的某一个字段，但是另外一个事物在此期间又在该范围内插入了一条新的数据，造成前一个事物出现幻觉(没有完全修改)。(幻读的重点在于新增或删除) 。</p><p><code>3.数据库事物的隔离级别</code></p><p>  Read Uncommited 读未提交:  事物未提交对其它的事物也是可见的。<br>  Read Commited 读已提交:  一个事物只能够读取到已提交的数据。(解决脏读, 未解决不可重复读)。<br>  Repeatable Read 可重复读:  一个事物对数据的前后读取结果是一致的。(解决了不可重复读, 未解决幻读)。<br>  Serializable 串行化:  数据库最高的隔离级别,  强制所有事物串行执行,解决了所有并发问题。</p><p><code>4.聚集索引和非聚集索引的区别</code><br>    聚集索引:  表中的数据是按照索引的顺序来存储的。索引的叶子节点上存储了真实的数据,不会有另外单独的数据页。<br>    非聚集索引:  表中的数据存储不依赖于索引的顺序。索引的叶子节点上存储了索引的关键字和指向真实数据的指针。   </p><p><code>5.sql调优</code></p><p>​    a. 创建索引  b.使用临时表存储中间结果-&gt;(避免多次扫描主表)。c. 避免在索引上使用计算。4.少使用select *，只返回需要的字段。</p><p><code>6.如何理解MVCC</code>   </p><p>​    a. 数据库每张表会单独维护两个字段，数据行版本号和删除版本号。   </p><p>​    b. 当执行insert操作时，我们开启了一个事物，执行数据插入操作时，会将这个事物的事物id设置到数据行版本号这个字段中（这个事物的事物id属于数据库一个全局属性，自增）。</p><p>​    c. 当执行delete操作时，我们开启了一个事物，执行数据删除操作时，会将这个事物的事物id设置到删除版本号这个字段中。</p><p>​    d. 当执行update操作时，我们开启了一个事物，指定数据更新操作时，会将这行数据copy一份，copy的这份数据数据行版本号为当前事物id，删除版本号为Null，并更新相关字段。原先那行的删除版本号会被设置为当前的事物id。</p><p>​    e.  当我们执行数据库查询时，满足以下两点要求：</p><p>​        e1：查找数据的数据行版本号小于或等于当前事物id。(保证该条数据在当前事物开启之前就已经存在或者为该事物添加的数据。</p><p>​        e2：查找数据的删除版本号为Null或者删除版本号大于当前事物id。（该条规则可以确保当前事物在开始之前数据还未被删除。</p><p><code>7.MVCC解决的问题与未解决的问题</code></p><p>   若是一个查询先于一行的数据更新，不会出现问题。若是一个查询后于一行的数据更新，会产生脏读的问题。</p><p><code>8.Innodb数据库的四种隔离级别是如何实现的</code></p><p>​    读未提交：对select操作不会加锁，并发性能是最好的，但是容易造成脏读。</p><p>​    读已提交（互联网上默认的隔离级别）：普通的数据读取是会直接读取数据快照，加锁的select，update等操作会使用记录锁。注意：读已提交读取快照时，一个事物读取了数据，但是当第二次读取的时候，另外一个事物已经将该快照刷新了，所以会造成不可重复读的问题。</p><p>​    可重复读（Innodb默认的事物隔离级别）：对于普通的数据库查询，使用读取快照的方式。对于加锁的select,update等语句，他们加锁的力度取决于查询条件是使用了唯一索引还是使用了范围查询。若是使用了唯一索引，会使用记录锁的方式。若是使用了范围查询，会使用间隙锁，避免发生不可重复读。注意:当一个事物开启读取数据时，前后两次读取的都是同一个快照，这样就可以实现了可重复读。</p><p>​    串行化：针对所有的操作都会去加锁，普通的select操作会去加共享锁-&gt;select * from table in share mode。对于 update 等操作会加排他锁。若是一个事物查询操作时，正好有一个事物对改行的数据做修改操作。则该查询操作会阻塞，直到更新操作执行完成。</p><p><code>9.如何理解快照读和当前读</code></p><p>​    快照读：读取的数据是快照。当前读：读取的数据是数据库的最新的数据。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;1.数据库四大特性&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;​    A( Atomicity 原子性):  数据库最小的工作单元，整个工作单元要么一起提交成功,要么一起失败回滚。&lt;br&gt;​    C( Consistency 一致性):  事物中操作的数据的状态是一致的。
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="数据库" scheme="https://zhilongao.github.io/categories/java/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mysql" scheme="https://zhilongao.github.io/categories/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>tcp</title>
    <link href="https://zhilongao.github.io/wiki/tcp/"/>
    <id>https://zhilongao.github.io/wiki/tcp/</id>
    <published>2019-08-26T13:33:14.000Z</published>
    <updated>2019-08-28T12:55:39.134Z</updated>
    
    <content type="html"><![CDATA[<hr><p><code>此时握手</code></p><p><code>四次挥手</code></p><p><code>为什么要三次握手</code></p><p><code>为什么要四次挥手</code></p><p><code>socket的几种状态</code></p><p>​        <code>listen:侦听来自远方tcp端口的连接请求</code></p><p>​        <code>syn-sent:在发送连接请求后，等待匹配的连接请求。</code></p><p>​        <code>syn-receive:在收到和发送一个连接请求后，等待连接请求的确认</code></p><p>​        <code>established:代表一个打开的连接，数据可以传送给用户</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;&lt;code&gt;此时握手&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;四次挥手&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;为什么要三次握手&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;为什么要四次挥手&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;socket的几种状态&lt;/code&gt;
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="分布式" scheme="https://zhilongao.github.io/categories/java/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="协议" scheme="https://zhilongao.github.io/categories/java/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%8D%8F%E8%AE%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>project-ask</title>
    <link href="https://zhilongao.github.io/wiki/project-ask/"/>
    <id>https://zhilongao.github.io/wiki/project-ask/</id>
    <published>2019-08-26T13:26:32.000Z</published>
    <updated>2019-09-05T03:01:01.061Z</updated>
    
    <content type="html"><![CDATA[<p><code>项目专题</code></p><p><code>系统1</code></p><p>​    <code>系统数据流转</code></p><p>​    <img src="https://raw.githubusercontent.com/zhilongao/images-repository/master/3153f3dae0ac8b3014874267ad70cc1.png" alt="任务执行流程"></p><p>​    </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 大体流程</span></span><br><span class="line"><span class="number">1</span>. 从原始借据表bp_collect_loan_src同步数据到bp_collect_loan，同步批次号为batch_no的数据。(同步数据时，每个线程处理数量默认为<span class="number">10000</span>，若是当前批次数据量超过<span class="number">10000</span>，会采用多线程来执行)</span><br><span class="line"><span class="number">2</span>. 针对每一个原始借据，数据库里面只有可能有一条与之对应的借据，所以将bp_collect_loan存入数据库的操作采用的是insertOrUpdate操作(任务执行失败后，不会对数据库中的数据造成影响)。</span><br><span class="line"><span class="number">3</span>. 借据同步完成之后，需要执行归案任务，就是将多个借据加工成为一个案件，以人为维度进行催收。</span><br><span class="line"><span class="number">4</span>. 归案完成之后，需要跑规则引擎来执行分案，通过规则引擎分案之后，会在数据库表bp_collect_divide表里面生成分案记录。</span><br><span class="line"><span class="number">5</span>. 将这些分案记录针对案件进行分案(分案记录里面存储了两类，针对个人的分案，针对组的分案)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用到的技术点(分布式锁 redis队列)</span></span><br><span class="line"><span class="number">1</span>. 由于任务是部署在多台机器上的，多个进程执行任务时，需要获取分布式锁。项目中采用redis来实现了分布式锁，上锁命令采用set命令，外加是否存在，过期时间参数来实现。而释放锁的命令采用lua脚本来实现，因为会有两步骤操作，首先式判断上锁客户端和释放锁的客户端是否一致（存储在value中），其次是删除该锁对应的key，lua脚本保证了该操作的原子性。</span><br><span class="line"><span class="number">2</span>. 在执行归案的过程中，针对每一个案件，需要将该案件分出去，会过规则引擎。而将分案请求交给规则引擎有两种方式，第一种是先将该案件构建成为请求，然后将该请求放到redis的同步队列里面，规则引擎那边从同步队列里面来进行消费。第二种是若同步队列已满，或者放入到同步队列出错，则会将请求直接交给规则引擎来处理。</span><br><span class="line"></span><br><span class="line"><span class="comment">// 技术难点-如何克服</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;项目专题&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;系统1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;​    &lt;code&gt;系统数据流转&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;​    &lt;img src=&quot;https://raw.githubusercontent.com/zhilong
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="项目" scheme="https://zhilongao.github.io/categories/java/%E9%A1%B9%E7%9B%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>threadpool</title>
    <link href="https://zhilongao.github.io/wiki/threadpool/"/>
    <id>https://zhilongao.github.io/wiki/threadpool/</id>
    <published>2019-08-26T13:20:13.000Z</published>
    <updated>2019-08-26T13:23:48.587Z</updated>
    
    <content type="html"><![CDATA[<hr><p><code>线程池</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建线程池的工具类Executors</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Executors</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个只有一个工作线程的线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个固定数目线程的线程池(核心线程数和最大线程数相同)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个cache线程池，核心线程大小为0</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 线程工厂，负责为线程池中的Worker创建线程-》可以创建个性化的线程</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger poolNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">        DefaultThreadFactory() &#123;</span><br><span class="line">            SecurityManager s = System.getSecurityManager();</span><br><span class="line">            group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() :</span><br><span class="line">                                  Thread.currentThread().getThreadGroup();</span><br><span class="line">            namePrefix = <span class="string">"pool-"</span> +</span><br><span class="line">                          poolNumber.getAndIncrement() +</span><br><span class="line">                         <span class="string">"-thread-"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 返回的线程又将Worker做了一层封装,当该线程执行strart方法时,将会调用Worker的run方法</span></span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(group, r,</span><br><span class="line">                                  namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                                  <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">                t.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">                t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// jdk定义的线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 核心线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line">    <span class="comment">// 最大线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maximumPoolSize;</span><br><span class="line">    <span class="comment">// 阻塞队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line">    <span class="comment">// 非工作线程存活时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> keepAliveTime;</span><br><span class="line">    <span class="comment">// 创建线程的工厂</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;</span><br><span class="line">    <span class="comment">// 线程池的拒绝策略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line">    <span class="comment">// 存储创建好的Worker线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br><span class="line">    <span class="comment">// 主锁,对workers进行操作时会上锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义线程池内部的工作线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="comment">// 当前Worker持有的线程</span></span><br><span class="line">        <span class="keyword">final</span> Thread thread;</span><br><span class="line">        <span class="comment">// 当前Worker执行的第一个任务</span></span><br><span class="line">        Runnable firstTask;</span><br><span class="line">        <span class="comment">// 记录当前Worker已经完成的任务数量</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">        Worker(Runnable firstTask) &#123;</span><br><span class="line">            <span class="comment">// 将aqs中的state值由0设置为-1,禁止中断(上锁了)</span></span><br><span class="line">            setState(-<span class="number">1</span>); </span><br><span class="line">            <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">            <span class="comment">// 调用工厂为当前的Worker创建一个Thread—&gt;传入的是当前this对象</span></span><br><span class="line">            <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前Worker线程启动需要执行的方法，该方法会由内部属性thread调用start方法时触发。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            runWorker(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断线程是否被独占</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试获取锁</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Thread t;</span><br><span class="line">            <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// Worker线程执行的真正逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">        Thread wt = Thread.currentThread();</span><br><span class="line">        Runnable task = w.firstTask;</span><br><span class="line">        w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">        w.unlock();<span class="comment">//执行任务之前允许被打断</span></span><br><span class="line">        <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 当前worker的task不为null或者是阻塞队列不为null,worker线程会一直运行</span></span><br><span class="line">            <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 上锁</span></span><br><span class="line">                w.lock();</span><br><span class="line">                <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                     (Thread.interrupted() &amp;&amp;</span><br><span class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                    !wt.isInterrupted())</span><br><span class="line">                    wt.interrupt();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beforeExecute(wt, task);</span><br><span class="line">                    Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 调用worker的run方法</span></span><br><span class="line">                        task.run();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        afterExecute(task, thrown);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="keyword">null</span>;</span><br><span class="line">                    w.completedTasks++;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            processWorkerExit(w, completedAbruptly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化一个线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.若是当前工作线程数小于核心线程数, 会去创建一个核心线程。</span></span><br><span class="line">    <span class="comment">// 2.若是当前工作线程数大于等于核心线程数，将任务放入到阻塞队列。</span></span><br><span class="line">    <span class="comment">// 3.若是阻塞队列已满，会去创建非核心线程。</span></span><br><span class="line">    <span class="comment">// 4.若是创建非核心线程也失败，执行拒绝策略。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.尝试着将工作线程数加1，workers的个数。</span></span><br><span class="line">    <span class="comment">// 2.创建一个Worker线程，并将其加入到workers数组中。</span></span><br><span class="line">    <span class="comment">// 3.若是加入到workers数组成功，调用worker的thread的start方法，启动线程。</span></span><br><span class="line">    <span class="comment">// 4.线程启动之后，会调用worker的run方法，而run方法又是调用runWorker(this)方法来执行的。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">        retry:</span><br><span class="line">        <span class="comment">// 自旋</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">            <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                   ! workQueue.isEmpty()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">                <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                    wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                    <span class="keyword">break</span> retry;</span><br><span class="line">                c = ctl.get();</span><br><span class="line">                <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                    <span class="keyword">continue</span> retry;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">        Worker w = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">            <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">                mainLock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">                    <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                        (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (t.isAlive())</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                        <span class="comment">// 将创建好的Worker加入到workers数组中</span></span><br><span class="line">                        workers.add(w);</span><br><span class="line">                        <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                        <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                            largestPoolSize = s;</span><br><span class="line">                        workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    mainLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                    t.start();</span><br><span class="line">                    workerStarted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">                addWorkerFailed(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> workerStarted;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// spring线程池-&gt;ThreadPoolTaskExecutor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTaskExecutor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object poolSizeMonitor = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="comment">// 核心线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> corePoolSize = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 最大线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxPoolSize = <span class="number">2147483647</span>;</span><br><span class="line">    <span class="comment">// 非核心线程空闲最大存活时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> keepAliveSeconds = <span class="number">60</span>;</span><br><span class="line">    <span class="comment">// 缓存队列容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> queueCapacity = <span class="number">2147483647</span>;</span><br><span class="line">    <span class="comment">// 是否允许核心线程池超时等待(设置为false,当到达一定时间没有任务,线程池会自动关闭)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> allowCoreThreadTimeOut = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> TaskDecorator taskDecorator;</span><br><span class="line">    <span class="keyword">private</span> ThreadPoolExecutor threadPoolExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolTaskExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 因为spring线程池提供了更加灵活的配置，项目中一般使用的是spring的线程池。</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;&lt;code&gt;线程池&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 创建线
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="并发" scheme="https://zhilongao.github.io/categories/java/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="线程池" scheme="https://zhilongao.github.io/categories/java/%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>lock</title>
    <link href="https://zhilongao.github.io/wiki/lock/"/>
    <id>https://zhilongao.github.io/wiki/lock/</id>
    <published>2019-08-25T06:28:41.000Z</published>
    <updated>2019-08-26T13:16:50.804Z</updated>
    
    <content type="html"><![CDATA[<hr><p><code>前戏</code>java里面提供了两种锁机制，基于jvm层面实现的关键字synchronized和基于jdk层面实现的Lock锁。</p><hr><p><code>synchronized关键字</code></p><p><code>基本使用</code>：synchronized关键字可以用来修饰静态方法，普通方法，代码块，获取到的锁对象分别为当前类Class对象，当前实例对象和synchronized括号里面的对象。</p><p><code>加锁原理</code>：synchronized加锁是基于对象监视器Monitor的monitorenter和monitorexit。在java中，每个对象都会有一个对象监视器，当synchronized修饰代码块时，在开始位置会加上monitorenter指令，在方法结束和异常处会插入monitorexit指令。当执行monitorentrt指令时，会去获取锁的Monitor对象，若是获取到，执行，获取不到的话，线程阻塞。</p><p><code>synchronized的锁升级</code></p><p>​    <code>偏向锁</code>：当线程执行时，会去修改对象的对象头（Mark Word）中线程id，若是修改成功，执行。若是修改不成功，需要将偏向锁升级为轻量级锁。锁升级的过程是，该获取锁的线程通知Mark Word中标识的线程，使其进入暂停状态。</p><p>​    <code>轻量级锁</code>：争抢锁的线程会去将对象的对象头（Mark Word）拷贝的线程栈中，并将对象头指向该栈（cas操作），若是执行成功，获取到锁，执行代码。若是执行失败，自旋等待其它线程释放锁。</p><p>​    <code>重量级锁</code>：当自旋超过了一定的时间之后，若是还不能获取到锁，将会升级为重量级锁，线程阻塞。</p><hr><p><code>Lock接口</code></p><table><thead><tr><th>特性</th><th>描述</th></tr></thead><tbody><tr><td>尝试非阻塞的获取锁</td><td>当前线程尝试获取锁，若这一时刻锁没有被其它线程获取到，则成功获取并持有锁。</td></tr><tr><td>能被中断的获取锁</td><td>获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放。</td></tr><tr><td>超时获取锁</td><td>在指定的时间之前获取锁，如果过了指定的时间任然无法获取到锁，则返回。</td></tr></tbody></table><table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td>void lock()</td><td>线程获取锁，当获取到锁后，线程从该方法返回。</td></tr><tr><td>void lockInterruptibly() throws InteruptedExecption</td><td>与lock方法不同之处在于可以在获取锁的过程中中断当前的线程。</td></tr><tr><td>boolean tryLock()</td><td>尝试获取锁，获取到返回true，未获取到返回false。</td></tr><tr><td>boolean tryLock(long time, TimeUnit unit) throws InteruptedException;</td><td>尝试获取锁，下列三种情况下会返回：1.在指定的时间内获取到锁。2.过了超时时间为获取到锁。3.当前线程被中断。</td></tr><tr><td>void unlock()</td><td>释放锁</td></tr><tr><td>Condition newCondition()</td><td>获取等待通知组件，只有成功获取到了锁，才能创建该组件</td></tr></tbody></table><hr><p><code>lock和synchronized的区别</code></p><p>​        <code>关于加锁和释放锁方式和原理的不同</code></p><ul><li><p>synchronized是jvm层面提供的关键字，获取锁和释放锁不需要手工干预。synchronized获取锁时会获取锁定对象(静态方法-&gt;类对象，普通方法-&gt;当前对象，代码块-&gt;提供的对象)的对象监视器Monitor。一旦一个线程获取到这个对象的Monitor,其它线程就无法获取。但是同一个线程对这个Monitor可以多次获取（可重入）。对于锁的释放，当方法正常执行结束或者发生异常时，会释放该锁。</p></li><li><p>lock锁是jdk层面提供的锁，可以基于api执行上锁和解锁操作，操作更加的灵活。Lock接口实现的可重入锁ReentLock，其底层是依赖于AQS实现，AQS内部维护了一个同步队列，获取锁的线程会被加入到这个同步队列上面，等待前一个获取锁的节点释放锁时唤醒。ReentLock提供了多种获取锁的方式，可以在获取锁的时候立即响应中断。</p><p><code>关于等待队列和同步队列的不同</code></p></li><li><p>synchronized基于对象监视器，调用底层的wait方法时，会将线程加入到等待队列中，内部只维护了一个等待队列，而调用notify或者notifyAll时，会将唤醒的线程加入到同步队列。</p></li><li><p>ReentLock内部可以创建多个等待队列，可以调用await方法将获取到锁的线程加入到等待队列，也可以调用singal,singalAll唤醒线程，将其加入到同步队列中。</p></li></ul><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;&lt;code&gt;前戏&lt;/code&gt;java里面提供了两种锁机制，基于jvm层面实现的关键字synchronized和基于jdk层面实现的Lock锁。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;code&gt;synchronized关键字&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;基本使用&lt;
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="并发" scheme="https://zhilongao.github.io/categories/java/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="锁" scheme="https://zhilongao.github.io/categories/java/%E5%B9%B6%E5%8F%91/%E9%94%81/"/>
    
    
  </entry>
  
  <entry>
    <title>http</title>
    <link href="https://zhilongao.github.io/wiki/http/"/>
    <id>https://zhilongao.github.io/wiki/http/</id>
    <published>2019-08-24T01:51:41.000Z</published>
    <updated>2019-08-27T09:55:26.475Z</updated>
    
    <content type="html"><![CDATA[<hr><ol><li><p>对http协议的理解</p><p>​    http协议是一种基于客户端-&gt;服务器模式的协议，客户端发送请求，服务器返回响应。http协议通过uri定位访问的资源。http协议是一种无状态的协议，服务 器无法识别同一浏览器的前后两次请求（为解决无状态,浏览器端引入了cookie机制）。</p></li></ol><hr><ol start="2"><li>http响应状态码</li></ol><table><thead><tr><th>状态码</th><th>类别</th><th>原因短语</th></tr></thead><tbody><tr><td>1XX</td><td>Informational（信息性状态码）</td><td>接收的请求正在处理</td></tr><tr><td>2XX</td><td>Success（成功状态码）</td><td>请求正常处理完毕</td></tr><tr><td>3XX</td><td>Redirection（重定向状态码）</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td>Client Error（客户端错误）</td><td>服务器无法处理请求</td></tr><tr><td>5XX</td><td>Server Error （服务端错误）</td><td>服务器处理请求出错</td></tr></tbody></table><hr><ol start="3"><li><p>http请求首部常用字段</p><p>Accept：用户代理可处理的媒体类型。</p><p>Accept-Encoding：优先的内容编码。</p><p>Accept-Language：优先的语言。</p><p>Content-Type：实体类型。</p></li></ol><hr><ol start="4"><li>跨域问题</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;对http协议的理解&lt;/p&gt;
&lt;p&gt;​    http协议是一种基于客户端-&amp;gt;服务器模式的协议，客户端发送请求，服务器返回响应。http协议通过uri定位访问的资源。http协议是一种无状态的协议，服务 器无法识别同一浏览器的前后两次请求（
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="分布式" scheme="https://zhilongao.github.io/categories/java/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="协议" scheme="https://zhilongao.github.io/categories/java/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%8D%8F%E8%AE%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>io</title>
    <link href="https://zhilongao.github.io/wiki/io/"/>
    <id>https://zhilongao.github.io/wiki/io/</id>
    <published>2019-08-23T09:43:24.000Z</published>
    <updated>2019-08-31T03:59:42.888Z</updated>
    
    <content type="html"><![CDATA[<hr><p>1.在jdk1.4，java引入了nio，nio是一种非阻塞io。</p><hr><ol start="2"><li>在nio中有三个概念</li></ol><ul><li><p>缓冲区(buffer)：java nio中数据的读取和存放需要通过缓冲区。</p></li><li><p>通道(channel)：可以理解为io中流的概念 ，与流不同的是，一个通道中既可以进行数据的读取，也可以进行数据的写入，而在io模型中，数据的读取和写入会有专门的输入和输出流来进行操作。</p></li><li><p>选择器(select)：通道可以在选择器上注册相关的事件，而选择器会有一个专门的线程来负责轮询这些事件，当某个写入事件或是读取事件可写或可读时，会交给相应的线程来处理。</p></li></ul><hr><ol start="3"><li>通过java nio模拟一个服务端-客户端通信的实例</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * NIO Server服务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span></span>&#123;</span><br><span class="line">    <span class="comment">// Selector-&gt;注册channel</span></span><br><span class="line">    Selector selector = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// ServerSocketChannel-&gt;服务端channel,类似ServerSocket</span></span><br><span class="line">    ServerSocketChannel serverSocketChannel;</span><br><span class="line">    <span class="comment">// 处理selector轮询事件</span></span><br><span class="line">    <span class="keyword">private</span> ChannelHandle handle;</span><br><span class="line">    <span class="comment">// NIO服务关闭标识</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    NIOServer(<span class="keyword">int</span> port) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">            <span class="comment">// 设置channel为非阻塞模式</span></span><br><span class="line">            serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 为channel绑定端口</span></span><br><span class="line">            serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">            <span class="comment">// 将channel注册到selector上，监听连接事件</span></span><br><span class="line">            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            handle = <span class="keyword">new</span> ChannelHandle();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动服务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">            <span class="comment">// 获取到等待处理的IO事件数量</span></span><br><span class="line">            <span class="keyword">int</span> readyChannels = selector.select();</span><br><span class="line">            <span class="comment">// 若是等待处理的IO事件数量为0,不处理</span></span><br><span class="line">            <span class="keyword">if</span> (readyChannels == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="comment">// 处理这些SelectionKey</span></span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                <span class="comment">// 获取到该key</span></span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line">                <span class="comment">// 移除该key</span></span><br><span class="line">                iterator.remove();</span><br><span class="line">                <span class="comment">// 分别处理各自事件</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    handle.handleAccept(key);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                    handle.handleRead(key);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">                    handle.handleWrite(key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止该服务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stop = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 针对selector上不同事件的处理类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChannelHandle</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理连接事件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleAccept</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel ssc = (ServerSocketChannel) key.channel();</span><br><span class="line">        SocketChannel sc = ssc.accept();</span><br><span class="line">        sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        sc.register(key.selector(), SelectionKey.OP_READ);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理可读事件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRead</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">        <span class="comment">// fixme 对读取到的数据进行处理-&gt;相关协议解析</span></span><br><span class="line">        sc.register(key.selector(), SelectionKey.OP_WRITE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理可写事件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleWrite</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"处理写数据"</span>);</span><br><span class="line">        <span class="comment">// fixme 对输出结果按照相关协议进行封装</span></span><br><span class="line">        String header = <span class="string">"HTTP/1.1 200 OK\r\n"</span>;</span><br><span class="line">        StringBuffer result = <span class="keyword">new</span> StringBuffer(header);</span><br><span class="line">        result.append(<span class="string">"Content-Type:application/json\n"</span>);</span><br><span class="line">        result.append(<span class="string">"\r\n"</span>);</span><br><span class="line">        result.append(<span class="string">"hello,world"</span>);</span><br><span class="line">        SocketChannel channel = (SocketChannel)key.channel();</span><br><span class="line">        ByteBuffer wrap = ByteBuffer.wrap(result.toString().getBytes());</span><br><span class="line">        channel.write(wrap);</span><br><span class="line">        channel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 启动一个基于NIO的服务</span></span><br><span class="line">        NIOServer nioServer = <span class="keyword">new</span> NIOServer(<span class="number">8070</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            nioServer.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>下面是通过java io的方式来实现的</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IOServer.createServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOServer</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开启服务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService =</span><br><span class="line">                Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8090</span>);</span><br><span class="line">            System.out.println(<span class="string">"服务器在端口8090上启动。。。"</span>);</span><br><span class="line">            <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Socket socket = serverSocket.accept();</span><br><span class="line">                    <span class="comment">// 将任务提交给线程池来处理</span></span><br><span class="line">                    executorService.execute(<span class="keyword">new</span> SocketHandle(socket));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (serverSocket !=  <span class="keyword">null</span>) &#123;</span><br><span class="line">                    serverSocket.close();</span><br><span class="line">                &#125;</span><br><span class="line">                executorService.shutdown();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭服务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stopServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stop = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * socket处理线程类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SocketHandle</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">    SocketHandle(Socket socket) &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理输入</span></span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        InputStreamReader isr = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            is = socket.getInputStream();</span><br><span class="line">            isr = <span class="keyword">new</span> InputStreamReader(is);</span><br><span class="line">            br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">            String s = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> ((s = br.readLine()) != <span class="keyword">null</span> &amp;&amp; s.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">                s = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理输出 \r\n 回车换行</span></span><br><span class="line">        OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            os = socket.getOutputStream();</span><br><span class="line">            os.write(<span class="string">"HTTP/1.1 200 OK\r\n"</span>.getBytes());</span><br><span class="line">            os.write(<span class="string">"Content-Type:application/json\n"</span>.getBytes());</span><br><span class="line">            os.write(<span class="string">"\r\n"</span>.getBytes());</span><br><span class="line">            os.write(<span class="string">"hello,world"</span>.getBytes());</span><br><span class="line">            os.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;1.在jdk1.4，java引入了nio，nio是一种非阻塞io。&lt;/p&gt;
&lt;hr&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;在nio中有三个概念&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;缓冲区(buffer)：java nio中数据的读取和存放需要通过缓冲区
      
    
    </summary>
    
      <category term="java" scheme="https://zhilongao.github.io/categories/java/"/>
    
      <category term="基础" scheme="https://zhilongao.github.io/categories/java/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="io" scheme="https://zhilongao.github.io/categories/java/%E5%9F%BA%E7%A1%80/io/"/>
    
    
  </entry>
  
</feed>
